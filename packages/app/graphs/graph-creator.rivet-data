{"datasets":[{"meta":{"id":"JSKwa7CCs75tPqXRToLj4","projectId":"wHxyeNIJLo2ZrylGbkznh","name":"Node Summaries","description":""},"data":{"id":"JSKwa7CCs75tPqXRToLj4","rows":[{"id":"fFUHwkCQkvYepcKvI8QS7","data":["The SubGraphNode in Rivet is a specialized node designed to execute another graph within an AI agent's workflow, allowing for modular and reusable graph structures. It facilitates the integration of existing graphs by defining inputs and outputs through Graph Input and Graph Output nodes, enabling users to pass data seamlessly between different graph components. The node can be configured to use error outputs, providing robust error handling during execution. This makes the SubGraphNode particularly useful for creating complex AI workflows that require the execution of multiple interconnected graphs, enhancing both the organization and reusability of AI prompt chains."]},{"id":"e2GDkyB6y6rT-SloWACE4","data":["The `LoadDatasetNode` is a component within the Rivet framework designed to facilitate the loading of datasets using a specified dataset ID. This node allows users to input a dataset ID, either through a direct input or by selecting from available datasets, and retrieves the corresponding dataset from a dataset provider. Upon successful retrieval, it outputs the dataset as an array of objects along with the dataset ID. If the specified dataset does not exist, the node throws an error, ensuring robust error handling. This functionality is essential for integrating data-driven decision-making into AI agents, enabling them to access and utilize datasets dynamically during their processes."]},{"id":"IOxNPP_5R1E1zaX6LWbQb","data":["The BooleanNode in Rivet is a versatile component designed to output a boolean constant or convert an input value into a boolean. It allows users to either define a fixed boolean value or utilize an input port to dynamically determine the boolean output based on incoming data. The node features a toggle editor for easy configuration of its value and supports optional input, making it useful for scenarios where boolean logic is needed, such as condition checks, flow control in AI prompt chains, or decision-making processes within AI agents. By providing clear output definitions and an intuitive interface, the BooleanNode enhances the flexibility and functionality of AI agent development within the Rivet environment."]},{"id":"TG3itS3Y8tXKjCqBKXGXt","data":["The Slice Node in Rivet is designed to extract a portion of an array based on specified start and count parameters, making it a valuable tool for manipulating lists. It allows users to define a starting index and the number of elements to slice from an input array, with options to either use fixed values or dynamic inputs for these parameters. This functionality is particularly useful for scenarios where you need to process or analyze specific segments of data within larger datasets, enabling efficient data handling and extraction in AI agent workflows."]},{"id":"cy1fJzQEVWxYz_ahF6lAM","data":["The `HttpCallNode` in Rivet is a specialized component designed for making HTTP requests within AI agent workflows. It allows users to configure various parameters such as the HTTP method (GET, POST, PUT, DELETE), URL, headers, and body of the request, enabling flexible interactions with web APIs. The node supports both binary and textual responses, and it can handle JSON parsing automatically based on the response content type. Additionally, it provides options for error handling on non-200 status codes and integrates seamlessly into the visual, graph-based interface of Rivet, making it an essential tool for developers looking to enhance their AI agents with external data retrieval capabilities."]},{"id":"-WFm_PpisggdqUsACgkx4","data":["The GPT Function Node in Rivet is designed to define a callable function for a GPT language model, allowing it to execute specific tasks based on structured inputs and outputs. This node facilitates the integration of user-defined functions into AI prompt chains by enabling developers to specify the function's name, description, and schema, which outlines the expected structure of input data. With options for strict parameter enforcement and the ability to dynamically generate input fields based on the provided schema, the GPT Function Node enhances the flexibility and capability of AI agents. It processes inputs to create a structured function that the language model can invoke, making it a powerful tool for developers looking to extend their AI applications with customized functionalities."]},{"id":"R7CuB0ej2KjI0EafKLEkc","data":["The Match Node in Rivet is a versatile component designed for evaluating input strings against a series of regular expressions, allowing users to define multiple cases that dictate the output based on the input's match status. It can be configured to either return the first matching case or all matches, depending on the exclusive setting. This functionality is particularly useful for scenarios such as input validation, conditional branching in AI workflows, or processing text data where different responses are required based on specific patterns. The node outputs the corresponding value for the matched case while providing a fallback for unmatched inputs, making it an essential tool for implementing logic and control flow in AI agent designs."]},{"id":"tZ_GX5uLd_G5jLxluwuI5","data":["The Destructure Node in Rivet is a specialized node designed for extracting values from complex objects using JSONPath notation. It allows users to specify one or more JSONPath expressions, each corresponding to an output port of the node. When provided with an input object, the node processes the specified paths and outputs the matched values, enabling developers to easily navigate and manipulate structured data within their AI prompt chains. This functionality is particularly useful for scenarios where data needs to be dissected for further processing or analysis, enhancing the flexibility and capability of AI agents created using the Rivet IDE."]},{"id":"fYyG9rArUM37A7qN-l3uy","data":["The Extract Object Path Node is a component in the Rivet IDE designed to extract values from complex data structures using JSONPath notation. It allows users to specify a path to navigate through an input object, retrieving a single match or all matches that correspond to the given path. The node features an optional input for the path, enabling dynamic extraction based on user-defined criteria. Its output includes the first match found and an array of all matches, making it particularly useful for processing and analyzing structured data formats like JSON. This node enhances the flexibility and efficiency of AI agent workflows by enabling precise data manipulation and retrieval."]},{"id":"-Q9mcnWBfWoy-zbbybWdC","data":["The Pop Node is a versatile component in the Rivet IDE designed for manipulating arrays by extracting elements from them. It allows users to pop either the first or the last item from an input array, depending on the configuration set in the node's properties. The node outputs the extracted item as well as the remaining elements of the array, making it useful for tasks that require dynamic array manipulation, such as processing lists in AI workflows or managing data sequences. With its toggle feature, users can easily switch between popping from the front or the back of the array, enhancing the flexibility of data handling in AI agent designs."]},{"id":"W3ab1F7qeg7j71tT9b0v6","data":["The Join Node in Rivet is designed to take an array of strings and concatenate them into a single string using a specified delimiter, which can be customized by the user. This node features a toggle option to flatten nested arrays, allowing for more flexible input handling. Users can define the joining string, with the default being a newline character, and can choose to input a different joining string dynamically. The Join Node is particularly useful for scenarios where multiple text inputs need to be combined into a cohesive output, such as formatting messages, generating reports, or preparing data for further processing in AI workflows."]},{"id":"y-j2pcrmOT7oB2bxM749V","data":["The Delegate Function Call Node in Rivet is designed to handle function calls by delegating them to specific subgraphs based on the function name provided in the call. It allows developers to define multiple handlers that map function names to their corresponding subgraph identifiers, enabling flexible and dynamic routing of function calls. If a function call does not match any defined handler, it can be directed to an \"unknown handler,\" ensuring that the system remains robust even when unexpected inputs are encountered. This node is particularly useful for creating modular AI agents that can process a variety of function calls efficiently, facilitating a clean and organized approach to managing complex AI interactions within the Rivet framework."]},{"id":"SYAauHVX63t5H42lDal9D","data":["The Play Audio Node in Rivet is designed to facilitate the playback of audio data within AI agent workflows. It allows users to input audio data, which can then be processed and played through an audio provider in the application's context. This node features a straightforward input-output structure, where it accepts audio data as input and returns the same data after playback, ensuring seamless integration within complex AI prompt chains. The Play Audio Node is particularly useful for applications that require audio feedback, such as interactive voice agents or multimedia presentations, enhancing user engagement through auditory experiences."]},{"id":"L2ScUWgRqOTxtDfQBLlMV","data":["The Shuffle Node in Rivet is designed to randomly reorder the elements of an input array, providing a shuffled output array. This node is particularly useful in scenarios where a randomized arrangement of data is required, such as in games, simulations, or when testing algorithms that rely on varying input sequences. By accepting an array as input and returning the shuffled version, the Shuffle Node enhances the flexibility and functionality of AI prompt chains, enabling developers to incorporate randomness into their AI agents' decision-making processes or data handling."]},{"id":"nFh7Kho3kv7haIV_oeWd7","data":["The Vector Store Node is a component within the Rivet framework designed for storing vectors alongside associated data in a specified vector database integration, such as Pinecone. This node accepts inputs including a vector, optional collection ID, integration type, and additional data, allowing users to dynamically configure its behavior. It processes the inputs to store the vector and its related data in the configured database, facilitating later retrieval. With its visual interface and integrated debugging capabilities, the Vector Store Node simplifies the management of vector data, making it a valuable tool for developers working on AI applications that require efficient data storage and retrieval mechanisms."]},{"id":"5ZxBBCSyk3rkTsI-x1Ri3","data":["The Chunk Node in Rivet is designed to split input text into an array of chunks based on a specified token count, making it particularly useful for processing large text inputs in AI applications. It allows users to define the number of tokens per chunk, the overlap percentage between chunks for redundancy, and the model to be used for tokenization. The node outputs several useful data points, including the array of chunks, the first and last chunks, their respective indexes, and the total count of chunks created. This functionality is essential for efficiently managing and analyzing large text data, ensuring that AI models can handle inputs without exceeding token limits while maintaining context through overlapping segments."]},{"id":"S9auIshZScS9t92rzbVQH","data":["The Context Node in Rivet is designed to retrieve values from the graph's context using a specified identifier, effectively acting as a \"global graph input\" that allows consistent access to values across different graphs or subgraphs. It is configurable, enabling users to define the data type and optionally provide a default value if the desired context value is not found. This node enhances the flexibility and reusability of AI prompt chains by allowing dynamic data retrieval based on the context, which is particularly useful in complex scenarios where multiple agents or processes may need to share and utilize the same data seamlessly."]},{"id":"WAE8KCklsiIQ6euG05uXO","data":["The Prompt Node in Rivet serves as a versatile component for generating chat messages within AI agent workflows. It allows users to define the type of message (system, user, assistant, or function) and customize the prompt text using interpolation, enabling dynamic content generation based on input values. The node can also handle function calls, making it suitable for integrating external functionalities, and it provides options for calculating token counts for the generated messages. With its ability to output structured chat messages, including optional metadata like names and cache breakpoints, the Prompt Node is essential for creating interactive and context-aware AI agents that can seamlessly communicate within various applications."]},{"id":"lLunx3hLQN2fyTxGyoT-7","data":["The UrlReferenceNode in Rivet is designed to define a reference to a URL or convert a string input into a URL reference, making it particularly useful for creating dynamic links in AI prompt chains. This node allows users to specify a URL directly or utilize an input string as a URL, enabling flexibility in how URLs are handled within the graph. The output of this node is an object containing the URL reference, which can be integrated with other nodes, such as the Assemble Message node, to facilitate the inclusion of URLs for attachments or images in AI-generated content. Additionally, the node features a user-friendly editor for easy configuration and real-time debugging capabilities to monitor its functionality within the overall AI agent workflow."]},{"id":"vQnwqhKe-2jSYCGKZzB0x","data":["The Coalesce Node in Rivet is a logic-based node that takes in multiple input values and outputs the first available value that exists, effectively consolidating branches in a decision-making process. It is particularly useful for scenarios where you want to prioritize certain inputs over others, such as after a Match node, ensuring that the first non-null input is returned. Additionally, the Coalesce Node can handle control-flow exclusions, allowing it to operate seamlessly in complex AI prompt chains by managing situations where no valid input is present. This functionality makes it an essential tool for creating robust and flexible AI agents that can adapt to varying input conditions."]},{"id":"3vQ3e3vwOZ8QoxRXfegYJ","data":["The `AppendToDatasetNode` is a specialized node within the Rivet framework designed to facilitate the appending of data rows to a specified dataset. This node allows users to input various types of data, including strings, arrays of strings, and vector embeddings, which can be associated with each row. It provides the option to specify a unique identifier for the row, generating one randomly if not provided. The node integrates seamlessly with Rivet's visual graph-based interface, enabling users to visually construct and manage their AI workflows. By utilizing this node, developers can effectively enrich their datasets with new information, making it a valuable tool for applications that require dynamic data management and storage in AI-driven projects."]},{"id":"wIGcsY5Ka9vJN8mFf7JPE","data":["The `RaiseEventNode` is a component within the Rivet IDE that allows users to trigger events within their AI agent workflows. It enables the user to specify an event name, which can either be a predefined string or dynamically provided through an input, along with associated data to be sent with the event. This functionality is particularly useful for creating interactive and responsive AI applications, as it facilitates communication between different parts of the system, such as triggering responses in other nodes or allowing external listeners to react to specific events. The node's design includes options for visual configuration and real-time debugging, enhancing the user's ability to manage complex event-driven behaviors within their AI projects."]},{"id":"xdP7ZQYXiBFL5QWRP2pOa","data":["The **Trim Chat Messages Node** is a specialized component within the Rivet IDE that processes an array of chat messages to ensure the total token count remains within a specified limit. It allows users to configure parameters such as the maximum token count and whether to remove messages from the beginning or the end of the array. This functionality is particularly useful for managing message chains in AI applications, ensuring that the input stays within the context limits of language models. By dynamically trimming chat messages, this node helps maintain efficient communication while preventing overflow issues in AI interactions."]},{"id":"rGBrJHs4VfzWZlk4E1RM-","data":["The `CreateDatasetNode` is a component of the Rivet IDE that facilitates the creation of a new dataset within an AI agent's workflow. It allows users to specify a unique Dataset ID and a Dataset Name as inputs. When processed, the node checks if a dataset with the given ID already exists; if not, it creates a new dataset with the provided metadata. This functionality is particularly useful for managing datasets dynamically within AI applications, enabling seamless integration and organization of data as the AI agent operates. The output of the node provides the Dataset ID, which can be used in subsequent nodes for further processing or analysis."]},{"id":"uSOXRpVErge-sn80K6dKz","data":["The Loop Controller Node in Rivet is designed to manage iterative processes within AI prompt chains, allowing users to define and control the flow of execution based on specified conditions. It enables the creation of loops by providing input ports for data and a \"continue\" control port to dictate whether the loop should proceed or break. Users can set a maximum number of iterations and specify actions to take when this limit is reached, such as breaking the loop or triggering an error. This node is particularly useful for scenarios where repeated processing of data is required, such as in simulations, batch processing tasks, or when implementing complex decision-making workflows that depend on previous iterations' outputs."]},{"id":"wRfdmGs8G_RYMrVDwXjkk","data":["The `GraphInputNode` is a component within the Rivet framework that defines an input for a graph, enabling users to pass in values when the graph is executed or to establish input ports for subgraphs. This node allows for the configuration of various attributes, including the input's ID, data type, and an optional default value. Users can also select from different editor types to tailor the user interface for editing the input value. During processing, the node retrieves the value from the graph's inputs or defaults to a specified value if none is provided, ensuring flexibility in handling different data types and accommodating scenarios where input may be absent. Overall, the `GraphInputNode` is essential for creating dynamic and interactive AI agent workflows in Rivet."]},{"id":"XYgpr4UrSRKca5mxn3yrA","data":["The Object Node in Rivet is designed to create structured objects from input values using a customizable JSON template. It allows users to define a template that incorporates dynamic input values, which are automatically escaped for safe insertion. This node is particularly useful for generating complex objects from multiple inputs, enabling users to easily format and manipulate data in a structured way. With its ability to interpolate values within the template and produce outputs as either individual objects or arrays of objects, the Object Node serves as a versatile tool for developers looking to streamline data handling in their AI agent workflows."]},{"id":"SlVX0FrUteaVJV2nuM-ED","data":["The Passthrough Node in Rivet is a simple yet versatile component designed to facilitate the flow of data within AI prompt chains by directly passing input values to their corresponding outputs without any modifications. This node is particularly useful for scenarios where data needs to be relayed from one part of the graph to another, allowing developers to maintain a clear flow of information while debugging or testing different configurations. With its dynamic input and output definitions based on connections, the Passthrough Node can adapt to various setups, making it an essential tool for managing data transfer in complex AI agent workflows."]},{"id":"o6BFdR-vOhQ39EDM9gt7u","data":["The `GetGlobalNode` is a specialized node within the Rivet IDE designed to retrieve global values that are shared across all graphs and subgraphs. It allows users to specify a variable ID, choose the data type of the value to be retrieved, and configure whether the value should be fetched on-demand or wait for its availability. This node can be particularly useful in scenarios where multiple agents or processes need to access and utilize shared data consistently, enabling dynamic and responsive AI behavior. It supports both immediate retrieval and deferred access, enhancing flexibility in managing global state within AI workflows."]},{"id":"I6mI5TEI0ugW26XhTEGiX","data":["The Compare Node in Rivet is a versatile logic node that enables users to perform various comparison operations between two input values, labeled as A and B. It supports a range of comparison functions, including equality checks (==, !=), relational comparisons (<, >, <=, >=), and logical operations (and, or, xor, nand, nor, xnor). Users can configure the node to either use a predefined comparison function or provide a custom function as an input. The output of the node is a boolean value indicating the result of the comparison, making it useful for decision-making processes within AI agent workflows, conditional branching, and logical evaluations in complex AI prompt chains. With its visual representation and live debugging capabilities, the Compare Node simplifies the integration of logical operations into AI applications."]},{"id":"D213W80MpIaHs0gfEsrsL","data":["The Array Node in Rivet is designed to create and manipulate arrays from input values, offering functionality to flatten nested arrays based on user-defined options. It allows users to dynamically connect multiple inputs, which can be either individual values or arrays. The node provides two main configurations: a standard flattening option that merges input arrays into a single array, and a deep flattening option that recursively flattens nested arrays. The output of the node includes the constructed array, its indices, and the length of the array, making it a versatile tool for both generating and merging arrays within AI prompt chains. This node is particularly useful for organizing and processing data in a structured manner, enhancing the capabilities of AI agents in handling complex data structures."]},{"id":"HN1HYhvhQo9OqIm51mSoq","data":["The Abort Graph Node in Rivet is a specialized node designed to terminate the execution of an AI prompt chain or graph immediately, allowing for controlled exits based on specific conditions. It provides the ability to abort the graph either successfully or with an error message, enabling developers to handle different scenarios during the execution flow. The node can be configured to take inputs that determine whether the abort is successful or erroneous, and it can output a custom error message if needed. This flexibility makes it a crucial component for managing the control flow in complex AI agent workflows, ensuring that processes can be halted gracefully when necessary."]},{"id":"4nvLCxsg9-kCLUEAqDFul","data":["The **Extract Markdown Code Blocks Node** is a specialized component within the Rivet IDE that enables users to extract code blocks from Markdown text inputs. Utilizing a regular expression, this node identifies and retrieves the first code block, all code blocks, and the programming languages associated with each block from the provided input string. It outputs three distinct values: the first matched code block as a string, an array of all matched code blocks, and an array of the corresponding languages. This functionality is particularly useful for developers and content creators who need to process and analyze code snippets embedded within Markdown documents, facilitating tasks such as code extraction, analysis, and transformation in AI-driven applications."]},{"id":"ZYbHc2F3wQWbfkmVAFl2v","data":["The Vector KNN (K-Nearest Neighbors) node in Rivet is designed to perform k-nearest neighbors searches on vector data stored within a configured vector database integration, such as Pinecone. By taking a vector as input, this node retrieves the k closest vectors along with their associated data, making it useful for applications in recommendation systems, similarity searches, and clustering tasks. It allows users to dynamically specify parameters such as the integration type, the number of neighbors (k), and the collection ID, enabling flexible and efficient data retrieval based on vector proximity."]},{"id":"8H4MadAXOrfnyPEuDef4O","data":["The Evaluate Node in Rivet is designed to perform mathematical operations on input values, allowing users to evaluate expressions and obtain results dynamically. It supports a variety of operations, including addition, subtraction, multiplication, division, exponentiation, modulus, and unary operations like absolute value and negation. The node can take one or two numeric inputs, depending on the selected operation, and can also accept an operation type as a string input for greater flexibility. This node is particularly useful for integrating mathematical calculations into AI workflows, enabling the creation of complex logic and data manipulations within the visual graph-based interface of the Rivet IDE."]},{"id":"j-ARO2y8yPb6umpjIPx0i","data":["The `UserInputNode` in Rivet is designed to prompt users for input during the execution of an AI graph, allowing for dynamic interaction within AI agent workflows. It can be configured to either use predefined questions or a single custom prompt, enabling flexibility in user engagement. The node outputs the user's responses, providing both answers only and a combined list of questions and answers. Additionally, it supports different rendering formats, such as preformatted text and markdown, enhancing the presentation of the user interface. This node is particularly useful for applications that require real-time user feedback or interaction, making it an essential component for creating responsive AI agents."]},{"id":"3dD66i3eLFkEv88nfA2yT","data":["The `DocumentNode` in Rivet is a specialized node designed for handling documents within AI agent workflows. It allows users to input various types of document data, including text and binary formats, and provides options to specify the media type, title, context, and whether citations should be enabled. This node can be particularly useful for integrating documents into AI processes, such as assembling messages or processing information, by facilitating the management and manipulation of document-related data. With its visual interface, users can easily configure input options and monitor the document's attributes, making it an essential component for applications that require document handling and processing in AI workflows."]},{"id":"Td8bAsWWqWqrR7vj80qKn","data":["The Assemble Prompt Node in Rivet is designed to dynamically compile an array of chat messages into a single prompt for use with Chat nodes. It allows users to input multiple messages, which can be either strings or chat message objects, and assembles them into a structured format. This node provides options to compute the token count of the resulting prompt and to designate the last message as a cache breakpoint, which is particularly useful for optimizing performance in AI interactions. By visually connecting this node within a graph, developers can easily manage and debug the flow of messages, making it an essential tool for creating complex AI agent interactions in Rivet."]},{"id":"Cmb9rvrqU7L2RIxAiLkTy","data":["The `GetDatasetRowNode` is a component within the Rivet IDE that enables users to retrieve a specific row from a dataset based on a provided dataset ID and row ID. This node is particularly useful for AI agents that require access to structured data, allowing them to dynamically pull in relevant information for processing or decision-making. The node features configurable inputs for both dataset and row IDs, supporting flexibility in how data is accessed. If the specified dataset or row does not exist, the node will throw an error, ensuring that users are promptly informed of any issues. Overall, this node facilitates efficient data handling within AI prompt chains, enhancing the capabilities of AI agents in data-driven applications."]},{"id":"H0XVxpYSzMa3_b8rQVc1b","data":["The `ToJsonNode` is a component in Rivet designed to convert input data into its JSON string representation. It offers functionality to toggle between indented and non-indented formats for better readability. This node requires an input of any data type and outputs the corresponding JSON string, making it useful for scenarios where data needs to be serialized for storage, transmission, or further processing in a JSON-compatible format. The node's visual interface allows users to easily integrate it into their AI prompt chains, facilitating the transformation of complex data structures into a widely-used format for APIs, databases, or other applications."]},{"id":"SK9HxYE7KiQvh0bauDD5D","data":["The `WaitForEventNode` is a specialized node within the Rivet framework designed to pause the execution of an AI agent until a specified event is triggered. It allows users to configure an event name, which can be either set directly or provided via input, enabling flexibility in how events are managed within prompt chains. When the node is activated, it listens for the designated event, and upon its occurrence, it captures any associated data. This functionality is particularly useful for creating interactive AI agents that need to respond to user actions or other external triggers, facilitating complex workflows that rely on real-time events."]},{"id":"QPGyaRosebPfH30NlJ8Ba","data":["The AudioNode in Rivet is designed to handle audio data within AI agent workflows, enabling users to define and manipulate audio samples for integration with other nodes. This node allows for the input of audio files through a file browser, supporting various media types such as WAV, MP3, and OGG. It features options for users to either directly input binary audio data or reference external audio data stored in a project. The AudioNode processes the input data and outputs it in a structured format, making it suitable for tasks that involve audio processing, playback, or analysis in AI applications. Its visual representation in the Rivet editor facilitates easy configuration and debugging, enhancing the development experience for AI agents that utilize audio content."]},{"id":"YM4kDBUraQqvp8n_qVP6A","data":["The `GetAllDatasetsNode` is a specialized node within the Rivet framework designed to retrieve all datasets associated with a specific project. When executed, it queries a `datasetProvider` to fetch the datasets linked to the project's metadata ID. If no datasets are found, it returns an empty array, ensuring that the output is always consistent. This node is particularly useful for AI agents that require access to available datasets for processing or analysis, enabling seamless integration and management of data within complex AI prompt chains and workflows."]},{"id":"4Ab1wp16GnNTOYmKYJAoi","data":["The **Get Embedding Node** in Rivet is designed to generate vector embeddings for input text using AI integrations, primarily OpenAI. It allows users to specify various parameters such as the integration type, model, and dimensions of the embedding, either through predefined settings or dynamic inputs. This node processes the input text and outputs a vector representation, which can be utilized in various applications, including vector storage and nearest neighbor search functionalities. Its flexibility in configuration makes it an essential tool for developers looking to enhance AI-driven applications with advanced text processing capabilities."]},{"id":"H7yqeascU5-aYdSfCohCz","data":["The Read File Node in Rivet is designed to read the contents of a specified file and output it as either a string or binary data, depending on the user's configuration. It offers flexibility through options such as using a path input, reading as binary, and handling errors for missing files. When integrated into an AI agent's prompt chain, this node can facilitate tasks that require file input, such as processing text files for natural language tasks or reading binary files for data analysis. The node's ability to handle errors gracefully allows for robust implementations, making it a valuable tool for developers working with file-based data in their AI applications."]},{"id":"lPdgh27W_sEFUrPiziZWF","data":["The `GraphOutputNode` is a specialized node in the Rivet IDE designed to represent individual outputs of a graph, facilitating the management of data flow within AI prompt chains. This node allows users to define an output value, which is then included as part of the overall output of the graph. It features input and output definitions for handling data, customizable editors for setting the output ID and data type, and a body description that provides context on its functionality. The node also supports control flow management by distinguishing between regular outputs and control-flow-excluded values, ensuring that the output reflects the current state of the graph accurately. This makes the `GraphOutputNode` essential for structuring and retrieving results from complex AI processes visually."]},{"id":"qppx3239UrIpsSsBRCQTS","data":["The `ChatNode` in Rivet is a versatile component designed for generating conversational responses using AI models, particularly from the OpenAI API. It allows users to configure various parameters such as model selection, temperature, top-p sampling, maximum token limits, and response formats, enabling fine-tuning of the AI's output. The node can handle both text and audio modalities, making it suitable for applications that require rich interaction, including chatbots and voice assistants. Additionally, it supports features like function calling, response caching, and usage statistics, making it a powerful tool for developers looking to integrate AI-driven conversational capabilities into their applications."]},{"id":"IHAdRHozYR_TI0ph6E3R9","data":["The Extract Regex Node in Rivet is designed to extract specific data from input text using a configurable regular expression. This node allows users to define a regex pattern that can include capture groups, enabling the retrieval of particular segments of text from the input string. It features options for error handling, such as throwing an error when no matches are found, and supports multiline input processing. The node outputs the captured groups as well as an array of all matches found, along with boolean indicators to signal the success or failure of the extraction process. This functionality is particularly useful for tasks such as data parsing, text analysis, and any scenario where structured information needs to be extracted from unstructured text."]},{"id":"c5q5y2dBewG1V4dMdlBKm","data":["The Number Node in Rivet is a versatile component designed for handling numerical data within AI prompt chains. It can either output a constant number or convert an input value into a number, offering flexibility in data processing. Users can configure the node to round the output to a specified number of decimal places, enhancing precision as needed. This node is particularly useful in scenarios where numerical manipulation is required, such as calculations, data formatting, or preparing numerical inputs for further processing in AI workflows. The node's visual representation and real-time processing capabilities make it easy to integrate and debug within the graph-based interface of Rivet."]},{"id":"Uc_wfPAjqNtb5HwBbSOs-","data":["The Comment Node in Rivet is a specialized node designed for adding annotations or notes within a graph without performing any functional operations. It allows users to include descriptive text, which can be formatted in Markdown, alongside customizable visual attributes such as color and background color. This node serves as a valuable tool for enhancing the clarity and organization of complex AI prompt chains by providing context and explanations directly within the visual interface, making it easier for developers to understand the purpose and flow of the graph at a glance. The Comment Node is particularly useful in collaborative environments where multiple users may need to reference or comprehend the logic behind various components of the AI agent."]},{"id":"iHkM2LdXwvhVH3dhCRJLz","data":["The `ReplaceDatasetNode` is a component in the Rivet IDE that facilitates the replacement of data within a specified dataset. It allows users to input new data, which can be in the form of an array of strings or an array of `DatasetRow` objects, and replaces the existing dataset with this new data. If no data is provided, the node will clear the dataset instead. This node is particularly useful for dynamically updating datasets during the execution of AI agents, enabling seamless data management and manipulation within the visual prompt chains created in Rivet. Additionally, it provides options for selecting the dataset ID, ensuring that users can easily target and modify the correct dataset in their workflows."]},{"id":"e2go1E5zH-rbYu0cZhb4q","data":["The External Call Node in Rivet serves as a bridge between the Rivet graph and external functions defined within the host project. This node allows users to invoke functions dynamically by specifying the function name and passing arguments, either directly or through input. It features options for error handling, enabling the user to choose whether to capture errors as output or to throw exceptions. This functionality is particularly useful for integrating Rivet's AI capabilities with existing application logic, allowing for seamless execution of external processes while maintaining control over the data flow and error management in AI agent workflows."]},{"id":"03j3m56fTG3YDs3uZda0I","data":["The Filter Node in Rivet is designed to process an array of values alongside a corresponding array of boolean indicators, effectively filtering the input array based on the truthiness of the boolean values. When executed, it takes in two inputs: an array and a boolean array of the same length, and returns a new array containing only the elements from the input array where the corresponding boolean value is true. This functionality is particularly useful for scenarios where selective data extraction is required, allowing users to efficiently manage and manipulate datasets based on specific criteria. The node's visual representation and real-time processing capabilities make it an intuitive choice for developers working with complex data flows in AI agent development."]},{"id":"NvojsE7xnxUsKIA3Y1ZA0","data":["The Set Global Node in Rivet is designed to define and manage global variables that can be accessed across multiple graphs and subgraphs within an AI agent's workflow. This node allows users to set a global value by specifying an ID and a data type, which can be configured through its editor interface. When executed, the node takes an input value, saves it as a global variable associated with the specified ID, and also retrieves the previous value of that global variable. This functionality is particularly useful for maintaining state or sharing data between different parts of an AI agent's operation, enabling more complex and interconnected behaviors in AI prompt chains."]},{"id":"umy_gxpnfE490in76CY61","data":["The Code Node in Rivet is a versatile component that allows users to execute JavaScript code within an AI agent's workflow. It provides a customizable interface where developers can define input and output names, enabling the seamless integration of dynamic logic into AI prompt chains. The node accepts inputs as an object, processes them through user-defined JavaScript code, and returns outputs that must match the specified output names. This functionality makes the Code Node ideal for scenarios where complex computations, data manipulations, or conditional logic are required, enhancing the overall capabilities of AI agents in Rivet's visual programming environment. Additionally, it supports error handling for missing outputs, ensuring robust and reliable execution within the AI framework."]},{"id":"ZZ8koA4y_atSKH4daxE3y","data":["The ImageNode in Rivet is designed to facilitate the integration and processing of static images within AI agent workflows. This node allows users to define an image by either providing binary data directly or referencing existing image data stored in the project. It supports various media types, including PNG, JPEG, and GIF, which can be selected through a dropdown interface. The ImageNode processes the input data to convert binary formats into image types, enabling seamless use of images in conjunction with other nodes in the AI prompt chains. Its functionality is particularly useful for applications that require image manipulation or display as part of their AI-driven processes."]},{"id":"V9ab7wi2WPzSG71yjdVZF","data":["The If/Else Node in Rivet is a logic-based component that facilitates conditional processing within AI prompt chains by evaluating a given condition and directing the flow of data based on its truthiness. It accepts three inputs: a condition (the \"If\" input), a value to output if the condition is true (the \"True\" input), and a value to output if the condition is false (the \"False\" input). If the condition is truthy, the node passes the true value through its output; otherwise, it passes the false value. This node also handles cases where input ports are unconnected, allowing for flexible graph designs. It is particularly useful for controlling the flow of data in complex AI workflows, enabling developers to implement branching logic effectively."]},{"id":"DwkdHce3seUsr0FQMi_-u","data":["The Hash Node in Rivet is a functional component designed to compute cryptographic hashes of input strings using various algorithms, including MD5, SHA-1, SHA-256, and SHA-512. This node allows users to select their desired hashing algorithm via a dropdown interface and processes the input string to produce a hashed output. It is particularly useful for scenarios that require data integrity verification, password hashing, or generating unique identifiers from input data. By visually integrating this node into AI prompt chains, developers can easily incorporate hashing functionality into their AI applications, enhancing data security and management capabilities."]},{"id":"Yrwk-M21nBY0wgv0GzN7K","data":["The `ToYamlNode` is a component of the Rivet IDE that converts input objects into YAML (YAML Ain't Markup Language) text format. This node accepts an object as input and processes it to produce a string output in YAML format, making it useful for scenarios where structured data needs to be represented in a human-readable format. It is particularly beneficial for developers working with configuration files, data serialization, or any context where YAML is preferred for its readability and simplicity. The node features a user-friendly interface that provides real-time feedback and debugging capabilities, ensuring that users can easily visualize and troubleshoot their data transformations."]},{"id":"2FzI-ytVSiie378V7Kita","data":["The Random Number Node in Rivet is designed to generate random numbers based on user-defined parameters. It allows users to specify minimum and maximum values, with options to include integers or floats, and to determine whether the maximum value is inclusive or exclusive. This node is useful for a variety of applications, such as simulations, gaming, or any scenario where randomization is needed within a specified range. The node's flexibility in configuration, including the ability to accept input values for the minimum and maximum thresholds, makes it a versatile tool for creating dynamic and unpredictable outputs in AI agent workflows."]},{"id":"fJrRW6QFB3L-koRCsJ_Lt","data":["The Assemble Message Node in Rivet is designed to create a single chat message by combining multiple parts, accommodating various data types such as text, images, and documents. This node is particularly useful for assembling messages in multimodal AI applications, allowing developers to specify the message type (system, user, assistant, or function) and optionally include a Tool Call ID for function messages. By connecting different input parts, users can construct complex messages that can be processed by AI agents, facilitating rich interactions and enhancing the overall functionality of AI-driven applications. The node also supports real-time monitoring and debugging, making it easier to ensure the correctness of the assembled messages."]},{"id":"sRkt_w-ddOjti-xEWGtk4","data":["The `ListGraphsNode` is a specialized node within the Rivet framework designed to retrieve and list all graphs present in a project. It outputs two key data types: an array of graph references, which includes the IDs and names of the graphs, and an array of graph names. This node is particularly useful for developers who need to dynamically access and manage multiple graphs within their AI agent configurations, enabling them to easily reference and utilize various graph components in their projects. By integrating this node into a graph chain, users can streamline workflows that require awareness of available graphs, facilitating better organization and execution of AI tasks."]},{"id":"VXZYMP6Cz64O-ibZewbhP","data":["The `TextNode` in Rivet is a versatile component designed for generating and manipulating text strings, enabling users to create dynamic outputs through interpolation. It allows for the inclusion of input variables within the text using a templating syntax (e.g., `{{input}}`), making it suitable for scenarios where personalized or context-specific responses are needed, such as crafting AI-generated messages or responses based on user inputs. The node provides a simple interface to define inputs and outputs, supports custom and code editors for enhanced usability, and features live debugging capabilities, ensuring that users can easily test and refine their text generation logic within AI agent workflows."]},{"id":"6u5HesTjmzxNbyBZ6fzJ8","data":["The Extract JSON Node in Rivet is designed to find and parse JSON objects from a given input string. It accepts a string input and attempts to extract the first valid JSON object, returning it as an output. If successful, the parsed object is provided through the output port, while a \"No Match\" port is used to indicate when no valid JSON is found. This node is particularly useful for scenarios where data is received in a string format that may contain JSON, allowing developers to seamlessly integrate JSON parsing capabilities into their AI agent workflows. Its robust error handling also ensures that even if the initial parsing attempt fails, it will try to identify and extract a JSON object from the input string using a more manual approach."]},{"id":"LDpUtYWu1YuO9CXYCcIB-","data":["The **Read Directory Node** is a component of the Rivet Integrated Development Environment designed for creating AI agents. This node facilitates the reading of a specified directory's contents, allowing users to retrieve an array of filenames within that directory. It offers configurable options such as whether to search recursively, include subdirectories, apply filters using glob patterns, and determine the output paths' format (relative or absolute). The node can be integrated into AI prompt chains to streamline file operations, making it particularly useful for applications that require directory management, file processing, or data extraction from file systems. Through its input and output definitions, users can dynamically control the parameters for directory reading, enhancing the flexibility and functionality of their AI agents."]},{"id":"VIRk9iXQeVgYsHkRPcp2K","data":["The Split Node in Rivet is designed to split a given string into an array of substrings based on a specified delimiter. This node allows users to define the delimiter either as a fixed string or dynamically through input, and it supports regular expression delimiters for advanced splitting scenarios. It features a user-friendly toggle for enabling regex usage and provides a clear interface for configuring the delimiter. The output of the node is an array of strings, making it useful for tasks such as parsing text data, processing user input, or transforming structured data formats where string manipulation is required."]},{"id":"NxDvijrSNnEU06ZuKyjjG","data":["The Chat Loop Node in Rivet is designed to facilitate interactive conversations between users and an AI model in a structured manner. It initiates a chat session by sending a user-defined prompt to the AI, capturing the AI's responses, and prompting the user for input in a continuous loop until the user decides to end the conversation. The node maintains a history of the entire conversation, allowing for contextually relevant interactions. It supports different rendering formats, such as plain text and markdown, making it versatile for various applications. This node is particularly useful for creating chatbots, virtual assistants, or any application requiring dynamic user interaction with an AI agent."]},{"id":"9YkNUuMPBqpl3Y-4XoEtw","data":["The Graph Reference Node in Rivet is designed to facilitate the referencing of other graphs within an AI agent's workflow. This node allows users to either input a graph's name or ID to obtain a reference to it, which can then be utilized in conjunction with a Call Graph node to invoke the referenced graph's functionality. It features dynamic input options, enabling users to select whether to use a graph ID or name for referencing. The node outputs a graph reference object that contains the graph's ID and name, making it a versatile tool for managing complex AI prompt chains by enabling modular graph execution and enhancing the overall organization of AI agent workflows."]},{"id":"rQULcmTdqsAVsYc0BmQn2","data":["The ChatNode is a component within the Rivet IDE that facilitates interactions with large language models (LLMs) through a chat interface. It allows users to make calls to GPT and other OpenAI-compatible APIs, enabling the integration of conversational AI capabilities into their projects. The node supports customizable inputs, including a system prompt for contextual guidance and a prompt input for sending messages or strings to the model. With its visual editor, users can easily configure the node's settings and monitor interactions, making it a powerful tool for creating dynamic and context-aware AI-driven applications."]},{"id":"JJQF5569oFymxzTqlSVna","data":["The Race Inputs Node in Rivet is designed to handle multiple input values and outputs the result of the first input that completes, effectively canceling any remaining inputs. This functionality is particularly useful in scenarios where multiple asynchronous operations may be initiated, and only the fastest response is needed, such as in competitive queries or time-sensitive tasks. The node dynamically determines the number of input ports based on the connections, allowing it to adapt to varying input scenarios. By leveraging this node, developers can streamline their AI agent's decision-making process by prioritizing the quickest responses while managing potential delays from slower inputs."]},{"id":"oxv7qt7MR1DPKRxSJcjuy","data":["The `ReadAllFilesNode` is a component of the Rivet IDE that facilitates the reading of all files within a specified directory, offering flexibility through various configurations such as recursive reading, filtering by glob patterns, and handling of ignored files. It allows users to choose whether to read files as binary or text and can be set to throw errors for missing files. The node outputs an array of objects, each containing the file path and its corresponding content, making it ideal for tasks that involve file manipulation, data processing, or content extraction from directories in a visual and user-friendly manner."]},{"id":"BsMeVnT_85ZsouqphfIKA","data":["The Call Graph Node in Rivet is a specialized component designed to invoke and execute another graph within the Rivet framework, allowing for modular and dynamic AI agent designs. This node takes a reference to a target graph and a set of inputs, processes them, and returns the outputs generated by the called graph. It features an optional error output mechanism, which can capture and return error messages if the graph execution fails. This functionality is particularly useful for creating complex AI workflows where different graphs can be called based on conditions or inputs, enabling developers to build sophisticated AI agents with reusable components while maintaining clear data flow and error handling."]},{"id":"hPtxs9E24s3234-qEneYv","data":["The Delay Node in Rivet is designed to introduce a specified delay in the execution of AI prompt chains, allowing for controlled timing in the flow of data between nodes. This node can be configured to accept a delay duration either as a fixed value or as an input from another node, enabling dynamic adjustments during runtime. When invoked, the Delay Node pauses execution for the defined duration before passing the input values to the output without any modifications. This functionality is particularly useful in scenarios where timing is critical, such as coordinating responses in chatbots, managing rate limits in API calls, or simulating real-time interactions in AI applications."]},{"id":"PBuAvXn8qFNCYNZ5G6YEM","data":["The Dataset Nearest Neighbors Node is a component within the Rivet framework designed for finding the k nearest neighbors in a specified dataset based on a given embedding. This node allows users to input an embedding vector and optionally specify a dataset ID and the value of k, which represents the number of nearest neighbors to retrieve. Utilizing a dataset provider, the node processes these inputs to return an array of nearest neighbors, each accompanied by its corresponding distance and data. This functionality is particularly useful in AI applications that require similarity searches, such as recommendation systems, clustering, or any scenario where proximity in a feature space is relevant."]},{"id":"t_l6-v7y5s9NcCgqZFlIW","data":["The Extract YAML Node in Rivet is designed to parse and extract data from YAML-formatted text input. It allows users to specify a root property name, which defaults to \"yamlDocument,\" and optionally provides an object path for more granular extraction of values within the YAML structure. The node processes the input string to locate the specified root property, extracts the corresponding YAML content, and converts it into a JavaScript object. If an object path is provided, it utilizes JSONPath to retrieve specific values, returning the parsed object, any matches found, or indicating if no match was made. This node is particularly useful for applications that need to handle and manipulate YAML data dynamically, enabling seamless integration of YAML parsing into AI agent workflows."]},{"id":"SwWZWPP7-L2NkcE_1X8mx","data":["The IfNode in Rivet serves as a conditional control flow mechanism within AI prompt chains, allowing users to route data based on the truthiness of a specified condition. It takes two inputs: a condition and a value, and based on the evaluation of the condition, it directs the value either to the True output or the False output. If the condition is truthy, the value is passed through the True port; if falsy, it is routed through the False port. This node is particularly useful for implementing decision-making logic in AI agents, enabling dynamic responses based on varying input conditions, and enhancing the overall flexibility and functionality of AI workflows."]}]}},{"meta":{"id":"kA30RgfCwAlUV5PttKa3E","projectId":"wHxyeNIJLo2ZrylGbkznh","name":"Node Source Code","description":""},"data":{"id":"kA30RgfCwAlUV5PttKa3E","rows":[{"id":"e44OCQbTlSzslXzC0M0IP","data":["SubGraphNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type GraphId } from '../NodeGraph.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Project } from '../Project.js';\nimport { type GraphInputNode } from './GraphInputNode.js';\nimport { type GraphOutputNode } from './GraphOutputNode.js';\nimport { type DataValue } from '../DataValue.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type DynamicEditorEditor, type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { getError } from '../../utils/errors.js';\nimport { match } from 'ts-pattern';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type SubGraphNode = ChartNode & {\n  type: 'subGraph';\n  data: {\n    graphId: GraphId;\n    useErrorOutput?: boolean;\n    useAsGraphPartialOutput?: boolean;\n\n    /** Data for each of the inputs of the subgraph */\n    inputData?: Record<string, DataValue>;\n  };\n};\n\nexport class SubGraphNodeImpl extends NodeImpl<SubGraphNode> {\n  static create(): SubGraphNode {\n    const chartNode: SubGraphNode = {\n      type: 'subGraph',\n      title: 'Subgraph',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        graphId: '' as GraphId,\n        useErrorOutput: false,\n        useAsGraphPartialOutput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(\n    _connections: NodeConnection[],\n    _nodes: Record<NodeId, ChartNode>,\n    project: Project,\n  ): NodeInputDefinition[] {\n    const graph = project.graphs[this.data.graphId];\n    if (!graph) {\n      return [];\n    }\n\n    const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput') as GraphInputNode[];\n    const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();\n\n    return inputIds.map(\n      (id): NodeInputDefinition => ({\n        id: id as PortId,\n        title: id,\n        dataType: inputNodes.find((node) => node.data.id === id)!.data.dataType,\n      }),\n    );\n  }\n\n  getGraphOutputs(project: Project): NodeOutputDefinition[] {\n    const graph = project.graphs[this.data.graphId];\n    if (!graph) {\n      return [];\n    }\n\n    const outputNodes = graph.nodes.filter((node) => node.type === 'graphOutput') as GraphOutputNode[];\n    const outputIds = [...new Set(outputNodes.map((node) => node.data.id))].sort();\n\n    const outputs = outputIds.map(\n      (id): NodeOutputDefinition => ({\n        id: id as PortId,\n        title: id,\n        dataType: outputNodes.find((node) => node.data.id === id)!.data.dataType,\n      }),\n    );\n\n    return outputs;\n  }\n\n  getOutputDefinitions(\n    _connections: NodeConnection[],\n    _nodes: Record<NodeId, ChartNode>,\n    project: Project,\n  ): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n\n    outputs.push(...this.getGraphOutputs(project));\n\n    if (this.data.useErrorOutput) {\n      outputs.push({\n        id: 'error' as PortId,\n        title: 'Error',\n        dataType: 'string',\n      });\n    }\n\n    return outputs;\n  }\n\n  getEditors(context: RivetUIContext): EditorDefinition<SubGraphNode>[] {\n    const definitions: EditorDefinition<SubGraphNode>[] = [\n      {\n        type: 'graphSelector',\n        label: 'Graph',\n        dataKey: 'graphId',\n      },\n      {\n        type: 'toggle',\n        label: 'Use Error Output',\n        dataKey: 'useErrorOutput',\n      },\n    ];\n\n    if (this.data.graphId) {\n      const graph = context.project.graphs[this.data.graphId];\n      if (graph) {\n        const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput') as GraphInputNode[];\n        const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();\n\n        for (const inputId of inputIds) {\n          const inputNode = inputNodes.find((node) => node.data.id === inputId)!;\n          definitions.push({\n            type: 'dynamic',\n            dataKey: 'inputData',\n            dynamicDataKey: inputNode.data.id,\n            dataType: inputNode.data.dataType,\n            label: inputNode.data.id,\n            editor: inputNode.data.editor ?? 'auto',\n          });\n        }\n      }\n    }\n\n    return definitions;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Executes another graph. Inputs and outputs are defined by Graph Input and Graph Output nodes within the subgraph.\n      `,\n      infoBoxTitle: 'Subgraph Node',\n      contextMenuTitle: 'Subgraph',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { project } = context;\n\n    if (!project) {\n      throw new Error('SubGraphNode requires a project to be set in the context.');\n    }\n\n    const graph = project.graphs[this.data.graphId];\n    if (!graph) {\n      throw new Error(`SubGraphNode requires a graph with id ${this.data.graphId} to be present in the project.`);\n    }\n\n    const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput') as GraphInputNode[];\n    const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();\n\n    const inputData = inputIds.reduce((obj, id): Inputs => {\n      if (inputs[id as PortId] != null) {\n        return {\n          ...obj,\n          [id]: inputs[id as PortId],\n        };\n      }\n\n      if (this.data.inputData?.[id] != null) {\n        return {\n          ...obj,\n          [id]: this.data.inputData[id],\n        };\n      }\n\n      return obj;\n    }, {} as Inputs);\n\n    const subGraphProcessor = context.createSubProcessor(this.data.graphId, { signal: context.signal });\n\n    try {\n      const startTime = Date.now();\n\n      const outputs = await subGraphProcessor.processGraph(\n        context,\n        inputData as Record<string, DataValue>,\n        context.contextValues,\n      );\n\n      const duration = Date.now() - startTime;\n\n      if (this.data.useErrorOutput) {\n        outputs['error' as PortId] = {\n          type: 'control-flow-excluded',\n          value: undefined,\n        };\n      }\n\n      if (outputs['duration' as PortId] == null) {\n        outputs['duration' as PortId] = {\n          type: 'number',\n          value: duration,\n        };\n      }\n\n      return outputs;\n    } catch (err) {\n      if (!this.data.useErrorOutput) {\n        throw err;\n      }\n\n      const outputs: Outputs = this.getGraphOutputs(context.project).reduce(\n        (obj, output): Outputs => ({\n          ...obj,\n          [output.id as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n        }),\n        {} as Outputs,\n      );\n\n      outputs['error' as PortId] = {\n        type: 'string',\n        value: getError(err).message,\n      };\n\n      return outputs;\n    }\n  }\n}\n\nexport const subGraphNode = nodeDefinition(SubGraphNodeImpl, 'Subgraph');\n"]},{"id":"OVfA2pbRx2nJ2Is_7RtE6","data":["LoadDatasetNode.ts","import type {\n  ChartNode,\n  DatasetId,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n  EditorDefinition,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { coerceTypeOptional, dedent, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type LoadDatasetNode = ChartNode<'loadDataset', LoadDatasetNodeData>;\n\ntype LoadDatasetNodeData = {\n  datasetId: DatasetId;\n  useDatasetIdInput?: boolean;\n};\n\nexport class LoadDatasetNodeImpl extends NodeImpl<LoadDatasetNode> {\n  static create(): LoadDatasetNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'loadDataset',\n      title: 'Load Dataset',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        datasetId: '' as DatasetId,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useDatasetIdInput) {\n      inputs.push({\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'dataset' as PortId,\n        title: 'Dataset',\n        dataType: 'object[]',\n      },\n      {\n        id: 'datasetId_out' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Loads a dataset with the provided ID. If the dataset does not exist, it throws an error.\n      `,\n      infoBoxTitle: 'Load Dataset Node',\n      contextMenuTitle: 'Load Dataset',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<LoadDatasetNode>[] | Promise<EditorDefinition<LoadDatasetNode>[]> {\n    return [\n      {\n        type: 'datasetSelector',\n        label: 'Dataset',\n        dataKey: 'datasetId',\n        useInputToggleDataKey: 'useDatasetIdInput',\n      },\n    ];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId = coerceTypeOptional(inputs['datasetId' as PortId], 'string') || this.data.datasetId;\n\n    const dataset = await datasetProvider.getDatasetData(datasetId as DatasetId);\n\n    if (!dataset) {\n      throw new Error(`Dataset with ID ${datasetId} does not exist`);\n    }\n\n    return {\n      ['dataset' as PortId]: {\n        type: 'object[]',\n        value: dataset.rows,\n      },\n      ['datasetId_out' as PortId]: {\n        type: 'string',\n        value: datasetId,\n      },\n    };\n  }\n}\n\nexport const loadDatasetNode = nodeDefinition(LoadDatasetNodeImpl, 'Load Dataset');\n"]},{"id":"-6VIxAZZmOMQtEPnMEs3P","data":["BooleanNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type BooleanNode = ChartNode<'boolean', BooleanNodeData>;\n\nexport type BooleanNodeData = {\n  value?: boolean;\n  useValueInput?: boolean;\n};\n\nexport class BooleanNodeImpl extends NodeImpl<BooleanNode> {\n  static create(): BooleanNode {\n    const chartNode: BooleanNode = {\n      type: 'boolean',\n      title: 'Bool',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 130,\n      },\n      data: {\n        value: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return this.data.useValueInput\n      ? [\n          {\n            dataType: 'any',\n            id: 'input' as PortId,\n            title: 'Input',\n          },\n        ]\n      : [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'boolean',\n        id: 'value' as PortId,\n        title: 'Value',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<BooleanNode>[] {\n    return [{ type: 'toggle', label: 'Value', dataKey: 'value', useInputToggleDataKey: 'useValueInput' }];\n  }\n\n  getBody(): string | undefined {\n    return this.data.useValueInput ? `(Input to bool)` : (this.data.value ?? false).toString();\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Outputs a boolean constant, or converts an input value into a boolean.\n      `,\n      infoBoxTitle: 'Bool Node',\n      contextMenuTitle: 'Bool',\n      group: ['Data'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const value = this.data.useValueInput\n      ? coerceTypeOptional(inputs['input' as PortId], 'boolean') ?? this.data.value ?? false\n      : this.data.value ?? false;\n\n    return {\n      ['value' as PortId]: {\n        type: 'boolean',\n        value,\n      },\n    };\n  }\n}\n\nexport const booleanNode = nodeDefinition(BooleanNodeImpl, 'Boolean');\n"]},{"id":"HcuEG7uWUVAeJnqSbGJt7","data":["SliceNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { entries } from '../../utils/typeSafety.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../../index.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { getInputOrData } from '../../utils/index.js';\n\nexport type SliceNode = ChartNode<'slice', SliceNodeData>;\n\nexport type SliceNodeData = {\n  start?: number;\n  useStartInput?: boolean;\n\n  count?: number;\n  useCountInput?: boolean;\n};\n\nexport class SliceNodeImpl extends NodeImpl<SliceNode> {\n  static create(): SliceNode {\n    const chartNode: SliceNode = {\n      type: 'slice',\n      title: 'Slice',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        start: 0,\n        count: undefined,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        dataType: 'any[]',\n        id: 'input' as PortId,\n        title: 'Input',\n      },\n    ];\n\n    if (this.data.useStartInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'start' as PortId,\n        title: 'Start',\n      });\n    }\n\n    if (this.data.useCountInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'count' as PortId,\n        title: 'Count',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'any[]',\n        id: 'output' as PortId,\n        title: 'Output',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<SliceNode>[] {\n    return [\n      { type: 'number', label: 'Start', dataKey: 'start', useInputToggleDataKey: 'useStartInput', allowEmpty: true },\n      { type: 'number', label: 'Count', dataKey: 'count', useInputToggleDataKey: 'useCountInput', allowEmpty: true },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | NodeBodySpec[] | undefined {\n    return dedent`\n      Start: ${this.data.useStartInput ? '(Using Input)' : this.data.start == null ? '0' : this.data.start}\n      Count: ${this.data.useCountInput ? '(Using Input)' : this.data.count == null ? 'All' : this.data.count}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Slices an array from the start index for the count number of elements.\n\n        Useful for extracting a portion of an array.\n      `,\n      infoBoxTitle: 'Slice Node',\n      contextMenuTitle: 'Slice',\n      group: ['Lists'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const inputArray = coerceType(inputs['input' as PortId], 'any[]');\n\n    const start = getInputOrData(this.data, inputs, 'start', 'number') ?? 0;\n    const count = getInputOrData(this.data, inputs, 'count', 'number') ?? inputArray.length;\n\n    const outputArray = inputArray.slice(start, start + count);\n\n    return {\n      ['output' as PortId]: {\n        type: 'any[]',\n        value: outputArray,\n      },\n    };\n  }\n}\n\nexport const sliceNode = nodeDefinition(SliceNodeImpl, 'Slice');\n"]},{"id":"gcMPjGnttWS9AKctXy5Sx","data":["HttpCallNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition, type InternalProcessContext } from '../../index.js';\nimport { coerceType, dedent, getInputOrData } from '../../utils/index.js';\nimport { getError } from '../../utils/errors.js';\n\nexport type HttpCallNode = ChartNode<'httpCall', HttpCallNodeData>;\n\nexport type HttpCallNodeData = {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  useMethodInput?: boolean;\n\n  url: string;\n  useUrlInput?: boolean;\n\n  headers: string;\n  useHeadersInput?: boolean;\n\n  body: string;\n  useBodyInput?: boolean;\n\n  isBinaryOutput?: boolean;\n\n  errorOnNon200?: boolean;\n};\n\nexport class HttpCallNodeImpl extends NodeImpl<HttpCallNode> {\n  static create(): HttpCallNode {\n    const chartNode: HttpCallNode = {\n      type: 'httpCall',\n      title: 'Http Call',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        method: 'GET',\n        url: '',\n        headers: '',\n        body: '',\n        errorOnNon200: true,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useMethodInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'method' as PortId,\n        title: 'Method',\n      });\n    }\n\n    if (this.data.useUrlInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'url' as PortId,\n        title: 'URL',\n      });\n    }\n\n    if (this.data.useHeadersInput) {\n      inputs.push({\n        dataType: 'object',\n        id: 'headers' as PortId,\n        title: 'Headers',\n      });\n    }\n\n    if (this.data.useBodyInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'req_body' as PortId,\n        title: 'Body',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputDefinitions: NodeOutputDefinition[] = [];\n    if (this.data.isBinaryOutput) {\n      outputDefinitions.push({\n        dataType: 'binary',\n        id: 'binary' as PortId,\n        title: 'Binary',\n      });\n    } else {\n      outputDefinitions.push(\n        {\n          dataType: 'string',\n          id: 'res_body' as PortId,\n          title: 'Body',\n        },\n        {\n          dataType: 'object',\n          id: 'json' as PortId,\n          title: 'JSON',\n        },\n      );\n    }\n\n    outputDefinitions.push(\n      {\n        dataType: 'number',\n        id: 'statusCode' as PortId,\n        title: 'Status Code',\n      },\n      {\n        dataType: 'object',\n        id: 'res_headers' as PortId,\n        title: 'Headers',\n      },\n    );\n\n    return outputDefinitions;\n  }\n\n  getEditors(): EditorDefinition<HttpCallNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Method',\n        dataKey: 'method',\n        useInputToggleDataKey: 'useMethodInput',\n        options: [\n          { label: 'GET', value: 'GET' },\n          { label: 'POST', value: 'POST' },\n          { label: 'PUT', value: 'PUT' },\n          { label: 'DELETE', value: 'DELETE' },\n        ],\n      },\n      {\n        type: 'string',\n        label: 'URL',\n        dataKey: 'url',\n        useInputToggleDataKey: 'useUrlInput',\n      },\n      {\n        type: 'code',\n        label: 'Headers',\n        dataKey: 'headers',\n        useInputToggleDataKey: 'useHeadersInput',\n        language: 'json',\n      },\n      {\n        type: 'code',\n        label: 'Body',\n        dataKey: 'body',\n        useInputToggleDataKey: 'useBodyInput',\n        language: 'json',\n      },\n      {\n        type: 'toggle',\n        label: 'Binary Output',\n        dataKey: 'isBinaryOutput',\n        helperMessage: 'Toggle on if the response is expected to be binary data',\n      },\n      {\n        type: 'toggle',\n        label: 'Error on non-200 status code',\n        dataKey: 'errorOnNon200',\n      },\n    ];\n  }\n\n  getBody(): string {\n    return dedent`\n      ${this.data.useMethodInput ? '(Method Using Input)' : this.data.method} ${\n        this.data.useUrlInput ? '(URL Using Input)' : this.data.url\n      } ${\n        this.data.useHeadersInput\n          ? '\\nHeaders: (Using Input)'\n          : this.data.headers.trim()\n            ? `\\nHeaders: ${this.data.headers}`\n            : ''\n      }${this.data.useBodyInput ? '\\nBody: (Using Input)' : this.data.body.trim() ? `\\nBody: ${this.data.body}` : ''}${\n        this.data.errorOnNon200 ? '\\nError on non-200' : ''\n      }\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Makes an HTTP call to the specified URL with the given method, headers, and body.\n      `,\n      infoBoxTitle: 'HTTP Call Node',\n      contextMenuTitle: 'HTTP Call',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const method = getInputOrData(this.data, inputs, 'method', 'string');\n    const url = getInputOrData(this.data, inputs, 'url', 'string');\n\n    // TODO: Use URL.canParse when we drop support for Node 18\n    try {\n      new URL(url);\n    } catch (err) {\n      throw new Error(`Invalid URL: ${url}`);\n    }\n\n    let headers: Record<string, string> | undefined;\n    if (this.data.useHeadersInput) {\n      const headersInput = inputs['headers' as PortId];\n      if (headersInput?.type === 'string') {\n        headers = JSON.parse(headersInput!.value);\n      } else if (headersInput?.type === 'object') {\n        headers = headersInput!.value as Record<string, string>;\n      } else {\n        headers = coerceType(headersInput, 'object') as Record<string, string>;\n      }\n    } else if (this.data.headers.trim()) {\n      headers = JSON.parse(this.data.headers);\n    }\n\n    let body: string | undefined;\n    if (this.data.useBodyInput) {\n      const bodyInput = inputs['req_body' as PortId];\n      if (bodyInput?.type === 'string') {\n        body = bodyInput!.value;\n      } else if (bodyInput?.type === 'object') {\n        body = JSON.stringify(bodyInput!.value);\n      } else {\n        body = coerceType(bodyInput, 'string');\n      }\n    } else {\n      body = this.data.body || undefined;\n    }\n\n    try {\n      const response = await fetch(url, {\n        method,\n        headers,\n        body,\n        signal: context.signal,\n        mode: 'cors',\n      });\n\n      const output: Outputs = {\n        ['statusCode' as PortId]: {\n          type: 'number',\n          value: response.status,\n        },\n        ['res_headers' as PortId]: {\n          type: 'object',\n          value: Object.fromEntries(response.headers.entries()),\n        },\n      };\n\n      if (this.data.isBinaryOutput) {\n        const responseBlob = await response.blob();\n        output['binary' as PortId] = {\n          type: 'binary',\n          value: new Uint8Array(await responseBlob.arrayBuffer()),\n        };\n      } else {\n        const responseText = await response.text();\n        output['res_body' as PortId] = {\n          type: 'string',\n          value: responseText,\n        };\n        if (response.headers.get('content-type')?.includes('application/json')) {\n          const jsonData = JSON.parse(responseText);\n          output['json' as PortId] = {\n            type: 'object',\n            value: jsonData,\n          };\n        } else {\n          output['json' as PortId] = {\n            type: 'control-flow-excluded',\n            value: undefined,\n          };\n        }\n      }\n\n      return output;\n    } catch (err) {\n      const { message } = getError(err);\n      if (message.includes('Load failed') || message.includes('Failed to fetch')) {\n        if (context.executor === 'browser') {\n          throw new Error(\n            'Failed to make HTTP call. You may be running into CORS problems. Try using the Node executor in the top-right menu.',\n          );\n        }\n      }\n\n      throw err;\n    }\n  }\n}\n\nexport const httpCallNode = nodeDefinition(HttpCallNodeImpl, 'Http Call');\n"]},{"id":"xcevniafIuVbnvfGu9Uws","data":["GptFunctionNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\nimport { interpolate } from '../../utils/interpolation.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { keys } from '../../utils/typeSafety.js';\nimport { coerceTypeOptional, coerceType } from '../../utils/coerceType.js';\nimport { getInputOrData } from '../../utils/index.js';\n\nexport type GptFunctionNode = ChartNode<'gptFunction', GptFunctionNodeData>;\n\nexport type GptFunctionNodeData = {\n  name: string;\n  useNameInput?: boolean;\n\n  description: string;\n  useDescriptionInput?: boolean;\n\n  schema: string;\n  useSchemaInput?: boolean;\n\n  strict?: boolean;\n};\n\nexport class GptFunctionNodeImpl extends NodeImpl<GptFunctionNode> {\n  static create(): GptFunctionNode {\n    const chartNode: GptFunctionNode = {\n      type: 'gptFunction',\n      title: 'GPT Function',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        name: 'newFunction',\n        description: 'No description provided',\n        schema: dedent`\n          {\n            \"type\": \"object\",\n            \"properties\": {}\n          }`,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    let inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useNameInput) {\n      inputs.push({\n        id: 'name' as PortId,\n        title: 'Name',\n        dataType: 'string',\n        description: 'The name of the function that GPT will see as available to call',\n      });\n    }\n\n    if (this.data.useDescriptionInput) {\n      inputs.push({\n        id: 'description' as PortId,\n        title: 'Description',\n        dataType: 'string',\n        description: 'The description of the function that GPT will see as available to call',\n      });\n    }\n\n    if (this.data.useSchemaInput) {\n      inputs.push({\n        id: 'schema' as PortId,\n        title: 'Schema',\n        dataType: 'object',\n        description: 'The schema of the function that GPT will see as available to call',\n      });\n    }\n\n    // Extract inputs from promptText, everything like {{input}}\n    const inputNames = this.data.useSchemaInput ? [] : [...new Set(this.data.schema.match(/\\{\\{([^}]+)\\}\\}/g))];\n    inputs = [\n      ...inputs,\n      ...(inputNames?.map((inputName): NodeInputDefinition => {\n        const name = inputName.slice(2, -2);\n        return {\n          // id and title should not have the {{ and }}\n          id: `input-${name}` as PortId,\n          title: name,\n          dataType: 'string',\n          description: `An interpolated value in the schema named '${name}'`,\n        };\n      }) ?? []),\n    ];\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'function' as PortId,\n        title: 'Function',\n        dataType: 'gpt-function',\n        description: 'The GPT function that can be called by the LLM.',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<GptFunctionNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Name',\n        dataKey: 'name',\n        useInputToggleDataKey: 'useNameInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Strict',\n        dataKey: 'strict',\n        helperMessage: 'Sets the strict parameter, which determines if OpenAI Structured Outputs are used.',\n      },\n      {\n        type: 'code',\n        label: 'Description',\n        dataKey: 'description',\n        useInputToggleDataKey: 'useDescriptionInput',\n        language: 'markdown',\n        height: 100,\n      },\n      {\n        type: 'custom',\n        customEditorId: 'GptFunctionNodeJsonSchemaAiAssist',\n        label: 'AI Assist',\n      },\n      {\n        type: 'code',\n        label: 'Schema',\n        dataKey: 'schema',\n        language: 'json',\n        useInputToggleDataKey: 'useSchemaInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return `!markdown_${this.data.name}_: ${this.data.description}`;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Defines a GPT function, which is a method that the LLM can call in its responses.\n      `,\n      infoBoxTitle: 'GPT Function Node',\n      contextMenuTitle: 'GPT Function',\n      group: ['AI'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const name = getInputOrData(this.data, inputs, 'name');\n    const description = getInputOrData(this.data, inputs, 'description');\n\n    let schema: unknown;\n    if (this.data.useSchemaInput) {\n      schema = coerceType(inputs['schema' as PortId], 'object');\n    } else {\n      const inputMap = keys(inputs)\n        .filter((key) => key.startsWith('input'))\n        .reduce(\n          (acc, key) => {\n            const stringValue = coerceTypeOptional(inputs[key], 'string') ?? '';\n\n            const interpolationKey = key.slice('input-'.length);\n            acc[interpolationKey] = stringValue;\n            return acc;\n          },\n          {} as Record<string, string>,\n        );\n\n      const interpolated = interpolate(this.data.schema, inputMap);\n\n      schema = JSON.parse(interpolated);\n    }\n\n    return {\n      ['function' as PortId]: {\n        type: 'gpt-function',\n        value: {\n          name,\n          description,\n          parameters: schema as object,\n          strict: this.data.strict ?? false,\n        },\n      },\n    };\n  }\n}\n\nexport const gptFunctionNode = nodeDefinition(GptFunctionNodeImpl, 'GPT Function');\n"]},{"id":"jg9JnzngBi6BCz22N9KyL","data":["MatchNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { type EditorDefinition, type Inputs, type NodeBody, type Outputs } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type MatchNode = ChartNode<'match', MatchNodeData>;\n\nexport type MatchNodeData = {\n  cases: string[];\n\n  /** If true, only the first matching branch will be ran. */\n  exclusive?: boolean;\n};\n\nexport class MatchNodeImpl extends NodeImpl<MatchNode> {\n  static create(): MatchNode {\n    const chartNode: MatchNode = {\n      type: 'match',\n      title: 'Match',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        cases: ['YES', 'NO'],\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'input' as PortId,\n        title: 'Test',\n        dataType: 'string',\n        required: true,\n        description: 'The value that will be tested against each of the cases.',\n      },\n      {\n        id: 'value' as PortId,\n        title: 'Value',\n        dataType: 'any',\n        description:\n          'The value passed through to the output port that matches. If unconnected, the test value will be passed through.',\n      },\n    ];\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n\n    for (let i = 0; i < this.data.cases.length; i++) {\n      outputs.push({\n        id: `case${i + 1}` as PortId,\n        title: this.data.cases[i]?.trim() ? this.data.cases[i]! : `Case ${i + 1}`,\n        dataType: 'string',\n        description: `The 'value' (or 'test' if value is unconnected) passed through if the test value matches this regex: /${this\n          .data.cases[i]!}/`,\n      });\n    }\n\n    outputs.push({\n      id: 'unmatched' as PortId,\n      title: 'Unmatched',\n      dataType: 'string',\n      description: 'The value (or test if value is unconnected) passed through if no regexes match.',\n    });\n\n    return outputs;\n  }\n\n  getBody(): NodeBody {\n    return dedent`\n      ${this.data.exclusive ? 'First Matching Case' : 'All Matching Cases'}\n      ${this.data.cases.length} Cases\n    `;\n  }\n\n  getEditors(): EditorDefinition<MatchNode>[] {\n    return [\n      {\n        type: 'toggle',\n        dataKey: 'exclusive',\n        label: 'Exclusive',\n        helperMessage: 'If enabled, only the first matching branch will be ran.',\n      },\n      {\n        type: 'stringList',\n        dataKey: 'cases',\n        label: 'Cases',\n        placeholder: 'Case (regular expression)',\n        helperMessage: '(Regular expressions)',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Any number of regular expressions can be configured, each corresponding to an output of the node. The output port of the first matching regex will be ran, and all other output ports will not be ran.\n      `,\n      infoBoxTitle: 'Match Node',\n      contextMenuTitle: 'Match',\n      group: ['Logic'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const inputString = coerceType(inputs['input' as PortId], 'string');\n    const value = inputs['value' as PortId];\n\n    const outputType = value === undefined ? 'string' : value.type;\n    const outputValue = value === undefined ? inputString : value.value;\n\n    const cases = this.data.cases;\n    let matched = false;\n    const output: Outputs = {};\n\n    for (let i = 0; i < cases.length; i++) {\n      const regExp = new RegExp(cases[i]!);\n      const match = regExp.test(inputString);\n\n      const canMatch = !this.data.exclusive || !matched;\n      if (match && canMatch) {\n        matched = true;\n        output[`case${i + 1}` as PortId] = {\n          type: outputType,\n          value: outputValue,\n        } as DataValue;\n      } else {\n        output[`case${i + 1}` as PortId] = {\n          type: 'control-flow-excluded',\n          value: undefined,\n        };\n      }\n    }\n\n    if (!matched) {\n      output['unmatched' as PortId] = {\n        type: outputType,\n        value: outputValue,\n      } as DataValue;\n    } else {\n      output['unmatched' as PortId] = {\n        type: 'control-flow-excluded',\n        value: undefined,\n      };\n    }\n\n    return output;\n  }\n}\n\nexport const matchNode = nodeDefinition(MatchNodeImpl, 'Match');\n"]},{"id":"quc9f0DuJYMD-aeJECs9W","data":["DestructureNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { JSONPath } from 'jsonpath-plus';\nimport { type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type DestructureNode = ChartNode<'destructure', DestructureNodeData>;\n\nexport type DestructureNodeData = {\n  paths: string[];\n};\n\nexport class DestructureNodeImpl extends NodeImpl<DestructureNode> {\n  static create(): DestructureNode {\n    const chartNode: DestructureNode = {\n      type: 'destructure',\n      title: 'Destructure',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        paths: ['$.value'],\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'object' as PortId,\n        title: 'Object',\n        dataType: 'object',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return this.data.paths.map((path, index) => ({\n      id: `match_${index}` as PortId,\n      title: path,\n      dataType: 'any',\n    }));\n  }\n\n  getEditors(): EditorDefinition<DestructureNode>[] {\n    return [\n      {\n        type: 'stringList',\n        label: 'Paths',\n        dataKey: 'paths',\n        helperMessage:\n          'One or more JSONPath expressions. Each expression will correspond to an output port of the node.',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return '';\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Destructures the input value by extracting values at the specified paths. The paths use JSONPath notation to navigate through the value.\n      `,\n      infoBoxTitle: 'Destructure Node',\n      contextMenuTitle: 'Destructure',\n      group: ['Objects'],\n    };\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const inputObject = coerceTypeOptional(inputs['object' as PortId], 'object');\n\n    const output: Record<PortId, DataValue> = {};\n\n    this.data.paths.forEach((path, index) => {\n      let match: unknown;\n      try {\n        match = JSONPath<unknown>({ json: inputObject ?? null, path: path.trim(), wrap: false });\n      } catch (err) {\n        match = undefined;\n      }\n\n      output[`match_${index}` as PortId] = {\n        type: 'any',\n        value: match,\n      };\n    });\n\n    return output;\n  }\n}\n\nexport const destructureNode = nodeDefinition(DestructureNodeImpl, 'Destructure');\n"]},{"id":"RtAkv3zc5O5D96YseHBeF","data":["ExtractObjectPathNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { JSONPath } from 'jsonpath-plus';\nimport { expectType } from '../../utils/expectType.js';\nimport { type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type ExtractObjectPathNode = ChartNode<'extractObjectPath', ExtractObjectPathNodeData>;\n\nexport type ExtractObjectPathNodeData = {\n  path: string;\n  usePathInput: boolean;\n};\n\nexport class ExtractObjectPathNodeImpl extends NodeImpl<ExtractObjectPathNode> {\n  static create(): ExtractObjectPathNode {\n    const chartNode: ExtractObjectPathNode = {\n      type: 'extractObjectPath',\n      title: 'Extract Object Path',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        path: '$',\n        usePathInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [\n      {\n        id: 'object' as PortId,\n        title: 'Object',\n        dataType: 'object',\n        required: true,\n      },\n    ];\n\n    if (this.chartNode.data.usePathInput) {\n      inputDefinitions.push({\n        id: 'path' as PortId,\n        title: 'Path',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'match' as PortId,\n        title: 'Match',\n        dataType: 'any',\n      },\n      {\n        id: 'all_matches' as PortId,\n        title: 'All Matches',\n        dataType: 'any[]',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ExtractObjectPathNode>[] {\n    return [\n      {\n        type: 'code',\n        label: 'Path',\n        dataKey: 'path',\n        language: 'jsonpath',\n        useInputToggleDataKey: 'usePathInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.usePathInput ? '(Using Input)' : this.data.path;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Extracts the value at the specified path from the input value. The path uses JSONPath notation to navigate through the value.\n      `,\n      infoBoxTitle: 'Extract Object Path Node',\n      contextMenuTitle: 'Extract Object Path',\n      group: ['Objects'],\n    };\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const inputObject = coerceTypeOptional(inputs['object' as PortId], 'object');\n    const inputPath = this.chartNode.data.usePathInput\n      ? expectType(inputs['path' as PortId], 'string')\n      : this.chartNode.data.path;\n\n    if (!inputPath) {\n      throw new Error('Path input is not provided');\n    }\n\n    let matches: unknown[];\n    try {\n      // Wrap doesn't seem to wrap when the input is undefined or null...\n      const match = JSONPath<unknown>({ json: inputObject ?? null, path: inputPath.trim(), wrap: true });\n      matches = match == null ? [] : (match as unknown[]);\n    } catch (err) {\n      matches = [];\n    }\n\n    if (matches.length === 0) {\n      return {\n        ['match' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n        ['all_matches' as PortId]: {\n          type: 'any[]',\n          value: [],\n        },\n      };\n    }\n\n    return {\n      ['match' as PortId]: {\n        type: 'any',\n        value: matches[0],\n      },\n      ['all_matches' as PortId]: {\n        type: 'any[]',\n        value: matches,\n      },\n    };\n  }\n}\n\nexport const extractObjectPathNode = nodeDefinition(ExtractObjectPathNodeImpl, 'Extract Object Path');\n"]},{"id":"8-Y2U9gvPjzYx27YRxxC2","data":["PopNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type PopNode = ChartNode<'pop', PopNodeData>;\n\nexport type PopNodeData = {\n  fromFront?: boolean;\n};\n\nexport class PopNodeImpl extends NodeImpl<PopNode> {\n  static create(): PopNode {\n    const baseNode: PopNode = {\n      type: 'pop',\n      title: 'Pop',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {},\n    };\n\n    return baseNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        dataType: 'any[]',\n        id: 'array' as PortId,\n        title: 'Array',\n        coerced: false,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'any',\n        id: 'lastItem' as PortId,\n        title: this.data.fromFront ? 'First' : 'Last',\n      },\n      {\n        dataType: 'any',\n        id: 'restOfArray' as PortId,\n        title: 'Rest',\n      },\n    ];\n  }\n\n  getEditors(_context: RivetUIContext): EditorDefinition<PopNode>[] | Promise<EditorDefinition<PopNode>[]> {\n    return [\n      {\n        label: 'Pop from front',\n        type: 'toggle',\n        dataKey: 'fromFront',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Pops the last value off the input array and outputs the new array and the popped value.\n\n        Can also be used to just extract the last value from an array.\n      `,\n      infoBoxTitle: 'Pop Node',\n      contextMenuTitle: 'Pop',\n      group: ['Lists'],\n    };\n  }\n\n  getBody(_context: RivetUIContext): NodeBody | Promise<NodeBody> {\n    return this.data.fromFront ? 'From front' : 'From back';\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const inputArray = inputs['array' as PortId]?.value;\n\n    if (!Array.isArray(inputArray) || inputArray.length === 0) {\n      throw new Error('Input array is empty or not an array');\n    }\n\n    const lastItem = this.data.fromFront ? inputArray[0] : inputArray[inputArray.length - 1];\n    const rest = this.data.fromFront ? inputArray.slice(1) : inputArray.slice(0, inputArray.length - 1);\n\n    return {\n      ['lastItem' as PortId]: {\n        type: 'any',\n        value: lastItem,\n      },\n      ['restOfArray' as PortId]: {\n        type: 'any[]',\n        value: rest,\n      },\n    };\n  }\n}\n\nexport const popNode = nodeDefinition(PopNodeImpl, 'Pop');\n"]},{"id":"BvB-TdS06e-Jmz7VGzi-a","data":["JoinNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { isArrayDataValue } from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { coerceType, coerceTypeOptional, inferType } from '../../utils/coerceType.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { handleEscapeCharacters } from '../../utils/index.js';\n\nexport type JoinNode = ChartNode<'join', JoinNodeData>;\n\nexport type JoinNodeData = {\n  flatten?: boolean;\n  joinString: string;\n  useJoinStringInput?: boolean;\n};\n\nexport class JoinNodeImpl extends NodeImpl<JoinNode> {\n  static create = (): JoinNode => {\n    const chartNode: JoinNode = {\n      type: 'join',\n      title: 'Join',\n      id: nanoid() as NodeId,\n      data: {\n        flatten: true,\n        joinString: '\\n',\n      },\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 150,\n      },\n    };\n    return chartNode;\n  };\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    if (this.data.useJoinStringInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'joinString' as PortId,\n        title: 'Join String',\n      });\n    }\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'string',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'string',\n        id: 'output' as PortId,\n        title: 'Joined',\n      },\n    ];\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);\n      if (messageNumber > maxInputNumber) {\n        maxInputNumber = messageNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  getEditors(): EditorDefinition<JoinNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: 'Flatten',\n        dataKey: 'flatten',\n      },\n      {\n        type: 'code',\n        label: 'Join String',\n        dataKey: 'joinString',\n        useInputToggleDataKey: 'useJoinStringInput',\n        language: 'plaintext',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return this.data.useJoinStringInput\n      ? '(Join value is input)'\n      : this.data.joinString === '\\n'\n        ? '(New line)'\n        : this.data.joinString === '\\t'\n          ? '(Tab)'\n          : this.data.joinString === ' '\n            ? '(Space)'\n            : this.data.joinString;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes an array of strings, and joins them using the configured delimiter.\n\n        Defaults to a newline.\n      `,\n      infoBoxTitle: 'Join Node',\n      contextMenuTitle: 'Join',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const joinString = this.data.useJoinStringInput\n      ? coerceTypeOptional(inputs['joinString' as PortId], 'string') ?? this.data.joinString\n      : this.data.joinString;\n\n    const normalizedJoinString = handleEscapeCharacters(joinString);\n\n    const inputKeys = Object.keys(inputs).filter((key) => key.startsWith('input'));\n\n    const inputValueStrings: string[] = [];\n\n    for (let i = 1; i <= inputKeys.length; i++) {\n      const inputValue = inputs[`input${i}` as PortId];\n      if (isArrayDataValue(inputValue) && this.data.flatten) {\n        for (const value of inputValue.value) {\n          inputValueStrings.push(coerceType(inferType(value), 'string'));\n        }\n      } else if (inputValue) {\n        inputValueStrings.push(coerceType(inputValue, 'string'));\n      }\n    }\n\n    const outputValue = inputValueStrings.join(normalizedJoinString);\n\n    return {\n      ['output' as PortId]: {\n        type: 'string',\n        value: outputValue,\n      },\n    };\n  }\n}\n\nexport const joinNode = nodeDefinition(JoinNodeImpl, 'Coalesce');\n"]},{"id":"z9RrFk7uxZQFwX_VNuNnL","data":["DelegateFunctionCallNode.ts","import { nanoid } from 'nanoid';\nimport type {\n  AssistantChatMessageFunctionCall,\n  DataValue,\n  GptFunction,\n  ParsedAssistantChatMessageFunctionCall,\n} from '../DataValue.js';\nimport type { ChartNode, NodeId, NodeInputDefinition, NodeOutputDefinition, PortId } from '../NodeBase.js';\nimport type { GraphId } from '../NodeGraph.js';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type DelegateFunctionCallNode = ChartNode<'delegateFunctionCall', DelegateFunctionCallNodeData>;\n\nexport type DelegateFunctionCallNodeData = {\n  handlers: { key: string; value: GraphId }[];\n  unknownHandler: GraphId | undefined;\n};\n\nexport class DelegateFunctionCallNodeImpl extends NodeImpl<DelegateFunctionCallNode> {\n  static create(): DelegateFunctionCallNode {\n    const chartNode: DelegateFunctionCallNode = {\n      type: 'delegateFunctionCall',\n      title: 'Delegate Function Call',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 325,\n      },\n      data: {\n        handlers: [],\n        unknownHandler: undefined,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    inputs.push({\n      id: 'function-call' as PortId,\n      dataType: 'object',\n      title: 'Function Call',\n      coerced: true,\n      required: true,\n      description: 'The function call to delegate to a subgraph.',\n    });\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n\n    outputs.push({\n      id: 'output' as PortId,\n      dataType: 'string',\n      title: 'Output',\n      description: 'The output of the function call.',\n    });\n\n    outputs.push({\n      id: 'message' as PortId,\n      dataType: 'object',\n      title: 'Message Output',\n      description: 'Maps the output for use directly with an Assemble Prompt node and GPT.',\n    });\n\n    return outputs;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Handles a function call by delegating it to a different subgraph depending on the function call.\n      `,\n      infoBoxTitle: 'Delegate Function Call Node',\n      contextMenuTitle: 'Delegate Function Call',\n      group: ['Advanced'],\n    };\n  }\n\n  getEditors(): EditorDefinition<DelegateFunctionCallNode>[] {\n    return [\n      {\n        type: 'custom',\n        customEditorId: 'ToolCallHandlers',\n        label: 'Handlers',\n        dataKey: 'handlers',\n      },\n      {\n        type: 'graphSelector',\n        dataKey: 'unknownHandler',\n        label: 'Unknown Handler',\n        helperMessage: 'The subgraph to delegate to if the function call does not match any handlers.',\n      },\n    ];\n  }\n\n  getBody(context: RivetUIContext): NodeBody {\n    if (this.data.handlers.length === 0) {\n      return 'No handlers defined';\n    }\n\n    const lines = ['Handlers:'];\n\n    this.data.handlers.forEach(({ key, value }) => {\n      const subgraphName = context.project.graphs[value]?.metadata!.name! ?? 'Unknown Subgraph';\n      lines.push(`    ${key || '(MISSING!)'} -> ${subgraphName}`);\n    });\n\n    return lines.join('\\n');\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const functionCall = coerceType(\n      inputs['function-call' as PortId],\n      'object',\n    ) as ParsedAssistantChatMessageFunctionCall;\n\n    let handler = this.data.handlers.find((handler) => handler.key === functionCall.name);\n\n    if (!handler) {\n      if (this.data.unknownHandler) {\n        handler = { key: undefined!, value: this.data.unknownHandler };\n      } else {\n        throw new Error(`No handler found for function call: ${functionCall.name}`);\n      }\n    }\n\n    const subgraphInputs: Record<string, DataValue> = {\n      _function_name: {\n        type: 'string',\n        value: functionCall.name,\n      },\n      _arguments: {\n        type: 'object',\n        value: functionCall.arguments,\n      },\n    };\n\n    for (const [argName, argument] of Object.entries(functionCall.arguments)) {\n      subgraphInputs[argName] = {\n        type: 'any',\n        value: argument,\n      };\n    }\n\n    const handlerGraphId = handler.value;\n    const subprocessor = context.createSubProcessor(handlerGraphId, { signal: context.signal });\n\n    const outputs = await subprocessor.processGraph(context, subgraphInputs, context.contextValues);\n\n    const outputString = coerceTypeOptional(outputs.output, 'string') ?? '';\n\n    return {\n      ['output' as PortId]: {\n        type: 'string',\n        value: outputString,\n      },\n      ['message' as PortId]: {\n        type: 'chat-message',\n        value: {\n          type: 'function',\n          message: outputString,\n          name: functionCall.id ?? '',\n        },\n      },\n    };\n  }\n}\n\nexport const delegateFunctionCallNode = nodeDefinition(DelegateFunctionCallNodeImpl, 'Delegate Function Call');\n"]},{"id":"zFHhv9ECkHGd4cF-38jnz","data":["PlayAudioNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type EditorDefinition, type Inputs, type InternalProcessContext, type Outputs } from '../../index.js';\nimport { expectType } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type PlayAudioNode = ChartNode<'playAudio', PlayAudioNodeData>;\n\ntype PlayAudioNodeData = {};\n\nexport class PlayAudioNodeImpl extends NodeImpl<PlayAudioNode> {\n  static create(): PlayAudioNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'playAudio',\n      title: 'Play Audio',\n      visualData: { x: 0, y: 0, width: 200 },\n      data: {},\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'data' as PortId,\n      title: 'Data',\n      dataType: 'audio',\n      coerced: false,\n    });\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: 'Audio Data',\n        dataType: 'audio',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<PlayAudioNode>[] {\n    return [];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      contextMenuTitle: 'Play Audio',\n      group: 'Input/Output',\n      infoBoxTitle: 'Play Audio Node',\n      infoBoxBody: 'Plays audio data to the speakers.',\n    };\n  }\n\n  async process(inputData: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    if (!context.audioProvider) {\n      throw new Error('Playing audio is not supported in this context');\n    }\n\n    const data = expectType(inputData['data' as PortId], 'audio');\n\n    await context.audioProvider.playAudio({ type: 'audio', value: data }, context.signal);\n\n    return {\n      ['data' as PortId]: {\n        type: 'audio',\n        value: data,\n      },\n    };\n  }\n}\n\nexport const playAudioNode = nodeDefinition(PlayAudioNodeImpl, 'Play Audio');\n"]},{"id":"yokMUU8qAxcuww6tmcyug","data":["ShuffleNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { shuffle } from 'lodash-es';\nimport { type DataValue, isArrayDataValue } from '../DataValue.js';\nimport { dedent } from 'ts-dedent';\n\nexport type ShuffleNode = ChartNode<'shuffle'>;\n\nexport class ShuffleNodeImpl extends NodeImpl<ShuffleNode> {\n  static create(): ShuffleNode {\n    const chartNode: ShuffleNode = {\n      type: 'shuffle',\n      title: 'Shuffle',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        dataType: 'any[]',\n        id: 'array' as PortId,\n        title: 'Array',\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'any[]',\n        id: 'shuffled' as PortId,\n        title: 'Shuffled',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Shuffles the input array. Outputs the shuffled array.\n      `,\n      infoBoxTitle: 'Shuffle Node',\n      contextMenuTitle: 'Shuffle',\n      group: ['Lists'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const input = inputs['array' as PortId];\n\n    const items = input ? (isArrayDataValue(input) ? input.value : [input.value]) : [];\n\n    const shuffled = shuffle(items);\n\n    return {\n      ['shuffled' as PortId]: {\n        type: inputs['array' as PortId]?.type ?? 'any[]',\n        value: shuffled,\n      } as DataValue,\n    };\n  }\n}\n\nexport const shuffleNode = nodeDefinition(ShuffleNodeImpl, 'Shuffle');\n"]},{"id":"0FWB4xvHYUiwBY_g8FTVu","data":["VectorStoreNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type EditorDefinition, type VectorDataValue } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { getIntegration } from '../../integrations/integrations.js';\nimport { getInputOrData } from '../../utils/index.js';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type VectorStoreNode = ChartNode<'vectorStore', VectorStoreNodeData>;\n\nexport type VectorStoreNodeData = {\n  integration: string;\n  useIntegrationInput?: boolean;\n\n  collectionId: string;\n  useCollectionIdInput?: boolean;\n};\n\nexport class VectorStoreNodeImpl extends NodeImpl<VectorStoreNode> {\n  static create(): VectorStoreNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'vectorStore',\n      title: 'Vector Store',\n      visualData: { x: 0, y: 0, width: 200 },\n      data: {\n        integration: 'pinecone',\n        collectionId: '',\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'vector' as PortId,\n      title: 'Vector',\n      dataType: 'vector',\n      required: true,\n    });\n\n    if (this.data.useCollectionIdInput) {\n      inputDefinitions.push({\n        id: 'collectionId' as PortId,\n        title: 'Collection ID',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    inputDefinitions.push({\n      id: 'data' as PortId,\n      title: 'Data',\n      dataType: 'any',\n      required: true,\n    });\n\n    if (this.data.useIntegrationInput) {\n      inputDefinitions.push({\n        id: 'integration' as PortId,\n        title: 'Integration',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    inputDefinitions.push({\n      id: 'id' as PortId,\n      title: 'ID',\n      dataType: 'string',\n      required: false,\n    });\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'complete' as PortId,\n        title: 'Complete',\n        dataType: 'boolean',\n      },\n    ];\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<VectorStoreNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Integration',\n        dataKey: 'integration',\n        options: [{ label: 'Pinecone', value: 'pinecone' }],\n        useInputToggleDataKey: 'useIntegrationInput',\n      },\n      {\n        type: 'string',\n        label: 'Collection ID',\n        dataKey: 'collectionId',\n        useInputToggleDataKey: 'useCollectionIdInput',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return dedent`\n      Integration: ${this.data.useIntegrationInput ? '(using input)' : this.data.integration}\n      Collection Id: ${this.data.useCollectionIdInput ? '(using input)' : this.data.collectionId}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in a vector, as well as data to store with the vector. This data is stored in the configured vector DB integration for later retrieval.\n      `,\n      infoBoxTitle: 'Vector Store Node',\n      contextMenuTitle: 'Vector Store',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const integration = getInputOrData(this.data, inputs, 'integration');\n    const vectorDb = getIntegration('vectorDatabase', integration, context);\n\n    const indexUrl = getInputOrData(this.data, inputs, 'collectionId');\n\n    if (inputs['vector' as PortId]?.type !== 'vector') {\n      throw new Error(`Expected vector input, got ${inputs['vector' as PortId]?.type}`);\n    }\n\n    await vectorDb.store(\n      { type: 'string', value: indexUrl },\n      inputs['vector' as PortId] as VectorDataValue,\n      inputs['data' as PortId]!,\n      {\n        id: coerceTypeOptional(inputs['id' as PortId], 'string'),\n      },\n    );\n\n    return {\n      ['complete' as PortId]: {\n        type: 'boolean',\n        value: true,\n      },\n    };\n  }\n}\n\nexport const vectorStoreNode = nodeDefinition(VectorStoreNodeImpl, 'Vector Store');\n"]},{"id":"vaNSbV8gsl-dAtHUAMefH","data":["ChunkNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../../model/NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../../model/NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { dedent } from 'ts-dedent';\nimport { openAiModelOptions } from '../../utils/openai.js';\nimport { type EditorDefinition, type Inputs, type InternalProcessContext, type Outputs } from '../../index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { Tokenizer, TokenizerCallInfo } from '../../integrations/Tokenizer.js';\n\nexport type ChunkNodeData = {\n  numTokensPerChunk: number;\n\n  model: string;\n  useModelInput: boolean;\n\n  overlap: number;\n};\n\nexport type ChunkNode = ChartNode<'chunk', ChunkNodeData>;\n\nexport class ChunkNodeImpl extends NodeImpl<ChunkNode> {\n  static create() {\n    const chartNode: ChunkNode = {\n      type: 'chunk',\n      title: 'Chunk',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        model: 'gpt-4o',\n        useModelInput: false,\n        numTokensPerChunk: 1024,\n        overlap: 0,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n      },\n    ];\n\n    if (this.data.useModelInput) {\n      inputs.push({\n        id: 'model' as PortId,\n        title: 'Model',\n        dataType: 'string',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'chunks' as PortId,\n        title: 'Chunks',\n        dataType: 'string[]',\n      },\n      {\n        id: 'first' as PortId,\n        title: 'First',\n        dataType: 'string',\n      },\n      {\n        id: 'last' as PortId,\n        title: 'Last',\n        dataType: 'string',\n      },\n      {\n        id: 'indexes' as PortId,\n        title: 'Indexes',\n        dataType: 'number[]',\n      },\n      {\n        id: 'count' as PortId,\n        title: 'Count',\n        dataType: 'number',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ChunkNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Model',\n        dataKey: 'model',\n        options: openAiModelOptions,\n        useInputToggleDataKey: 'useModelInput',\n      },\n      {\n        type: 'number',\n        label: 'Number of tokens per chunk',\n        dataKey: 'numTokensPerChunk',\n        min: 1,\n        max: 32768,\n        step: 1,\n      },\n      {\n        type: 'number',\n        label: 'Overlap (in %)',\n        dataKey: 'overlap',\n        min: 0,\n        max: 100,\n        step: 1,\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return dedent`\n      Model: ${this.data.model}\n      Token Count: ${this.data.numTokensPerChunk.toLocaleString()}\n      ${this.data.overlap ? `Overlap: ${this.data.overlap}%` : ''}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n          Splits the input text into an array of chunks based on an approximate GPT token count per chunk.\n\n          The \"overlap\" setting allows you to partially overlap the chunks for redundancy.\n\n          Can also be used for string length truncation by only using the \\`First\\` or \\`Last\\` outputs of the node.\n        `,\n      infoBoxTitle: 'Chunk Node',\n      contextMenuTitle: 'Chunk',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const input = coerceType(inputs['input' as PortId], 'string');\n\n    const overlapPercent = this.chartNode.data.overlap / 100;\n\n    const chunked = await chunkStringByTokenCount(\n      context.tokenizer,\n      {\n        node: this.chartNode,\n        endpoint: undefined,\n        model: this.data.model,\n      },\n      input,\n      this.chartNode.data.numTokensPerChunk,\n      overlapPercent,\n    );\n\n    return {\n      ['chunks' as PortId]: {\n        type: 'string[]',\n        value: chunked,\n      },\n      ['first' as PortId]: {\n        type: 'string',\n        value: chunked[0]!,\n      },\n      ['last' as PortId]: {\n        type: 'string',\n        value: chunked.at(-1)!,\n      },\n      ['indexes' as PortId]: {\n        type: 'number[]',\n        value: chunked.map((_, i) => i + 1),\n      },\n      ['count' as PortId]: {\n        type: 'number',\n        value: chunked.length,\n      },\n    };\n  }\n}\n\nexport const chunkNode = nodeDefinition(ChunkNodeImpl, 'Chunk');\n\nexport async function chunkStringByTokenCount(\n  tokenizer: Tokenizer,\n  tokenizerInfo: TokenizerCallInfo,\n  input: string,\n  targetTokenCount: number,\n  overlapPercent: number,\n) {\n  overlapPercent = Number.isNaN(overlapPercent) ? 0 : Math.max(0, Math.min(1, overlapPercent));\n\n  const chunks: string[] = [];\n  const guess = Math.floor(\n    targetTokenCount * (input.length / (await tokenizer.getTokenCountForString(input, tokenizerInfo))),\n  );\n  let remaining = input;\n\n  while (remaining.length > 0) {\n    chunks.push(remaining.slice(0, guess));\n    remaining = remaining.slice(guess - Math.floor(guess * overlapPercent));\n  }\n\n  return chunks;\n}\n"]},{"id":"uxhch5EunE07JyRbXyF_8","data":["ToTreeNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\nimport { extractInterpolationVariables, interpolate } from '../../utils/interpolation.js';\nimport { get, sortBy } from 'lodash-es';\n\nexport type ToTreeNode = ChartNode<'toTree', ToTreeNodeData>;\n\nexport type ToTreeNodeData = {\n  format: string;\n  childrenProperty: string;\n  useSortAlphabetically: boolean;\n};\n\nexport class ToTreeNodeImpl extends NodeImpl<ToTreeNode> {\n  static create(): ToTreeNode {\n    const chartNode: ToTreeNode = {\n      type: 'toTree',\n      title: 'To Tree',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        format: '{{path}}',\n        childrenProperty: 'children',\n        useSortAlphabetically: true,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'objects' as PortId,\n        title: 'Objects',\n        dataType: ['object[]', 'object'],\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'tree' as PortId,\n        title: 'Tree',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ToTreeNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Children Property',\n        dataKey: 'childrenProperty',\n      },\n      {\n        type: 'code',\n        label: 'Format',\n        dataKey: 'format',\n        language: 'prompt-interpolation-markdown',\n        theme: 'prompt-interpolation',\n      },\n      {\n        type: 'toggle',\n        label: 'Sort Alphabetically',\n        dataKey: 'useSortAlphabetically',\n      },\n    ];\n  }\n\n  getBody(): string {\n    return dedent`\n      Format: ${this.data.format}\n      Children: ${this.data.childrenProperty}\n      Sort: ${this.data.useSortAlphabetically ? 'Yes' : 'No'}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Converts an array of objects into a tree structure and renders it as text.\n\n        The format field supports interpolation using {{property}} syntax to determine\n        how each node is displayed.\n\n        Use the children property to specify which field contains child nodes.\n      `,\n      infoBoxTitle: 'To Tree Node',\n      contextMenuTitle: 'To Tree',\n      group: ['Text'],\n    };\n  }\n\n  buildTree(objects: unknown[], parentPath: string = '', level: number = 0, isLast: boolean = true): string {\n    if (!Array.isArray(objects) || objects.length === 0) return '';\n\n    let result = '';\n    const sortedObjects = this.data.useSortAlphabetically\n      ? sortBy(objects, (obj) => String(get(obj, 'path', '')))\n      : objects;\n\n    sortedObjects.forEach((obj, index) => {\n      const isLastItem = index === sortedObjects.length - 1;\n      const prefix = level === 0 ? '' : isLast ? '└── ' : '├── ';\n      const indent = level === 0 ? '' : '    '.repeat(level - 1) + (isLast ? '    ' : '│   ');\n\n      // Get all potential interpolation variables from the format string\n      const matches = extractInterpolationVariables(this.data.format);\n      const interpolationVars = matches.reduce(\n        (acc, match) => {\n          const key = match;\n          acc[key] = String(get(obj, key, ''));\n          return acc;\n        },\n        {} as Record<string, string>,\n      );\n\n      const formattedNode = interpolate(this.data.format, interpolationVars);\n\n      // Add this node to the result\n      result += indent + prefix + formattedNode + '\\n';\n\n      // Process children if they exist\n      const children = get(obj, this.data.childrenProperty);\n      if (Array.isArray(children) && children.length > 0) {\n        const newPath = parentPath ? `${parentPath}/${formattedNode}` : formattedNode;\n        result += this.buildTree(children, newPath, level + 1, isLastItem);\n      }\n    });\n\n    return result;\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const objects = coerceTypeOptional(inputs['objects' as PortId], 'object[]') ?? [];\n    const treeOutput = this.buildTree(objects);\n\n    return {\n      ['tree' as PortId]: {\n        type: 'string',\n        value: treeOutput,\n      },\n    };\n  }\n}\n\nexport const toTreeNode = nodeDefinition(ToTreeNodeImpl, 'To Tree');\n"]},{"id":"dbqn4EkOlfrNV2L0OIx4B","data":["ContextNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { type DataType, type DataValue } from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type ContextNode = ChartNode<'context', ContextNodeData>;\n\nexport type ContextNodeData = {\n  id: string;\n  dataType: DataType;\n  defaultValue?: unknown;\n  useDefaultValueInput?: boolean;\n};\n\nexport class ContextNodeImpl extends NodeImpl<ContextNode> {\n  static create(): ContextNode {\n    const chartNode: ContextNode = {\n      type: 'context',\n      title: 'Context',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        id: 'input',\n        dataType: 'string',\n        defaultValue: undefined,\n        useDefaultValueInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    if (this.data.useDefaultValueInput) {\n      return [\n        {\n          id: 'default' as PortId,\n          title: 'Default Value',\n          dataType: this.chartNode.data.dataType as DataType,\n        },\n      ];\n    }\n\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: this.data.id,\n        dataType: this.chartNode.data.dataType as DataType,\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ContextNode>[] {\n    return [\n      { type: 'string', label: 'ID', dataKey: 'id' },\n      { type: 'dataTypeSelector', label: 'Data Type', dataKey: 'dataType' },\n      {\n        type: 'anyData',\n        label: 'Default Value',\n        dataKey: 'defaultValue',\n        useInputToggleDataKey: 'useDefaultValueInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      ${this.data.id}\n      Type: ${this.data.dataType}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Retrieves a value from the graph's context using a configured id. The context serves as a \"global graph input\", allowing the same values to be accessible from any graph or subgraph.\n      `,\n      infoBoxTitle: 'Context Node',\n      contextMenuTitle: 'Context',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const contextValue = context.contextValues[this.data.id];\n\n    if (contextValue !== undefined) {\n      return {\n        ['data' as PortId]: contextValue,\n      };\n    }\n\n    let defaultValue;\n    if (this.data.useDefaultValueInput) {\n      defaultValue = inputs['default' as PortId]!;\n    } else {\n      defaultValue = { type: this.data.dataType, value: this.data.defaultValue } as DataValue;\n    }\n\n    return {\n      ['data' as PortId]: defaultValue,\n    };\n  }\n}\n\nexport const contextNode = nodeDefinition(ContextNodeImpl, 'Context');\n"]},{"id":"KgywHbvCdB8q9KirHRy2G","data":["PromptNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type AssistantChatMessage,\n  type AssistantChatMessageFunctionCall,\n  type ChatMessage,\n  type EditorDefinition,\n  type Inputs,\n  type InternalProcessContext,\n  type NodeBodySpec,\n  type Outputs,\n} from '../../index.js';\nimport { mapValues } from 'lodash-es';\nimport { dedent } from 'ts-dedent';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\nimport { getInputOrData } from '../../utils/index.js';\nimport { interpolate, extractInterpolationVariables } from '../../utils/interpolation.js';\nimport { match } from 'ts-pattern';\n\nexport type PromptNode = ChartNode<'prompt', PromptNodeData>;\n\nexport type PromptNodeData = {\n  type: 'system' | 'user' | 'assistant' | 'function';\n  useTypeInput: boolean;\n\n  promptText: string;\n\n  name?: string;\n  useNameInput?: boolean;\n  enableFunctionCall?: boolean;\n  computeTokenCount?: boolean;\n\n  isCacheBreakpoint?: boolean;\n  useIsCacheBreakpointInput?: boolean;\n};\n\nexport class PromptNodeImpl extends NodeImpl<PromptNode> {\n  static create(): PromptNode {\n    const chartNode: PromptNode = {\n      type: 'prompt',\n      title: 'Prompt',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        type: 'user',\n        useTypeInput: false,\n        promptText: '{{input}}',\n        enableFunctionCall: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    let inputs: NodeInputDefinition[] = [];\n\n    if (this.data.enableFunctionCall) {\n      inputs.push({\n        id: 'function-call' as PortId,\n        title: 'Function Call',\n        dataType: 'object',\n      });\n    }\n\n    if (this.data.useTypeInput) {\n      inputs.push({\n        id: 'type' as PortId,\n        title: 'Type',\n        dataType: 'string',\n      });\n    }\n\n    if (this.data.useNameInput) {\n      inputs.push({\n        id: 'name' as PortId,\n        title: 'Name/ID',\n        dataType: 'string',\n      });\n    }\n\n    if (this.data.useIsCacheBreakpointInput) {\n      inputs.push({\n        id: 'isCacheBreakpoint' as PortId,\n        title: 'Is Cache Breakpoint',\n        dataType: 'boolean',\n      });\n    }\n\n    // Extract inputs from promptText, everything like {{input}}\n    const inputNames = extractInterpolationVariables(this.data.promptText);\n    inputs = [\n      ...inputs,\n      ...(inputNames?.map((inputName): NodeInputDefinition => {\n        return {\n          id: inputName as PortId,\n          title: inputName,\n          dataType: 'string',\n          required: false,\n        };\n      }) ?? []),\n    ];\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'output' as PortId,\n        title: 'Output',\n        dataType: 'chat-message',\n      },\n    ];\n\n    if (this.chartNode.data.computeTokenCount) {\n      outputs.push({\n        id: 'tokenCount' as PortId,\n        title: 'Token Count',\n        dataType: 'number',\n      });\n    }\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<PromptNode>[] {\n    return [\n      {\n        type: 'custom',\n        customEditorId: 'PromptNodeAiAssist',\n        label: 'Generate Using AI',\n      },\n      {\n        type: 'dropdown',\n        label: 'Type',\n        options: [\n          { value: 'system', label: 'System' },\n          { value: 'user', label: 'User' },\n          { value: 'assistant', label: 'Assistant' },\n          { value: 'function', label: 'Function' },\n        ],\n        dataKey: 'type',\n        useInputToggleDataKey: 'useTypeInput',\n      },\n      {\n        type: 'string',\n        label: 'Name',\n        dataKey: 'name',\n        useInputToggleDataKey: 'useNameInput',\n        hideIf: (data) => data.type !== 'function',\n        helperMessage:\n          'For OpenAI, this is the tool call ID. Otherwise, it is the name of the function that is outputting the message.',\n      },\n      {\n        type: 'toggle',\n        label: 'Enable Function Call',\n        dataKey: 'enableFunctionCall',\n        hideIf: (data) => data.type !== 'assistant',\n      },\n      {\n        type: 'toggle',\n        label: 'Compute Token Count',\n        dataKey: 'computeTokenCount',\n      },\n      {\n        type: 'toggle',\n        label: 'Is Cache Breakpoint',\n        dataKey: 'isCacheBreakpoint',\n        helperMessage:\n          'For Anthropic, marks this message as a cache breakpoint - this message and every message before it will be cached using Prompt Caching.',\n        useInputToggleDataKey: 'useIsCacheBreakpointInput',\n      },\n      {\n        type: 'code',\n        label: 'Prompt Text',\n        dataKey: 'promptText',\n        language: 'prompt-interpolation-markdown',\n        theme: 'prompt-interpolation',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | NodeBodySpec[] | undefined {\n    return [\n      {\n        type: 'markdown',\n        text: dedent`\n          _${typeDisplay[this.data.type]}${this.data.name ? ` (${this.data.name})` : ''}_ ${this.data.isCacheBreakpoint ? ' (Cache Breakpoint)' : ''}\n      `,\n      },\n      {\n        type: 'colorized',\n        text: this.data.promptText.split('\\n').slice(0, 15).join('\\n').trim(),\n        language: 'prompt-interpolation-markdown',\n        theme: 'prompt-interpolation',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Outputs a chat message, which is a string of text with an attached \"type\" saying who sent the message (User, Assistant, System) and optionally an attached \"name\".\n\n        Also provides the same <span style=\"color: var(--primary)\">{{interpolation}}</span> capabilities as a Text node.\n\n        Can change one chat message type into another chat message type. For example, changing a User message into a System message.\n      `,\n      infoBoxTitle: 'Prompt Node',\n      contextMenuTitle: 'Prompt',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext<PromptNode>): Promise<Outputs> {\n    const inputMap = mapValues(inputs, (input) => coerceType(input, 'string')) as Record<PortId, string>;\n\n    const outputValue = interpolate(this.chartNode.data.promptText, inputMap);\n\n    const type = getInputOrData(this.data, inputs, 'type', 'string');\n    const isCacheBreakpoint = getInputOrData(this.data, inputs, 'isCacheBreakpoint', 'boolean');\n\n    if (['assistant', 'system', 'user', 'function'].includes(type) === false) {\n      throw new Error(`Invalid type: ${type}`);\n    }\n\n    const message = match(type)\n      .with(\n        'system',\n        (type): ChatMessage => ({\n          type,\n          message: outputValue,\n          isCacheBreakpoint,\n        }),\n      )\n      .with(\n        'user',\n        (type): ChatMessage => ({\n          type,\n          message: outputValue,\n          isCacheBreakpoint,\n        }),\n      )\n      .with('assistant', (type): ChatMessage => {\n        let functionCall = this.data.enableFunctionCall\n          ? coerceTypeOptional(inputs['function-call' as PortId], 'object')\n          : undefined;\n\n        // If no name is specified, ignore the function call\n        if (!functionCall?.name || !functionCall?.arguments) {\n          functionCall = undefined;\n        }\n\n        // GPT is weird - the arguments should be a stringified JSON object https://platform.openai.com/docs/api-reference/chat/create\n        if (functionCall?.arguments && typeof functionCall.arguments !== 'string') {\n          functionCall.arguments = JSON.stringify(functionCall.arguments);\n        }\n\n        return {\n          type,\n          message: outputValue,\n          function_call: functionCall as AssistantChatMessageFunctionCall,\n          function_calls: functionCall ? [functionCall as AssistantChatMessageFunctionCall] : undefined,\n          isCacheBreakpoint,\n        };\n      })\n      .with(\n        'function',\n        (type): ChatMessage => ({\n          type,\n          message: outputValue,\n          name: getInputOrData(this.data, inputs, 'name', 'string'),\n          isCacheBreakpoint,\n        }),\n      )\n      .otherwise(() => {\n        throw new Error(`Invalid chat-message type: ${type}`);\n      });\n\n    const outputs: Outputs = {\n      ['output' as PortId]: {\n        type: 'chat-message',\n        value: message,\n      },\n    };\n\n    if (this.chartNode.data.computeTokenCount) {\n      const tokenCount = await context.tokenizer.getTokenCountForMessages([message], undefined, {\n        node: this.chartNode,\n      });\n      outputs['tokenCount' as PortId] = {\n        type: 'number',\n        value: tokenCount,\n      };\n    }\n\n    return outputs;\n  }\n}\n\nexport const promptNode = nodeDefinition(PromptNodeImpl, 'Prompt');\n\nconst typeDisplay: Record<PromptNodeData['type'], string> = {\n  assistant: 'Assistant',\n  system: 'System',\n  user: 'User',\n  function: 'Function',\n};\n"]},{"id":"x14OlE_R_J4aD21vK39hP","data":["URLReferenceNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition, type NodeUIData } from '../../index.js';\nimport { nodeDefinition } from '../../model/NodeDefinition.js';\nimport { getInputOrData } from '../../utils/index.js';\n\nexport type UrlReferenceNode = ChartNode<'urlReference', UrlReferenceNodeData>;\n\nexport type UrlReferenceNodeData = {\n  url: string;\n  useUrlInput?: boolean;\n};\n\nexport class UrlReferenceNodeImpl extends NodeImpl<UrlReferenceNode> {\n  static create(): UrlReferenceNode {\n    const chartNode: UrlReferenceNode = {\n      type: 'urlReference',\n      title: 'URL Reference',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 225,\n      },\n      data: {\n        url: '',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useUrlInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'url' as PortId,\n        title: 'URL',\n        description: 'The value to convert into a URL reference.',\n        coerced: true,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'object',\n        id: 'urlReference' as PortId,\n        title: 'URL Reference',\n        description: 'A reference to a URL.',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<UrlReferenceNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'URL',\n        dataKey: 'url',\n        useInputToggleDataKey: 'useUrlInput',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      contextMenuTitle: 'URL Reference',\n      group: 'Data',\n      infoBoxTitle: 'URL Reference Node',\n      infoBoxBody:\n        'Defines a reference to a URL, or converts a string into a URL reference. Used with the Assemble Message node to define URLs for attachments/images.',\n    };\n  }\n\n  getBody(): string {\n    return this.data.useUrlInput ? '(URL Using Input)' : this.data.url;\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const url = getInputOrData(this.data, inputs, 'url', 'string');\n\n    return {\n      ['urlReference' as PortId]: {\n        type: 'object',\n        value: { type: 'url_reference', url },\n      },\n    };\n  }\n}\n\nexport const urlReferenceNode = nodeDefinition(UrlReferenceNodeImpl, 'URL Reference');\n"]},{"id":"Ox4S2kyp_yPPkNp1-SsHb","data":["CoalesceNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { type DataValue, unwrapDataValue } from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type CoalesceNode = ChartNode<'coalesce', CoalesceNodeData>;\n\nexport type CoalesceNodeData = {};\n\nexport class CoalesceNodeImpl extends NodeImpl<CoalesceNode> {\n  static create = (): CoalesceNode => {\n    const chartNode: CoalesceNode = {\n      type: 'coalesce',\n      title: 'Coalesce',\n      id: nanoid() as NodeId,\n      data: {},\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 150,\n      },\n    };\n    return chartNode;\n  };\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    inputs.push({\n      dataType: 'boolean',\n      id: 'conditional' as PortId,\n      title: 'Conditional',\n    });\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'any',\n        id: 'output' as PortId,\n        title: 'Output',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in any number of inputs and outputs the first value that exists. Useful for consolidating branches after a Match node. This node can also \"consume\" the \"Not Ran\" value.\n      `,\n      infoBoxTitle: 'Coalesce Node',\n      contextMenuTitle: 'Coalesce',\n      group: ['Logic'],\n    };\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);\n      if (messageNumber > maxInputNumber) {\n        maxInputNumber = messageNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  async process(inputData: Inputs): Promise<Outputs> {\n    const conditional = inputData['conditional' as PortId];\n\n    // This lets the coalesce actually be control-flow-excluded itself, because otherwise\n    // the input control-flow-excluded are consumed.\n    if (conditional?.type === 'control-flow-excluded') {\n      return {\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    const inputCount = Object.keys(inputData).filter((key) => key.startsWith('input')).length;\n    const okInputValues: DataValue[] = [];\n\n    for (let i = 1; i <= inputCount; i++) {\n      const inputValue = inputData[`input${i}` as PortId];\n      if (inputValue && inputValue.type !== 'control-flow-excluded' && unwrapDataValue(inputValue) != null) {\n        okInputValues.push(inputValue);\n      }\n    }\n\n    if (okInputValues.length === 0) {\n      return {\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['output' as PortId]: okInputValues[0]!,\n    };\n  }\n}\n\nexport const coalesceNode = nodeDefinition(CoalesceNodeImpl, 'Coalesce');\n"]},{"id":"enMDOS4JA-l2QUhkwlODG","data":["AppendToDatasetNode.ts","import type { ChartNode, NodeId, PortId, NodeInputDefinition, NodeOutputDefinition } from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { getInputOrData, coerceTypeOptional, newId, coerceType } from '../../utils/index.js';\nimport { arrayizeDataValue, unwrapDataValue } from '../DataValue.js';\nimport type { DatasetId, DatasetRow } from '../Dataset.js';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\n\nexport type AppendToDatasetNode = ChartNode<'appendToDataset', AppendToDatasetNodeData>;\n\ntype AppendToDatasetNodeData = {\n  datasetId: DatasetId;\n  useDatasetIdInput?: boolean;\n};\n\nexport class AppendToDatasetNodeImpl extends NodeImpl<AppendToDatasetNode> {\n  static create(): AppendToDatasetNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'appendToDataset',\n      title: 'Append to Dataset',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        datasetId: '' as DatasetId,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'data' as PortId,\n      dataType: 'string[]',\n      title: 'Data',\n      description:\n        'The data to append to the dataset. May be a string or array of strings. If an array, each element will be a column in the dataset.',\n    });\n\n    inputDefinitions.push({\n      id: 'id' as PortId,\n      dataType: 'string',\n      title: 'ID',\n      description:\n        'The ID of the row to append. If not provided, a random ID will be generated. If an existing ID is provided, the row will be overwritten.',\n    });\n\n    inputDefinitions.push({\n      id: 'embedding' as PortId,\n      dataType: 'vector',\n      title: 'Embedding',\n      description: 'The vector embedding to store with the row.',\n    });\n\n    if (this.data.useDatasetIdInput) {\n      inputDefinitions.push({\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n        description: 'The ID of the dataset to append to.',\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'dataset' as PortId,\n        title: 'Dataset',\n        dataType: 'object', // technically string[][]...\n      },\n      {\n        id: 'id_out' as PortId,\n        title: 'ID',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Appends a row of data to the specified dataset.\n      `,\n      infoBoxTitle: 'Append to Dataset Node',\n      contextMenuTitle: 'Append to Dataset',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<AppendToDatasetNode>[] | Promise<EditorDefinition<AppendToDatasetNode>[]> {\n    return [\n      {\n        type: 'datasetSelector',\n        label: 'Dataset',\n        dataKey: 'datasetId',\n        useInputToggleDataKey: 'useDatasetIdInput',\n      },\n    ];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId = getInputOrData(this.data, inputs, 'datasetId', 'string') as DatasetId;\n    const dataId = coerceTypeOptional(inputs['id' as PortId], 'string') || newId<DatasetId>();\n    const embedding = coerceTypeOptional(inputs['embedding' as PortId], 'vector');\n\n    const dataInput = inputs['data' as PortId];\n\n    if (!dataInput) {\n      throw new Error('data input is required');\n    }\n\n    const data = arrayizeDataValue(unwrapDataValue(dataInput));\n    const stringData = data.map((d) => coerceType(d, 'string'));\n\n    const newData: DatasetRow = {\n      id: dataId,\n      data: stringData,\n      embedding,\n    };\n\n    await datasetProvider.putDatasetRow(datasetId, newData);\n\n    return {\n      ['dataset' as PortId]: {\n        type: 'object',\n        value: newData as any,\n      },\n      ['id_out' as PortId]: {\n        type: 'string',\n        value: datasetId,\n      },\n    };\n  }\n}\n\nexport const appendToDatasetNode = nodeDefinition(AppendToDatasetNodeImpl, 'Append To Dataset');\n"]},{"id":"CeImJjAf3mzT1_-aGIt_r","data":["RaiseEventNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type RaiseEventNode = ChartNode<'raiseEvent', RaiseEventNodeData>;\n\nexport type RaiseEventNodeData = {\n  eventName: string;\n  useEventNameInput: boolean;\n};\n\nexport class RaiseEventNodeImpl extends NodeImpl<RaiseEventNode> {\n  static create(): RaiseEventNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'raiseEvent',\n      title: 'Raise Event',\n      visualData: { x: 0, y: 0, width: 150 },\n      data: {\n        eventName: 'toast',\n        useEventNameInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useEventNameInput) {\n      inputDefinitions.push({\n        id: 'eventName' as PortId,\n        title: 'Event Name',\n        dataType: 'string',\n      });\n    }\n\n    inputDefinitions.push({\n      id: 'data' as PortId,\n      title: 'Data',\n      dataType: 'any',\n    });\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'result' as PortId,\n        title: 'Result',\n        dataType: 'any',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<RaiseEventNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Event Name',\n        dataKey: 'eventName',\n        useInputToggleDataKey: 'useEventNameInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.useEventNameInput ? '(Using Input)' : this.data.eventName;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Raises an event that the host project or a 'Wait For Event' node can listen for.\n      `,\n      infoBoxTitle: 'Raise Event Node',\n      contextMenuTitle: 'Raise Event',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Record<string, DataValue>> {\n    const eventName = this.chartNode.data.useEventNameInput\n      ? coerceType(inputs['eventName' as PortId], 'string')\n      : this.chartNode.data.eventName;\n\n    const eventData = inputs['data' as PortId];\n\n    context.raiseEvent(eventName, eventData);\n\n    return {\n      result: eventData as DataValue,\n    };\n  }\n}\n\nexport const raiseEventNode = nodeDefinition(RaiseEventNodeImpl, 'Raise Event');\n"]},{"id":"kzlD85Iz9coa2fylrU6ti","data":["TrimChatMessagesNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../../model/NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../../model/NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport {\n  type EditorDefinition,\n  type Inputs,\n  type InternalProcessContext,\n  type NodeBodySpec,\n  type Outputs,\n} from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { TokenizerCallInfo } from '../../integrations/Tokenizer.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { getInputOrData } from '../../utils/index.js';\n\nexport type TrimChatMessagesNodeData = {\n  maxTokenCount: number;\n  useMaxTokenCountInput?: boolean;\n\n  removeFromBeginning: boolean;\n  useRemoveFromBeginningInput?: boolean;\n};\n\nexport type TrimChatMessagesNode = ChartNode<'trimChatMessages', TrimChatMessagesNodeData>;\n\nexport class TrimChatMessagesNodeImpl extends NodeImpl<TrimChatMessagesNode> {\n  static create() {\n    const chartNode: TrimChatMessagesNode = {\n      type: 'trimChatMessages',\n      title: 'Trim Chat Messages',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        maxTokenCount: 4096,\n        removeFromBeginning: true,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'chat-message[]',\n      },\n    ];\n\n    if (this.data.useMaxTokenCountInput) {\n      inputs.push({\n        id: 'maxTokenCount' as PortId,\n        title: 'Max Token Count',\n        dataType: 'number',\n      });\n    }\n\n    if (this.data.useRemoveFromBeginningInput) {\n      inputs.push({\n        id: 'removeFromBeginning' as PortId,\n        title: 'Remove From Beginning',\n        dataType: 'boolean',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'trimmed' as PortId,\n        title: 'Trimmed',\n        dataType: 'chat-message[]',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<TrimChatMessagesNode>[] {\n    return [\n      {\n        type: 'number',\n        label: 'Max Token Count',\n        dataKey: 'maxTokenCount',\n        useInputToggleDataKey: 'useMaxTokenCountInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Remove From Beginning',\n        dataKey: 'removeFromBeginning',\n        useInputToggleDataKey: 'useRemoveFromBeginningInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      Max Token Count: ${this.data.useMaxTokenCountInput ? '(From Input)' : this.data.maxTokenCount}\n      Remove From Beginning: ${\n        this.data.useRemoveFromBeginningInput ? '(From Input)' : this.data.removeFromBeginning ? 'Yes' : 'No'\n      }\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes an array of chat messages, and slices messages from the beginning or the end of the list until the total length of the messages is under the configured token length.\n\n        Useful for setting up infinite message chains that stay under the LLM context limit.\n      `,\n      infoBoxTitle: 'Trim Chat Messages Node',\n      contextMenuTitle: 'Trim Chat Messages',\n      group: ['AI'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext<TrimChatMessagesNode>): Promise<Outputs> {\n    const input = coerceType(inputs['input' as PortId], 'chat-message[]');\n\n    const maxTokenCount = getInputOrData(this.data, inputs, 'maxTokenCount', 'number');\n    const removeFromBeginning = getInputOrData(this.data, inputs, 'removeFromBeginning', 'boolean');\n\n    const trimmedMessages = [...input];\n\n    const tokenizerInfo: TokenizerCallInfo = {\n      node: this.chartNode,\n    };\n\n    let tokenCount = await context.tokenizer.getTokenCountForMessages(trimmedMessages, undefined, tokenizerInfo);\n\n    while (tokenCount > maxTokenCount) {\n      if (removeFromBeginning) {\n        trimmedMessages.shift();\n      } else {\n        trimmedMessages.pop();\n      }\n      tokenCount = await context.tokenizer.getTokenCountForMessages(trimmedMessages, undefined, tokenizerInfo);\n    }\n\n    return {\n      ['trimmed' as PortId]: {\n        type: 'chat-message[]',\n        value: trimmedMessages,\n      },\n    };\n  }\n}\n\nexport const trimChatMessagesNode = nodeDefinition(TrimChatMessagesNodeImpl, 'Trim Chat Messages');\n"]},{"id":"AxcdsO4oPlxKc6MwkmeB1","data":["CreateDatasetNode.ts","import type {\n  ChartNode,\n  DatasetId,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { coerceTypeOptional, dedent, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type CreateDatasetNode = ChartNode<'createDataset', CreateDatasetNodeData>;\n\ntype CreateDatasetNodeData = {};\n\nexport class CreateDatasetNodeImpl extends NodeImpl<CreateDatasetNode> {\n  static create(): CreateDatasetNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'createDataset',\n      title: 'Create Dataset',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {},\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      },\n      {\n        id: 'datasetName' as PortId,\n        title: 'Dataset Name',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'datasetId_out' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Creates a new dataset with the provided ID and name. If the dataset already exists, it does nothing.\n      `,\n      infoBoxTitle: 'Create Dataset Node',\n      contextMenuTitle: 'Create Dataset',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId =\n      (coerceTypeOptional(inputs['datasetId' as PortId], 'string') as DatasetId | undefined) || newId<DatasetId>();\n    const datasetName = coerceTypeOptional(inputs['datasetName' as PortId], 'string') || datasetId;\n\n    const existingDataset = await datasetProvider.getDatasetMetadata(datasetId);\n\n    if (!existingDataset) {\n      await datasetProvider.putDatasetMetadata({\n        id: datasetId,\n        name: datasetName,\n        description: '',\n        projectId: context.project.metadata.id,\n      });\n    }\n\n    return {\n      ['datasetId_out' as PortId]: {\n        type: 'string',\n        value: datasetId || datasetName,\n      },\n    };\n  }\n}\n\nexport const createDatasetNode = nodeDefinition(CreateDatasetNodeImpl, 'Create Dataset');\n"]},{"id":"WHN7CJzyF0Hzc67Q45f86","data":["LoopControllerNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../../index.js';\nimport { entries, values } from '../../utils/typeSafety.js';\n\nexport type LoopControllerNode = ChartNode<'loopController', LoopControllerNodeData>;\n\nexport type LoopControllerNodeData = {\n  maxIterations?: number;\n  atMaxIterationsAction?: 'break' | 'error';\n};\n\nexport class LoopControllerNodeImpl extends NodeImpl<LoopControllerNode> {\n  static create(): LoopControllerNode {\n    const chartNode: LoopControllerNode = {\n      type: 'loopController',\n      title: 'Loop Controller',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        maxIterations: 100,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[], nodes: Record<NodeId, ChartNode>): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const messageCount = this.#getInputPortCount(connections);\n\n    inputs.push({\n      dataType: 'any',\n      id: 'continue' as PortId,\n      title: 'Continue',\n    });\n\n    let i = 1;\n    for (; i <= messageCount + 1; i++) {\n      const input: NodeInputDefinition = {\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      };\n\n      const inputConnection = connections.find(\n        (connection) => connection.inputId === input.id && connection.inputNodeId === this.id,\n      );\n      if (inputConnection && nodes[inputConnection.outputNodeId]) {\n        input.title = nodes[inputConnection.outputNodeId]!.title;\n      }\n\n      const inputDefault: NodeInputDefinition = {\n        dataType: 'any',\n        id: `input${i}Default` as PortId,\n        title: `Input ${i} Default`,\n      };\n      const inputDefaultConnection = connections.find(\n        (connection) => connection.inputId === inputDefault.id && connection.inputNodeId === this.id,\n      );\n      if (inputDefaultConnection && nodes[inputDefaultConnection.outputNodeId]) {\n        inputDefault.title = `${nodes[inputDefaultConnection.outputNodeId]!.title} (Default)`;\n      }\n\n      inputs.push(input);\n      inputs.push(inputDefault);\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(connections: NodeConnection[], nodes: Record<NodeId, ChartNode>): NodeOutputDefinition[] {\n    const messageCount = this.#getInputPortCount(connections);\n\n    const outputs: NodeOutputDefinition[] = [];\n\n    outputs.push({\n      dataType: 'any',\n      id: 'break' as PortId,\n      title: 'Break',\n    });\n\n    outputs.push({\n      dataType: 'number',\n      id: 'iteration' as PortId,\n      title: 'Iteration',\n    });\n\n    for (let i = 1; i <= messageCount; i++) {\n      const output: NodeOutputDefinition = {\n        dataType: 'any',\n        id: `output${i}` as PortId,\n        title: `Output ${i}`,\n      };\n\n      const inputConnection = connections.find(\n        (connection) => connection.inputId === `input${i}` && connection.inputNodeId === this.id,\n      );\n      if (inputConnection && nodes[inputConnection.outputNodeId]) {\n        output.title = `${nodes[inputConnection.outputNodeId]!.title}?`;\n      }\n\n      outputs.push(output);\n    }\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<LoopControllerNode>[] {\n    return [\n      {\n        type: 'number',\n        label: 'Max Iterations',\n        dataKey: 'maxIterations',\n      },\n      {\n        type: 'dropdown',\n        options: [\n          {\n            label: 'Break',\n            value: 'break',\n          },\n          {\n            label: 'Error',\n            value: 'error',\n          },\n        ],\n        label: 'At Max Iterations',\n        dataKey: 'atMaxIterationsAction',\n        defaultValue: 'error',\n        helperMessage: 'What should happen when the max iterations is reached?',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Defines the entry point for a loop. Values from inside the loop should be passed back through the \"Input\" ports, and their corresponding \"Default\" values can be specified on the input ports as well.\n\n        If the \"continue\" input is falsey, then the \"break\" output will run.\n      `,\n      infoBoxTitle: 'Loop Controller Node',\n      contextMenuTitle: 'Loop Controller',\n      group: ['Logic'],\n    };\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const messageConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxMessageNumber = 0;\n    for (const connection of messageConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''));\n      if (messageNumber > maxMessageNumber) {\n        maxMessageNumber = messageNumber;\n      }\n    }\n\n    return maxMessageNumber;\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const output: Outputs = {};\n\n    let inputCount = 0;\n    while (inputs[`input${inputCount + 1}` as PortId] || inputs[`input${inputCount + 1}Default` as PortId]) {\n      inputCount++;\n    }\n\n    const defaultInputs = entries(inputs).filter(([key]) => key.endsWith('Default'));\n\n    // If any of the default inputs are control-flow-excluded, then exclude all outputs.\n    // Technically, it should be \"any node outside of the cycle\" but this should be good enough?\n    if (defaultInputs.some(([, value]) => value?.type === 'control-flow-excluded')) {\n      for (let i = 0; i <= inputCount; i++) {\n        output[`output${i}` as PortId] = { type: 'control-flow-excluded', value: undefined };\n      }\n      output['break' as PortId] = { type: 'control-flow-excluded', value: undefined };\n\n      return output;\n    }\n\n    const iterationCount = context.attachedData.loopInfo?.iterationCount ?? 0;\n\n    output['iteration' as PortId] = { type: 'number', value: iterationCount + 1 };\n\n    if (iterationCount >= (this.data.maxIterations ?? 100) && this.data.atMaxIterationsAction !== 'break') {\n      throw new Error(`Loop controller exceeded max iterations of ${this.data.maxIterations ?? 100}`);\n    }\n\n    // If the continue port is not connected (so undefined), or if it's undefined before it's\n    // inside the loop itself (connection has not ran yet), then we should continue by default.\n    let continueValue = false;\n\n    if (inputs['continue' as PortId] === undefined) {\n      continueValue = true;\n    } else {\n      const continueDataValue = inputs['continue' as PortId]!;\n      if (continueDataValue.type === 'control-flow-excluded') {\n        continueValue = false;\n      } else {\n        continueValue = coerceType(continueDataValue, 'boolean');\n      }\n    }\n\n    if (iterationCount >= (this.data.maxIterations ?? 100) && this.data.atMaxIterationsAction === 'break') {\n      continueValue = false;\n    }\n\n    if (continueValue) {\n      output['break' as PortId] = { type: 'control-flow-excluded', value: 'loop-not-broken' };\n    } else {\n      const inputValues: unknown[] = [];\n      for (let i = 1; i <= inputCount; i++) {\n        inputValues.push(inputs[`input${i}` as PortId]?.value);\n      }\n\n      // Break gets an array of all the input values\n      output['break' as PortId] = { type: 'any[]', value: inputValues };\n    }\n\n    for (let i = 1; i <= inputCount; i++) {\n      if (continueValue) {\n        const inputId = `input${i}` as PortId;\n        const outputId = `output${i}` as PortId;\n\n        if (inputs[inputId]) {\n          output[outputId] = inputs[inputId]!;\n        } else {\n          output[outputId] = inputs[`${inputId}Default` as PortId]!;\n        }\n      } else {\n        output[`output${i}` as PortId] = { type: 'control-flow-excluded', value: undefined };\n      }\n    }\n\n    return output;\n  }\n}\n\nexport const loopControllerNode = nodeDefinition(LoopControllerNodeImpl, 'Loop Controller');\n"]},{"id":"Drnv65NqslRPjJ6sqzRaP","data":["GraphInputNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataType, type DataValue, getDefaultValue, isArrayDataType } from '../DataValue.js';\nimport { type Inputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type DynamicEditorEditor, type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional, inferType } from '../../utils/coerceType.js';\n\nexport type GraphInputNode = ChartNode<'graphInput', GraphInputNodeData>;\n\nexport type GraphInputNodeData = {\n  id: string;\n  dataType: DataType;\n  defaultValue?: unknown;\n  useDefaultValueInput?: boolean;\n  editor?: DynamicEditorEditor;\n};\n\nexport class GraphInputNodeImpl extends NodeImpl<GraphInputNode> {\n  static create(): GraphInputNode {\n    const chartNode: GraphInputNode = {\n      type: 'graphInput',\n      title: 'Graph Input',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        id: 'input',\n        dataType: 'string',\n        defaultValue: undefined,\n        useDefaultValueInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    if (this.data.useDefaultValueInput) {\n      return [\n        {\n          id: 'default' as PortId,\n          title: 'Default Value',\n          dataType: this.chartNode.data.dataType as DataType,\n        },\n      ];\n    }\n\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: this.data.id,\n        dataType: this.chartNode.data.dataType as DataType,\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<GraphInputNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'ID',\n        dataKey: 'id',\n      },\n      {\n        type: 'dataTypeSelector',\n        label: 'Data Type',\n        dataKey: 'dataType',\n      },\n      {\n        type: 'anyData',\n        label: 'Default Value',\n        dataKey: 'defaultValue',\n        useInputToggleDataKey: 'useDefaultValueInput',\n      },\n      {\n        type: 'dropdown',\n        label: 'Editor',\n        dataKey: 'editor',\n        defaultValue: 'auto',\n        options: [\n          { label: 'None', value: 'none' },\n          { label: 'Auto', value: 'auto' },\n          { label: 'String', value: 'string' },\n          { label: 'Number', value: 'number' },\n          { label: 'Code', value: 'code' },\n          { label: 'Data Type', value: 'dataTypeSelector' },\n          { label: 'String List', value: 'stringList' },\n          { label: 'Key Value Pairs', value: 'keyValuePair' },\n          { label: 'Toggle', value: 'toggle' },\n        ] satisfies { label: string; value: DynamicEditorEditor }[],\n        helperMessage: 'The editor to use when editing this value in the UI. Make sure this matches the data type.',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      ${this.data.id}\n      Type: ${this.data.dataType}\n      ${this.data.defaultValue == null ? '' : `Default: ${this.data.defaultValue}`}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Defines an input for the graph which can be passed in when the graph is called, or defines one of the input ports when the graph is a subgraph.\n      `,\n      infoBoxTitle: 'Graph Input Node',\n      contextMenuTitle: 'Graph Input',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Record<string, DataValue>> {\n    let inputValue =\n      context.graphInputs[this.data.id] == null\n        ? undefined\n        : coerceTypeOptional(context.graphInputs[this.data.id], this.data.dataType);\n\n    if (inputValue == null && this.data.useDefaultValueInput) {\n      inputValue = coerceTypeOptional(inputs['default' as PortId], this.data.dataType);\n    }\n\n    if (inputValue == null) {\n      inputValue =\n        coerceTypeOptional(inferType(this.data.defaultValue), this.data.dataType) ||\n        getDefaultValue(this.data.dataType);\n    }\n\n    // Resolve undefined for array inputs to empty array\n    if (inputValue == null && isArrayDataType(this.data.dataType)) {\n      inputValue = { type: this.data.dataType, value: [] } as DataValue;\n    }\n\n    const value = {\n      type: this.data.dataType,\n      value: inputValue,\n    } as DataValue;\n\n    return { ['data' as PortId]: value };\n  }\n}\n\nexport const graphInputNode = nodeDefinition(GraphInputNodeImpl, 'Graph Input');\n"]},{"id":"HAwfeOwq0WLjMWXtXoQ1n","data":["ObjectNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\n\nexport type ObjectNode = ChartNode<'object', ObjectNodeData>;\n\nexport type ObjectNodeData = {\n  jsonTemplate: string;\n};\n\nconst DEFAULT_JSON_TEMPLATE = `{\n  \"key\": \"{{input}}\"\n}`;\n\nexport class ObjectNodeImpl extends NodeImpl<ObjectNode> {\n  static create(): ObjectNode {\n    const chartNode: ObjectNode = {\n      type: 'object',\n      title: 'Object',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        jsonTemplate: DEFAULT_JSON_TEMPLATE,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    // Extract inputs from text, everything like {{input}}\n    const inputNames = [...new Set(this.chartNode.data.jsonTemplate.match(/\\{\\{([^}]+)\\}\\}/g))];\n    return (\n      inputNames?.map((inputName) => {\n        return {\n          // id and title should not have the {{ and }}\n          id: inputName.slice(2, -2) as PortId,\n          title: inputName.slice(2, -2),\n          dataType: 'any',\n          required: false,\n        };\n      }) ?? []\n    );\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: ['object', 'object[]'],\n        id: 'output' as PortId,\n        title: 'Output',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ObjectNode>[] {\n    return [\n      {\n        type: 'custom',\n        customEditorId: 'ObjectNodeAiAssist',\n        label: 'AI Assist',\n      },\n      {\n        type: 'code',\n        label: 'JSON Template',\n        dataKey: 'jsonTemplate',\n        language: 'json',\n        theme: 'prompt-interpolation',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Creates an object from input values and a JSON template, escaping the input values and inserting them into the template.\n\n        Use double-quotes around the input values to escape them. String values are automatically escaped.\n\n        Useful for creating objects from multiple inputs.\n      `,\n      infoBoxTitle: 'Object Node',\n      contextMenuTitle: 'Object',\n      group: ['Objects'],\n    };\n  }\n\n  interpolate(baseString: string, values: Record<string, any>): string {\n    return baseString.replace(/(\"?)\\{\\{([^}]+)\\}\\}(\"?)/g, (_m, openQuote, key, _closeQuote) => {\n      const isQuoted = Boolean(openQuote);\n      const value = values[key];\n      if (value == null) {\n        return 'null';\n      }\n      if (isQuoted && typeof value === 'string') {\n        // Adds double-quotes back.\n        return JSON.stringify(value);\n      }\n      if (isQuoted) {\n        // Non-strings require a double-stringify, first to turn them into a string, then to escape that string and add quotes.\n        return JSON.stringify(JSON.stringify(value));\n      }\n      // Otherwise, it was not quoted, so no need to double-stringify\n      return JSON.stringify(value);\n    });\n  }\n\n  async process(inputs: Record<string, DataValue>): Promise<Record<string, DataValue>> {\n    const inputMap = Object.keys(inputs).reduce(\n      (acc, key) => {\n        acc[key] = (inputs[key] as any)?.value;\n        return acc;\n      },\n      {} as Record<string, any>,\n    );\n\n    const outputValue = JSON.parse(this.interpolate(this.chartNode.data.jsonTemplate, inputMap)) as Record<\n      string,\n      unknown\n    >;\n\n    if (Array.isArray(outputValue)) {\n      return {\n        output: {\n          type: 'object[]',\n          value: outputValue,\n        },\n      };\n    }\n\n    return {\n      output: {\n        type: 'object',\n        value: outputValue,\n      },\n    };\n  }\n}\n\nexport const objectNode = nodeDefinition(ObjectNodeImpl, 'Object');\n"]},{"id":"Hel_v2KgUdtk8PE2kNNsy","data":["PassthroughNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\n\nexport type PassthroughNode = ChartNode<'passthrough', PassthroughNodeData>;\n\nexport type PassthroughNodeData = {};\n\nexport class PassthroughNodeImpl extends NodeImpl<PassthroughNode> {\n  static create = (): PassthroughNode => {\n    const chartNode: PassthroughNode = {\n      type: 'passthrough',\n      title: 'Passthrough',\n      id: nanoid() as NodeId,\n      data: {},\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n    };\n    return chartNode;\n  };\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(connections: NodeConnection[]): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    for (let i = 1; i <= inputCount - 1; i++) {\n      outputs.push({\n        dataType: 'any',\n        id: `output${i}` as PortId,\n        title: `Output ${i}`,\n      });\n    }\n\n    return outputs;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Simply passes the input value to the output without any modifications.\n      `,\n      infoBoxTitle: 'Passthrough Node',\n      contextMenuTitle: 'Passthrough',\n      group: ['Logic'],\n    };\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);\n      if (messageNumber > maxInputNumber) {\n        maxInputNumber = messageNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  async process(inputData: Inputs): Promise<Outputs> {\n    const inputCount = Object.keys(inputData).filter((key) => key.startsWith('input')).length;\n\n    const outputs: Outputs = {};\n\n    for (let i = 1; i <= inputCount; i++) {\n      const input = inputData[`input${i}` as PortId]!;\n      outputs[`output${i}` as PortId] = input;\n    }\n\n    return outputs;\n  }\n}\n\nexport const passthroughNode = nodeDefinition(PassthroughNodeImpl, 'Passthrough');\n"]},{"id":"PviHsU44DXd9S4pkC1SGm","data":["GetGlobalNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type FunctionDataValues,\n  type ScalarDataType,\n  type ScalarDataValue,\n  type ScalarOrArrayDataType,\n  isArrayDataType,\n  isScalarDataType,\n  scalarDefaults,\n} from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition, type NodeBodySpec } from '../../index.js';\n\nexport type GetGlobalNode = ChartNode<'getGlobal', GetGlobalNodeData>;\n\nexport type GetGlobalNodeData = {\n  id: string;\n  useIdInput: boolean;\n\n  dataType: ScalarOrArrayDataType;\n\n  /**\n   * Returns a fn<value> instead of a value, so that the variable is read when nodes need it, rather than when this node executes.\n   * The only time you wouldn't want this is to read a global at the start of a subgraph.\n   */\n  onDemand: boolean;\n\n  /** Wait until the variable is available */\n  wait: boolean;\n};\n\nexport class GetGlobalNodeImpl extends NodeImpl<GetGlobalNode> {\n  static create(): GetGlobalNode {\n    const chartNode: GetGlobalNode = {\n      type: 'getGlobal',\n      title: 'Get Global',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        id: 'variable-name',\n        dataType: 'string',\n        onDemand: true,\n        useIdInput: false,\n        wait: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    if (this.data.useIdInput) {\n      return [\n        {\n          id: 'id' as PortId,\n          title: 'Variable ID',\n          dataType: this.data.dataType as ScalarDataType,\n        },\n      ];\n    }\n\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const { onDemand, dataType } = this.chartNode.data;\n    return [\n      {\n        id: 'value' as PortId,\n        title: 'Value',\n        dataType: onDemand ? (`fn<${dataType}>` as const) : dataType,\n      },\n      {\n        id: 'variable_id_out' as PortId,\n        title: 'Variable ID',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<GetGlobalNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Variable ID',\n        dataKey: 'id',\n        useInputToggleDataKey: 'useIdInput',\n      },\n      {\n        type: 'dataTypeSelector',\n        label: 'Data Type',\n        dataKey: 'dataType',\n      },\n      {\n        type: 'toggle',\n        label: 'On Demand',\n        dataKey: 'onDemand',\n      },\n      {\n        type: 'toggle',\n        label: 'Wait',\n        dataKey: 'wait',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      ${this.data.useIdInput ? '(ID from input)' : this.data.id}\n      Type: ${this.data.dataType}\n      ${this.data.wait ? 'Waits for available data' : ''}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Retrieves a global value that is shared across all graphs and subgraphs. The id of the global value is configured in this node.\n      `,\n      infoBoxTitle: 'Get Global Node',\n      contextMenuTitle: 'Get Global',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    if (this.data.onDemand) {\n      if (this.data.wait) {\n        throw new Error('Cannot use onDemand and wait together');\n      }\n      return {\n        ['value' as PortId]: {\n          type: `fn<${this.data.dataType}>` as const,\n          value: () => {\n            const id = this.data.useIdInput ? coerceType(inputs['id' as PortId], 'string') : this.data.id;\n\n            const value = context.getGlobal(id);\n            if (value) {\n              return value.value;\n            }\n\n            // Have some useful defaults before the value is set\n            if (isArrayDataType(this.data.dataType)) {\n              return [];\n            }\n\n            return scalarDefaults[this.data.dataType];\n          },\n        } as FunctionDataValues,\n      };\n    }\n\n    const id = this.data.useIdInput ? coerceType(inputs['id' as PortId], 'string') : this.data.id;\n\n    let value = this.data.wait ? await context.waitForGlobal(id) : context.getGlobal(id);\n\n    // Have some useful defaults before the value is set\n    if (!value && isArrayDataType(this.data.dataType)) {\n      value = { type: this.data.dataType, value: [] };\n    }\n\n    if (!value && isScalarDataType(this.data.dataType)) {\n      value = { type: this.data.dataType, value: scalarDefaults[this.data.dataType] } as ScalarDataValue;\n    }\n\n    return {\n      ['value' as PortId]: value,\n      ['variable_id_out' as PortId]: { type: 'string', value: id },\n    };\n  }\n}\n\nexport const getGlobalNode = nodeDefinition(GetGlobalNodeImpl, 'Get Global');\n"]},{"id":"NYHUD4pVtqoJrkGc8ibOp","data":["CompareNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { isEqual } from 'lodash-es';\nimport { match } from 'ts-pattern';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type CompareNode = ChartNode<'compare', CompareNodeData>;\n\nexport type CompareNodeData = {\n  comparisonFunction: '==' | '<' | '>' | '<=' | '>=' | '!=' | 'and' | 'or' | 'xor' | 'nand' | 'nor' | 'xnor';\n  useComparisonFunctionInput?: boolean;\n};\n\nexport class CompareNodeImpl extends NodeImpl<CompareNode> {\n  static create(): CompareNode {\n    const chartNode: CompareNode = {\n      type: 'compare',\n      title: 'Compare',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 160,\n      },\n      data: {\n        comparisonFunction: '==',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        dataType: 'any',\n        id: 'a' as PortId,\n        title: 'A',\n      },\n      {\n        dataType: 'any',\n        id: 'b' as PortId,\n        title: 'B',\n      },\n    ];\n\n    if (this.data.useComparisonFunctionInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'comparisonFunction' as PortId,\n        title: 'Comparison Function',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'boolean',\n        id: 'output' as PortId,\n        title: 'Output',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<CompareNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Comparison Function',\n        dataKey: 'comparisonFunction',\n        options: [\n          { label: '==', value: '==' },\n          { label: '!=', value: '!=' },\n          { label: '<', value: '<' },\n          { label: '<=', value: '<=' },\n          { label: '>', value: '>' },\n          { label: '>=', value: '>=' },\n          { label: 'and', value: 'and' },\n          { label: 'or', value: 'or' },\n          { label: 'xor', value: 'xor' },\n          { label: 'nand', value: 'nand' },\n          { label: 'nor', value: 'nor' },\n          { label: 'xnor', value: 'xnor' },\n        ],\n        useInputToggleDataKey: 'useComparisonFunctionInput',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return this.data.useComparisonFunctionInput ? 'A (Comparison Function) B' : `A ${this.data.comparisonFunction} B`;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Compares two values using the configured operator and outputs the result.\n\n        If the data types of the values do not match, then the B value is converted to the type of the A value.\n      `,\n      infoBoxTitle: 'Compare Node',\n      contextMenuTitle: 'Compare',\n      group: ['Logic'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const comparisonFunction = (\n      this.data.useComparisonFunctionInput\n        ? coerceType(inputs['comparisonFunction' as PortId], 'string')\n        : this.data.comparisonFunction\n    ) as CompareNodeData['comparisonFunction'];\n\n    const inputA = inputs['a' as PortId];\n    const inputB = inputs['b' as PortId];\n\n    if (!inputA) {\n      return {\n        ['output' as PortId]: {\n          type: 'boolean',\n          value: match(comparisonFunction)\n            .with('==', () => !inputB)\n            .with('!=', () => !!inputB)\n            .otherwise(() => false),\n        },\n      };\n    }\n\n    const value1 = inputA.value;\n    const value2 = inputB?.type !== inputA.type ? coerceTypeOptional(inputB, inputA.type) : inputB.value;\n\n    return {\n      ['output' as PortId]: {\n        type: 'boolean',\n        value: match(comparisonFunction)\n          .with('==', () => isEqual(value1, value2))\n          .with('!=', () => !isEqual(value1, value2))\n          .with('<', () => (value1 as any) < (value2 as any))\n          .with('>', () => (value1 as any) > (value2 as any))\n          .with('<=', () => (value1 as any) <= (value2 as any))\n          .with('>=', () => (value1 as any) >= (value2 as any))\n          .with('and', () => !!(value1 && value2))\n          .with('or', () => !!(value1 || value2))\n          .with('xor', () => !!(value1 ? !value2 : value2))\n          .with('nand', () => !(value1 && value2))\n          .with('nor', () => !(value1 || value2))\n          .with('xnor', () => !(value1 ? !value2 : value2))\n          .exhaustive(),\n      },\n    };\n  }\n}\n\nexport const compareNode = nodeDefinition(CompareNodeImpl, 'Compare');\n"]},{"id":"5kTw6RsdPNFjndKh1kLPK","data":["ArrayNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { entries } from '../../utils/typeSafety.js';\nimport { flattenDeep } from 'lodash-es';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type ArrayNode = ChartNode<'array', ArrayNodeData>;\n\nexport type ArrayNodeData = {\n  flatten?: boolean;\n  flattenDeep?: boolean;\n};\n\nexport class ArrayNodeImpl extends NodeImpl<ArrayNode> {\n  static create(): ArrayNode {\n    const chartNode: ArrayNode = {\n      type: 'array',\n      title: 'Array',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        flatten: true,\n        flattenDeep: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n        description:\n          'An input to create the array from. If an array, will be flattened if the \"Flatten\" option is enabled.',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'any[]',\n        id: 'output' as PortId,\n        title: 'Output',\n        description: 'The array created from the inputs.',\n      },\n      {\n        dataType: 'number[]',\n        id: 'indices' as PortId,\n        title: 'Indices',\n        description:\n          'The indices of the array. I.e. [0, 1, 2, 3, etc]. Useful for zipping with the output array to get the indexes.',\n      },\n      {\n        dataType: 'number',\n        id: 'length' as PortId,\n        title: 'Length',\n        description: 'The length of the output array.',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ArrayNode>[] {\n    return [\n      { type: 'toggle', label: 'Flatten', dataKey: 'flatten' },\n      {\n        type: 'toggle',\n        label: 'Deep',\n        dataKey: 'flattenDeep',\n      },\n    ];\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const inputNumber = parseInt(connection.inputId.replace('input', ''));\n      if (inputNumber > maxInputNumber) {\n        maxInputNumber = inputNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Creates an array from the input values. By default, flattens any arrays which are inputs into a single array. Can be configured to keep the arrays separate, or deeply flatten arrays.\n\n        Useful for both creating and merging arrays.\n\n        The number of inputs is dynamic based on the number of connections.\n      `,\n      infoBoxTitle: 'Array Node',\n      contextMenuTitle: 'Array',\n      group: ['Lists'],\n    };\n  }\n\n  getBody(): NodeBody {\n    return dedent`\n      ${this.data.flatten ? (this.data.flattenDeep ? 'Flatten (Deep)' : 'Flatten') : 'No Flatten'}\n    `;\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const outputArray: any[] = [];\n\n    for (const [key, input] of entries(inputs)) {\n      if (key.startsWith('input')) {\n        if (this.data.flatten) {\n          if (Array.isArray(input?.value)) {\n            for (const value of input?.value ?? []) {\n              if (this.data.flattenDeep) {\n                outputArray.push(...(Array.isArray(value) ? flattenDeep(value) : [value]));\n              } else {\n                outputArray.push(value);\n              }\n            }\n          } else {\n            outputArray.push(input?.value);\n          }\n        } else {\n          outputArray.push(input?.value);\n        }\n      }\n    }\n\n    return {\n      ['output' as PortId]: {\n        type: 'any[]',\n        value: outputArray,\n      },\n      ['indices' as PortId]: {\n        type: 'number[]',\n        value: outputArray.map((_, index) => index),\n      },\n      ['length' as PortId]: {\n        type: 'number',\n        value: outputArray.length,\n      },\n    };\n  }\n}\n\nexport const arrayNode = nodeDefinition(ArrayNodeImpl, 'Array');\n"]},{"id":"AWz7WoCYzg57blVOBF36r","data":["AbortGraphNode.ts","import type { ChartNode, NodeId, NodeOutputDefinition, PortId, NodeInputDefinition } from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport type { EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type AbortGraphNode = ChartNode<'abortGraph', AbortGraphNodeData>;\n\nexport type AbortGraphNodeData = {\n  /** Did the graph abort, but it's a success? Use this for early-exit instead of \"error abort\". */\n  successfully: boolean;\n\n  useSuccessfullyInput?: boolean;\n\n  errorMessage?: string;\n};\n\nexport class AbortGraphNodeImpl extends NodeImpl<AbortGraphNode> {\n  static create(): AbortGraphNode {\n    const chartNode: AbortGraphNode = {\n      type: 'abortGraph',\n      title: 'Abort Graph',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        successfully: true,\n        errorMessage: '',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'data' as PortId,\n        title: 'Data or Error',\n        dataType: 'any',\n        description: 'The message to abort the graph with.',\n      },\n    ];\n\n    if (this.data.useSuccessfullyInput) {\n      inputs.push({\n        id: 'successfully' as PortId,\n        title: 'Successfully',\n        dataType: 'boolean',\n        description: 'Whether to successfully abort the graph (early-exit), or error abort the graph.',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [];\n  }\n\n  getEditors(): EditorDefinition<AbortGraphNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: 'Successfully Abort',\n        dataKey: 'successfully',\n        useInputToggleDataKey: 'useSuccessfullyInput',\n      },\n      {\n        type: 'string',\n        label: 'Error Message (if not successfully aborting)',\n        dataKey: 'errorMessage',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return dedent`\n      ${\n        this.data.useSuccessfullyInput\n          ? 'Success depends on input'\n          : this.data.successfully\n            ? 'Successfully Abort'\n            : this.data.errorMessage\n              ? `Error Abort: ${this.data.errorMessage}`\n              : 'Error Abort'\n      }\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Aborts the execution of the entire graph immediately.\n\n        Can either \"successfully\" abort the graph (early-exit), or \"error\" abort the graph.\n      `,\n      infoBoxTitle: 'Abort Graph Node',\n      contextMenuTitle: 'Abort Graph',\n      group: ['Logic'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const successfully = this.data.useSuccessfullyInput\n      ? coerceTypeOptional(inputs['successfully' as PortId], 'boolean') ?? this.data.successfully\n      : this.data.successfully;\n\n    if (successfully) {\n      context.abortGraph();\n    } else {\n      const errorMessage =\n        coerceTypeOptional(inputs['data' as PortId], 'string')?.trim() ||\n        this.data.errorMessage ||\n        'Graph aborted with error';\n      context.abortGraph(errorMessage);\n    }\n\n    return {};\n  }\n}\n\nexport const abortGraphNode = nodeDefinition(AbortGraphNodeImpl, 'Abort Graph');\n"]},{"id":"tso-y4QWuk_boPXlG9Xg9","data":["ExtractMarkdownCodeBlocksNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { expectType } from '../../utils/expectType.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\n\nexport type ExtractMarkdownCodeBlocksNode = ChartNode<'extractMarkdownCodeBlocks', {}>;\n\nexport class ExtractMarkdownCodeBlocksNodeImpl extends NodeImpl<ExtractMarkdownCodeBlocksNode> {\n  static create(): ExtractMarkdownCodeBlocksNode {\n    const chartNode: ExtractMarkdownCodeBlocksNode = {\n      type: 'extractMarkdownCodeBlocks',\n      title: 'Extract Markdown Code Blocks',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'firstBlock' as PortId,\n        title: 'First Block',\n        dataType: 'string',\n      },\n      {\n        id: 'allBlocks' as PortId,\n        title: 'All Blocks',\n        dataType: 'string[]',\n      },\n      {\n        id: 'languages' as PortId,\n        title: 'Languages',\n        dataType: 'string[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Extracts the code blocks in the input Markdown text.\n\n        Outputs the first matched block, all matched blocks, and the languages specified for the blocks.\n      `,\n      infoBoxTitle: 'Extract Markdown Code Blocks Node',\n      contextMenuTitle: 'Extract Markdown Code Blocks',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const inputString = expectType(inputs['input' as PortId], 'string');\n\n    const regex = /```(\\w*)\\n([\\s\\S]*?)```/g;\n    let match;\n    let firstBlock: string | undefined;\n    const allBlocks = [];\n    const languages = [];\n\n    while ((match = regex.exec(inputString)) !== null) {\n      const language = match[1];\n      const block = match[2];\n\n      if (!firstBlock) {\n        firstBlock = block!;\n      }\n\n      allBlocks.push(block!);\n      languages.push(language!);\n    }\n\n    return {\n      ['firstBlock' as PortId]:\n        firstBlock == null\n          ? {\n              type: 'control-flow-excluded',\n              value: undefined,\n            }\n          : {\n              type: 'string',\n              value: firstBlock,\n            },\n      ['allBlocks' as PortId]: {\n        type: 'string[]',\n        value: allBlocks,\n      },\n      ['languages' as PortId]: {\n        type: 'string[]',\n        value: languages,\n      },\n    };\n  }\n}\n\nexport const extractMarkdownCodeBlocksNode = nodeDefinition(\n  ExtractMarkdownCodeBlocksNodeImpl,\n  'Extract Markdown Code Blocks',\n);\n"]},{"id":"jcBfiYLQsp8jxBUT6E9Zm","data":["VectorNearestNeighborsNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type DataValue, type EditorDefinition, type VectorDataValue } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { getIntegration } from '../../integrations/integrations.js';\nimport { getInputOrData } from '../../utils/index.js';\n\nexport type VectorNearestNeighborsNode = ChartNode<'vectorNearestNeighbors', VectorNearestNeighborsNodeData>;\n\nexport type VectorNearestNeighborsNodeData = {\n  integration: string;\n  useIntegrationInput?: boolean;\n\n  k: number;\n  useKInput?: boolean;\n\n  collectionId: string;\n  useCollectionIdInput?: boolean;\n};\n\nexport class VectorNearestNeighborsNodeImpl extends NodeImpl<VectorNearestNeighborsNode> {\n  static create(): VectorNearestNeighborsNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'vectorNearestNeighbors',\n      title: 'Vector KNN',\n      visualData: { x: 0, y: 0, width: 200 },\n      data: {\n        k: 10,\n        integration: 'pinecone',\n        collectionId: '',\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'vector' as PortId,\n      title: 'Vector',\n      dataType: 'vector',\n      required: true,\n    });\n\n    if (this.data.useIntegrationInput) {\n      inputDefinitions.push({\n        id: 'integration' as PortId,\n        title: 'Integration',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    if (this.data.useCollectionIdInput) {\n      inputDefinitions.push({\n        id: 'collectionId' as PortId,\n        title: 'Collection ID',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    if (this.data.useKInput) {\n      inputDefinitions.push({\n        id: 'k' as PortId,\n        title: 'K',\n        dataType: 'number',\n        required: true,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'results' as PortId,\n        title: 'Results',\n        dataType: 'any[]',\n      },\n    ];\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<VectorNearestNeighborsNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Integration',\n        dataKey: 'integration',\n        options: [{ label: 'Pinecone', value: 'pinecone' }],\n        useInputToggleDataKey: 'useIntegrationInput',\n      },\n      {\n        type: 'number',\n        label: 'K',\n        dataKey: 'k',\n        min: 1,\n        max: 100,\n        step: 1,\n        defaultValue: 10,\n        useInputToggleDataKey: 'useKInput',\n      },\n      {\n        type: 'string',\n        label: 'Collection ID',\n        dataKey: 'collectionId',\n        useInputToggleDataKey: 'useCollectionIdInput',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return dedent`\n      Integration: ${this.data.useIntegrationInput ? '(using input)' : this.data.integration}\n      K: ${this.data.useKInput ? '(using input)' : this.data.k}\n      Collection Id: ${this.data.useCollectionIdInput ? '(using input)' : this.data.collectionId}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Performs a k-nearest neighbors search on the vectors stored in the configured vector DB integration. Takes in a vector and returns the k closest vectors and their corresponding data.\n      `,\n      infoBoxTitle: 'Vector KNN Node',\n      contextMenuTitle: 'Vector KNN',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const integration = getInputOrData(this.data, inputs, 'integration');\n    const vectorDb = getIntegration('vectorDatabase', integration, context);\n\n    const indexUrl = getInputOrData(this.data, inputs, 'collectionId');\n    const k = getInputOrData(this.data, inputs, 'k', 'number');\n\n    if (inputs['vector' as PortId]?.type !== 'vector') {\n      throw new Error(`Expected vector input, got ${inputs['vector' as PortId]?.type}`);\n    }\n\n    const results = await vectorDb.nearestNeighbors(\n      { type: 'string', value: indexUrl },\n      inputs['vector' as PortId] as VectorDataValue,\n      k,\n    );\n\n    return {\n      ['results' as PortId]: results as DataValue,\n    };\n  }\n}\n\nexport const vectorNearestNeighborsNode = nodeDefinition(VectorNearestNeighborsNodeImpl, 'Vector KNN');\n"]},{"id":"GpYz6NsubMQkCysNgltXl","data":["EvaluateNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { match } from 'ts-pattern';\nimport { dedent } from 'ts-dedent';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type EvaluateNode = ChartNode<'evaluate', EvaluateNodeData>;\n\nexport type EvaluateNodeData = {\n  operation: '+' | '-' | '*' | '/' | '^' | '%' | 'abs' | 'negate';\n  useOperationInput?: boolean;\n};\n\nconst unaryOperation = ['abs', 'negate'] as const;\ntype Unary = (typeof unaryOperation)[number];\nconst isUnaryOp = (operation: string): operation is Unary => unaryOperation.includes(operation as Unary);\n\nexport class EvaluateNodeImpl extends NodeImpl<EvaluateNode> {\n  static create(): EvaluateNode {\n    const chartNode: EvaluateNode = {\n      type: 'evaluate',\n      title: 'Evaluate',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {\n        operation: '+',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        dataType: 'number',\n        id: 'a' as PortId,\n        title: 'A',\n      },\n    ];\n\n    const isUnary = !this.data.useOperationInput && isUnaryOp(this.data.operation);\n\n    if (!isUnary) {\n      inputs.push({\n        dataType: 'number',\n        id: 'b' as PortId,\n        title: 'B',\n      });\n    }\n\n    if (this.data.useOperationInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'operation' as PortId,\n        title: 'Operation',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'number',\n        id: 'output' as PortId,\n        title: 'Output',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<EvaluateNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Operation',\n        dataKey: 'operation',\n        options: [\n          { label: '+', value: '+' },\n          { label: '-', value: '-' },\n          { label: '*', value: '*' },\n          { label: '/', value: '/' },\n          { label: '^', value: '^' },\n          { label: '%', value: '%' },\n          { label: 'abs', value: 'abs' },\n          { label: 'negate', value: 'negate' },\n        ],\n        useInputToggleDataKey: 'useOperationInput',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    const isUnary = !this.data.useOperationInput && isUnaryOp(this.data.operation);\n\n    if (isUnary) {\n      return match(this.data.operation as Unary)\n        .with('abs', () => 'abs(A)')\n        .with('negate', () => '-A')\n        .exhaustive();\n    }\n\n    if (this.data.operation === '^') {\n      return '!markdownA<sup>B</sup>';\n    }\n\n    return this.data.useOperationInput ? 'A (Operation) B' : `A ${this.data.operation} B`;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Evaluates the configured mathematical operation on the input values and outputs the result.\n\n        For more complex operations, you should use the \\`Code\\` node.\n      `,\n      infoBoxTitle: 'Evaluate Node',\n      contextMenuTitle: 'Evaluate',\n      group: ['Numbers'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const operation = (\n      this.data.useOperationInput ? coerceType(inputs['operation' as PortId], 'string') : this.data.operation\n    ) as EvaluateNodeData['operation'];\n\n    const inputA = coerceTypeOptional(inputs['a' as PortId], 'number');\n    const inputB = coerceTypeOptional(inputs['b' as PortId], 'number');\n\n    if (isUnaryOp(operation) && inputA) {\n      return {\n        ['output' as PortId]: {\n          type: 'number',\n          value: match(operation as Extract<EvaluateNodeData['operation'], Unary>)\n            .with('abs', () => Math.abs(inputA))\n            .with('negate', () => -inputA)\n            .exhaustive(),\n        },\n      };\n    }\n\n    if (inputA == null || inputB == null) {\n      throw new Error('Missing input');\n    }\n\n    return {\n      ['output' as PortId]: {\n        type: 'number',\n        value: match(operation as Exclude<EvaluateNodeData['operation'], Unary>)\n          .with('+', () => inputA + inputB)\n          .with('-', () => inputA - inputB)\n          .with('*', () => inputA * inputB)\n          .with('/', () => inputA / inputB)\n          .with('^', () => Math.pow(inputA, inputB))\n          .with('%', () => inputA % inputB)\n          .exhaustive(),\n      },\n    };\n  }\n}\n\nexport const evaluateNode = nodeDefinition(EvaluateNodeImpl, 'Evaluate');\n"]},{"id":"BKsZ-M7ApUxIj5OqlE46B","data":["UserInputNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport type { ChartNode, NodeId, NodeInputDefinition, NodeOutputDefinition, PortId } from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { zip } from 'lodash-es';\nimport { type Outputs, type Inputs, type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\n\nexport type UserInputNode = ChartNode<'userInput', UserInputNodeData>;\n\nexport type UserInputNodeData = {\n  prompt: string;\n  useInput: boolean;\n\n  renderingFormat?: 'preformatted' | 'markdown';\n};\n\nexport class UserInputNodeImpl extends NodeImpl<UserInputNode> {\n  static create(): UserInputNode {\n    const chartNode: UserInputNode = {\n      type: 'userInput',\n      title: 'User Input',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        prompt: 'This is an example question?',\n        useInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    if (this.chartNode.data.useInput) {\n      return [\n        {\n          dataType: 'string[]',\n          id: 'questions' as PortId,\n          title: 'Questions',\n        },\n      ];\n    }\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'string[]',\n        id: 'output' as PortId,\n        title: 'Answers Only',\n      },\n      {\n        dataType: 'string[]',\n        id: 'questionsAndAnswers' as PortId,\n        title: 'Q & A',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<UserInputNode>[] {\n    return [\n      {\n        type: 'code',\n        label: 'Prompt',\n        dataKey: 'prompt',\n        useInputToggleDataKey: 'useInput',\n        language: 'plain-text',\n      },\n      {\n        type: 'group',\n        label: 'Rendering',\n        editors: [\n          {\n            type: 'dropdown',\n            dataKey: 'renderingFormat',\n            label: 'Format',\n            options: [\n              { label: 'Preformatted', value: 'preformatted' },\n              { label: 'Markdown', value: 'markdown' },\n            ],\n            defaultValue: 'markdown',\n          },\n        ],\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.useInput ? '(Using input)' : this.data.prompt;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Prompts the user for input during the execution of the graph. The user's response becomes the output of this node.\n      `,\n      infoBoxTitle: 'User Input Node',\n      contextMenuTitle: 'User Input',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const questions = this.data.useInput ? coerceType(inputs['questions' as PortId], 'string[]') : [this.data.prompt];\n\n    const renderingFormat = this.data.renderingFormat === 'preformatted' ? 'text' : 'markdown';\n\n    const response = await context.requestUserInput(questions, renderingFormat);\n\n    return {\n      ['output' as PortId]: {\n        type: 'string[]',\n        value: response.value,\n      },\n      ['questionsAndAnswers' as PortId]: {\n        type: 'string[]',\n        value: zip(questions, response.value).map(([q, a]) => `${q}\\n${a}`),\n      },\n    };\n  }\n}\n\nexport const userInputNode = nodeDefinition(UserInputNodeImpl, 'User Input');\n"]},{"id":"AACu0DpLZUqvlfpzCUufH","data":["DocumentNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport {\n  type DataRef,\n  type EditorDefinition,\n  type Inputs,\n  type InternalProcessContext,\n  type NodeBody,\n  type Outputs,\n  type SupportedDocumentMediaTypes,\n} from '../../index.js';\nimport { base64ToUint8Array, expectType } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { getInputOrData } from '../../utils/inputs.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport { dedent } from '../../utils/misc.js';\n\nexport type DocumentNode = ChartNode<'document', DocumentNodeData>;\n\ntype DocumentNodeData = {\n  data?: DataRef;\n  useDataInput: boolean;\n\n  mediaType?: SupportedDocumentMediaTypes;\n  useMediaTypeInput: boolean;\n\n  title: string;\n  useTitleInput: boolean;\n\n  context: string;\n  useContextInput: boolean;\n\n  enableCitations: boolean;\n  useEnableCitationsInput: boolean;\n};\n\nexport class DocumentNodeImpl extends NodeImpl<DocumentNode> {\n  static create(): DocumentNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'document',\n      title: 'Document',\n      visualData: { x: 0, y: 0, width: 300 },\n      data: {\n        useDataInput: false,\n        useMediaTypeInput: false,\n        title: '',\n        useTitleInput: false,\n        context: '',\n        useContextInput: false,\n        enableCitations: false,\n        useEnableCitationsInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useDataInput) {\n      inputDefinitions.push({\n        id: 'data' as PortId,\n        title: 'Data',\n        dataType: ['string', 'binary'],\n        coerced: false,\n        description: 'The document data. Either string or binary data loaded from a file.',\n      });\n    }\n\n    if (this.chartNode.data.useMediaTypeInput) {\n      inputDefinitions.push({\n        id: 'mediaType' as PortId,\n        title: 'Media Type',\n        dataType: 'string',\n        coerced: false,\n        description: 'The media type of the document, such as text/plain or application/pdf.',\n      });\n    }\n\n    if (this.data.useTitleInput) {\n      inputDefinitions.push({\n        id: 'title' as PortId,\n        title: 'Title',\n        dataType: 'string',\n        coerced: true,\n        description: 'The title of the document.',\n      });\n    }\n\n    if (this.data.useContextInput) {\n      inputDefinitions.push({\n        id: 'context' as PortId,\n        title: 'Context',\n        dataType: 'string',\n        coerced: true,\n        description: 'The context of the document.',\n      });\n    }\n\n    if (this.data.useEnableCitationsInput) {\n      inputDefinitions.push({\n        id: 'enableCitations' as PortId,\n        title: 'Enable Citations',\n        dataType: 'boolean',\n        coerced: true,\n        description: 'Whether to enable citations for the document.',\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: 'Document Data',\n        dataType: 'document',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<DocumentNode>[] {\n    return [\n      {\n        type: 'fileBrowser',\n        label: 'Document File',\n        dataKey: 'data',\n        mediaTypeDataKey: 'mediaType',\n        useInputToggleDataKey: 'useDataInput',\n        accept: '*/*',\n      },\n      {\n        type: 'string',\n        label: 'Media Type',\n        dataKey: 'mediaType',\n        useInputToggleDataKey: 'useMediaTypeInput',\n      },\n      {\n        type: 'string',\n        label: 'Title',\n        dataKey: 'title',\n        useInputToggleDataKey: 'useTitleInput',\n      },\n      {\n        type: 'string',\n        label: 'Context',\n        dataKey: 'context',\n        useInputToggleDataKey: 'useContextInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Enable Citations',\n        dataKey: 'enableCitations',\n        useInputToggleDataKey: 'useEnableCitationsInput',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      contextMenuTitle: 'Document',\n      group: 'Data',\n      infoBoxTitle: 'Document Node',\n      infoBoxBody:\n        'Defines a document for use with other nodes such as Assemble Message. Can accept text and PDF files.',\n    };\n  }\n\n  getBody(_context: RivetUIContext): NodeBody | Promise<NodeBody> {\n    const parts = [\n      this.data.useDataInput ? '(Data from input)' : '(Data stored in node)',\n      this.data.useMediaTypeInput\n        ? '(Media type from input)'\n        : this.data.mediaType\n          ? `(${this.data.mediaType.trim()})`\n          : undefined,\n      this.data.useTitleInput ? '(Title from input)' : this.data.title ? `Title: ${this.data.title}` : undefined,\n      this.data.useContextInput\n        ? '(Context from input)'\n        : this.data.context\n          ? `Context: ${this.data.context}`\n          : undefined,\n    ].filter((x) => x != null);\n\n    return dedent`\n      ${parts.join('\\n')}\n    `;\n  }\n\n  async process(inputData: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    let data: Uint8Array;\n\n    const mediaType = getInputOrData(this.data, inputData, 'mediaType', 'string') || 'text/plain';\n\n    const title = getInputOrData(this.data, inputData, 'title');\n    const contextInput = getInputOrData(this.data, inputData, 'context');\n    const enableCitations = getInputOrData(this.data, inputData, 'enableCitations', 'boolean');\n\n    if (this.chartNode.data.useDataInput) {\n      data = expectType(inputData['data' as PortId], 'binary');\n    } else {\n      const dataRef = this.data.data?.refId;\n      if (!dataRef) {\n        throw new Error('No data ref');\n      }\n\n      const encodedData = context.project.data?.[dataRef] as string;\n\n      if (!encodedData) {\n        throw new Error(`No data at ref ${dataRef}`);\n      }\n\n      data = base64ToUint8Array(encodedData);\n    }\n\n    return {\n      ['data' as PortId]: {\n        type: 'document',\n        value: {\n          data,\n          mediaType: mediaType as SupportedDocumentMediaTypes,\n          title,\n          context: contextInput,\n          enableCitations,\n        },\n      },\n    };\n  }\n}\n\nexport const documentNode = nodeDefinition(DocumentNodeImpl, 'Document');\n"]},{"id":"SUSXD3fe-eBD3JoQZctlO","data":["AssemblePromptNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { type ChatMessage, arrayizeDataValue, unwrapDataValue, type ChatMessageDataValue } from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { orderBy } from 'lodash-es';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport { getInputOrData } from '../../utils/inputs.js';\n\nexport type AssemblePromptNode = ChartNode<'assemblePrompt', AssemblePromptNodeData>;\n\nexport type AssemblePromptNodeData = {\n  computeTokenCount?: boolean;\n\n  isLastMessageCacheBreakpoint?: boolean;\n  useIsLastMessageCacheBreakpointInput?: boolean;\n};\n\nexport class AssemblePromptNodeImpl extends NodeImpl<AssemblePromptNode> {\n  static create(): AssemblePromptNode {\n    const chartNode: AssemblePromptNode = {\n      type: 'assemblePrompt',\n      title: 'Assemble Prompt',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const messageCount = this.#getMessagePortCount(connections);\n\n    if (this.data.useIsLastMessageCacheBreakpointInput) {\n      inputs.push({\n        dataType: 'boolean',\n        id: 'isLastMessageCacheBreakpoint' as PortId,\n        title: 'Is Last Message Cache Breakpoint',\n        description: 'Whether the last message in the prompt should be a cache breakpoint.',\n      });\n    }\n\n    for (let i = 1; i <= messageCount; i++) {\n      inputs.push({\n        dataType: ['chat-message', 'chat-message[]'] as const,\n        id: `message${i}` as PortId,\n        title: `Message ${i}`,\n        description: 'A message, or messages, to include in the full prompt.',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        dataType: 'chat-message[]',\n        id: 'prompt' as PortId,\n        title: 'Prompt',\n        description: 'The assembled prompt, a list of chat messages.',\n      },\n    ];\n\n    if (this.data.computeTokenCount) {\n      outputs.push({\n        dataType: 'number',\n        id: 'tokenCount' as PortId,\n        title: 'Token Count',\n        description: 'The number of tokens in the full output prompt.',\n      });\n    }\n\n    return outputs;\n  }\n\n  #getMessagePortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const messageConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('message'),\n    );\n\n    let maxMessageNumber = 0;\n    for (const connection of messageConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('message', ''));\n      if (messageNumber > maxMessageNumber) {\n        maxMessageNumber = messageNumber;\n      }\n    }\n\n    return maxMessageNumber + 1;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Assembles an array of chat messages for use with a Chat node. The inputs can be strings or chat messages.\n\n        The number of inputs is dynamic based on the number of connections.\n\n        Strings are converted to User type chat messages.\n      `,\n      infoBoxTitle: 'Assemble Prompt Node',\n      contextMenuTitle: 'Assemble Prompt',\n      group: ['AI'],\n    };\n  }\n\n  getEditors(_context: RivetUIContext): EditorDefinition<AssemblePromptNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: 'Compute Token Count',\n        dataKey: 'computeTokenCount',\n      },\n      {\n        type: 'toggle',\n        label: 'Is Last Message Cache Breakpoint',\n        dataKey: 'isLastMessageCacheBreakpoint',\n        helperMessage:\n          'For Anthropic, marks the last message as a cache breakpoint - this message and every message before it will be cached using Prompt Caching.',\n      },\n    ];\n  }\n\n  getBody(_context: RivetUIContext): NodeBody | Promise<NodeBody> {\n    return this.data.isLastMessageCacheBreakpoint ? 'Last message is cache breakpoint' : '';\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const output: Outputs = {};\n\n    const isLastMessageCacheBreakpoint = getInputOrData(this.data, inputs, 'isLastMessageCacheBreakpoint', 'boolean');\n\n    const outMessages: ChatMessage[] = [];\n\n    const inputMessages = orderBy(\n      Object.entries(inputs).filter(([key]) => key.startsWith('message')),\n      ([key]) => key,\n      'asc',\n    );\n\n    for (const [, inputMessage] of inputMessages) {\n      if (!inputMessage || inputMessage.type === 'control-flow-excluded' || !inputMessage.value) {\n        continue;\n      }\n\n      const inMessages = arrayizeDataValue(unwrapDataValue(inputMessage));\n      for (const message of inMessages) {\n        if (message.type === 'chat-message') {\n          outMessages.push(message.value);\n        } else {\n          const coerced = coerceType(message, 'chat-message');\n\n          if (coerced) {\n            outMessages.push(coerced);\n          }\n        }\n      }\n    }\n\n    if (isLastMessageCacheBreakpoint && outMessages.length > 1) {\n      outMessages.at(-1)!.isCacheBreakpoint = true;\n    }\n\n    output['prompt' as PortId] = {\n      type: 'chat-message[]',\n      value: outMessages,\n    };\n\n    if (this.data.computeTokenCount) {\n      const tokenCount = await context.tokenizer.getTokenCountForMessages(outMessages, undefined, {\n        node: this.chartNode,\n      });\n      output['tokenCount' as PortId] = {\n        type: 'number',\n        value: tokenCount,\n      };\n    }\n\n    return output;\n  }\n}\n\nexport const assemblePromptNode = nodeDefinition(AssemblePromptNodeImpl, 'Assemble Prompt');\n"]},{"id":"y_BTyu-P7rTUtgjV-qg5m","data":["ToMarkdownTableNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { toMarkdown } from 'mdast-util-to-markdown';\nimport { gfmTableToMarkdown } from 'mdast-util-gfm-table';\n\nexport type ToMarkdownTableNode = ChartNode<'toMarkdownTable', ToMarkdownTableNodeData>;\n\nexport type ToMarkdownTableNodeData = {\n  includeHeaders?: boolean;\n  alignPipes?: boolean;\n};\n\nexport class ToMarkdownTableNodeImpl extends NodeImpl<ToMarkdownTableNode> {\n  static create(): ToMarkdownTableNode {\n    const chartNode: ToMarkdownTableNode = {\n      type: 'toMarkdownTable',\n      title: 'To Markdown Table',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        includeHeaders: true,\n        alignPipes: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: 'Data Array',\n        dataType: 'any',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'markdown' as PortId,\n        title: 'Markdown Table',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ToMarkdownTableNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: 'Include Headers',\n        dataKey: 'includeHeaders',\n      },\n      {\n        type: 'toggle',\n        label: 'Align Pipes',\n        dataKey: 'alignPipes',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    const parts = [];\n    if (this.data.includeHeaders) parts.push('With Header Row');\n    if (this.data.alignPipes) parts.push('Pipes Aligned');\n    return parts.length > 0 ? parts.join(', ') : undefined;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Converts an array of objects into a markdown table format.\n        Input should be an array of objects with consistent keys.\n      `,\n      infoBoxTitle: 'To Markdown Table Node',\n      contextMenuTitle: 'To Markdown Table',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const data = coerceType(inputs['data' as PortId], 'object[]');\n\n    const keys = data.length === 0 ? [] : Object.keys(data[0]!);\n\n    const markdownTable = toMarkdown(\n      {\n        type: 'table',\n        children: [\n          ...(this.data.includeHeaders\n            ? [\n                {\n                  type: 'tableRow' as const,\n                  children: keys.map((key) => ({\n                    type: 'tableCell' as const,\n                    children: [{ type: 'text' as const, value: key }],\n                  })),\n                },\n              ]\n            : []),\n          ...data.map((row) => ({\n            type: 'tableRow' as const,\n            children: keys.map((key) => ({\n              type: 'tableCell' as const,\n              children: [{ type: 'text' as const, value: `${row[key]}` }],\n            })),\n          })),\n        ],\n      },\n      {\n        extensions: [gfmTableToMarkdown({ tablePipeAlign: this.data.alignPipes })],\n      },\n    );\n\n    return {\n      ['markdown' as PortId]: {\n        type: 'string',\n        value: markdownTable,\n      },\n    };\n  }\n}\n\nexport const toMarkdownTableNode = nodeDefinition(ToMarkdownTableNodeImpl, 'To Markdown Table');\n"]},{"id":"mca3MiFpj5GgDZJv60S0_","data":["GetDatasetRowNode.ts","import type {\n  ChartNode,\n  DatasetId,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n  EditorDefinition,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { dedent, getInputOrData, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type GetDatasetRowNode = ChartNode<'getDatasetRow', GetDatasetRowNodeData>;\n\ntype GetDatasetRowNodeData = {\n  datasetId: DatasetId;\n  useDatasetIdInput?: boolean;\n\n  rowId: string;\n  useRowIdInput?: boolean;\n};\n\nexport class GetDatasetRowNodeImpl extends NodeImpl<GetDatasetRowNode> {\n  static create(): GetDatasetRowNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'getDatasetRow',\n      title: 'Get Dataset Row',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        datasetId: '' as DatasetId,\n        rowId: '',\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useRowIdInput) {\n      inputs.push({\n        id: 'rowId' as PortId,\n        title: 'Row ID',\n        dataType: 'string',\n      });\n    }\n\n    if (this.data.useDatasetIdInput) {\n      inputs.push({\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'row' as PortId,\n        title: 'Row',\n        dataType: 'object',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Gets a row from a dataset with the provided ID. If the dataset or row does not exist, it throws an error.\n      `,\n      infoBoxTitle: 'Get Dataset Row Node',\n      contextMenuTitle: 'Get Dataset Row',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<GetDatasetRowNode>[] | Promise<EditorDefinition<GetDatasetRowNode>[]> {\n    return [\n      {\n        type: 'datasetSelector',\n        label: 'Dataset',\n        dataKey: 'datasetId',\n        useInputToggleDataKey: 'useDatasetIdInput',\n      },\n      {\n        type: 'string',\n        label: 'Row ID',\n        dataKey: 'rowId',\n        useInputToggleDataKey: 'useRowIdInput',\n      },\n    ];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId = getInputOrData(this.data, inputs, 'datasetId', 'string') as DatasetId;\n    const rowId = getInputOrData(this.data, inputs, 'rowId', 'string') as string;\n\n    const dataset = await datasetProvider.getDatasetData(datasetId as DatasetId);\n\n    if (!dataset) {\n      throw new Error(`Dataset with ID ${datasetId} does not exist`);\n    }\n\n    // TODO be more efficient\n    const row = dataset.rows.find((r) => r.id === rowId);\n\n    if (!row) {\n      return {\n        ['row' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['row' as PortId]: {\n        type: 'object',\n        value: row,\n      },\n    };\n  }\n}\n\nexport const getDatasetRowNode = nodeDefinition(GetDatasetRowNodeImpl, 'Get Dataset Row');\n"]},{"id":"zLdjRmF0FrWMqs_428Vpf","data":["ToJsonNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type ToJsonNode = ChartNode<'toJson', ToJsonNodeData>;\n\nexport type ToJsonNodeData = {\n  indented?: boolean;\n};\n\nexport class ToJsonNodeImpl extends NodeImpl<ToJsonNode> {\n  static create(): ToJsonNode {\n    const chartNode: ToJsonNode = {\n      type: 'toJson',\n      title: 'To JSON',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {\n        indented: true,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: 'Data',\n        dataType: 'any',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'json' as PortId,\n        title: 'JSON',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ToJsonNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: 'Indented',\n        dataKey: 'indented',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return this.data.indented ? 'Indented' : 'Not indented';\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Turns the input value into its JSON equivalent (stringifies the value).\n      `,\n      infoBoxTitle: 'To JSON Node',\n      contextMenuTitle: 'To JSON',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const data = coerceType(inputs['data' as PortId], 'any');\n\n    const toJson = this.data.indented ? JSON.stringify(data, null, 2) : JSON.stringify(data);\n\n    return {\n      ['json' as PortId]: {\n        type: 'string',\n        value: toJson,\n      },\n    };\n  }\n}\n\nexport const toJsonNode = nodeDefinition(ToJsonNodeImpl, 'To JSON');\n"]},{"id":"IUmqy63BnmY3o80VEz7n9","data":["WaitForEventNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type WaitForEventNode = ChartNode<'waitForEvent', WaitForEventNodeData>;\n\nexport type WaitForEventNodeData = {\n  eventName: string;\n  useEventNameInput: boolean;\n};\n\nexport class WaitForEventNodeImpl extends NodeImpl<WaitForEventNode> {\n  static create(): WaitForEventNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'waitForEvent',\n      title: 'Wait For Event',\n      visualData: { x: 0, y: 0, width: 150 },\n      data: {\n        eventName: 'continue',\n        useEventNameInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useEventNameInput) {\n      inputDefinitions.push({\n        id: 'eventName' as PortId,\n        title: 'Event Name',\n        dataType: 'string',\n      });\n    }\n\n    inputDefinitions.push({\n      id: 'inputData' as PortId,\n      title: 'Data',\n      dataType: 'any',\n    });\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'outputData' as PortId,\n        title: 'Data',\n        dataType: 'any',\n      },\n      {\n        id: 'eventData' as PortId,\n        title: 'Event Data',\n        dataType: 'any',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<WaitForEventNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Event Name',\n        dataKey: 'eventName',\n        useInputToggleDataKey: 'useEventNameInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.useEventNameInput ? '(Using Input)' : this.data.eventName;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Waits for a specific event to be raised by a 'Raise Event' node or the host project. The event name can be configured.\n      `,\n      infoBoxTitle: 'Wait For Event Node',\n      contextMenuTitle: 'Wait For Event',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const eventName = this.chartNode.data.useEventNameInput\n      ? coerceType(inputs['eventName' as PortId], 'string')\n      : this.chartNode.data.eventName;\n\n    const eventData = await context.waitEvent(eventName);\n\n    return {\n      ['outputData' as PortId]: inputs['inputData' as PortId],\n      ['eventData' as PortId]: eventData,\n    };\n  }\n}\n\nexport const waitForEventNode = nodeDefinition(WaitForEventNodeImpl, 'Wait For Event');\n"]},{"id":"lmg4as9Tc3UqKerR4Ff0t","data":["CronNode.ts","import { nanoid } from 'nanoid';\nimport type { DataValue } from '../DataValue.js';\nimport type { ChartNode, NodeId, NodeInputDefinition, NodeOutputDefinition, PortId } from '../NodeBase.js';\nimport type { GraphId } from '../NodeGraph.js';\nimport { NodeImpl, type NodeBody } from '../NodeImpl.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\nimport * as cronParser from 'cron-parser';\n\ntype TimeUnit = 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks';\ntype ScheduleType = 'interval' | 'cron';\n\ninterface IntervalSchedule {\n  type: 'interval';\n  value: number;\n  unit: TimeUnit;\n}\n\ninterface CronSchedule {\n  type: 'cron';\n  expression: string;\n}\n\ntype Schedule = IntervalSchedule | CronSchedule;\n\nexport type CronNode = ChartNode<'cron', CronNodeData>;\n\nexport type CronNodeData = {\n  targetGraph: GraphId | undefined;\n  scheduleType: ScheduleType;\n  schedule: string;\n  executeImmediately?: boolean;\n\n  useTargetGraphInput?: boolean;\n};\n\nexport class CronNodeImpl extends NodeImpl<CronNode> {\n  static create(): CronNode {\n    const chartNode: CronNode = {\n      type: 'cron',\n      title: 'Cron',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        targetGraph: undefined,\n        scheduleType: 'interval',\n        schedule: '5 minutes',\n        executeImmediately: true,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    inputs.push({\n      id: 'trigger' as PortId,\n      title: 'Trigger',\n      dataType: 'boolean',\n      description: 'Starts the scheduled job when true.',\n    });\n\n    if (this.data.useTargetGraphInput) {\n      inputs.push({\n        id: 'targetGraph' as PortId,\n        title: 'Target Graph',\n        dataType: 'string',\n        description: 'The subgraph to execute on schedule',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'Last Output',\n        dataType: 'any',\n        description: 'The last output from the subgraph execution.',\n      },\n      {\n        id: 'iteration' as PortId,\n        title: 'Iteration',\n        dataType: 'number',\n        description: 'The current iteration number.',\n      },\n      {\n        id: 'completed' as PortId,\n        title: 'Completed',\n        dataType: 'boolean',\n        description: 'True when the job has completed.',\n      },\n      {\n        id: 'nextRun' as PortId,\n        title: 'Next Run',\n        dataType: 'string',\n        description: 'The scheduled time for the next execution.',\n      },\n    ];\n  }\n\n  static getUIData() {\n    return {\n      infoBoxBody: dedent`\n        Executes a subgraph on a schedule. Supports:\n        - Natural language (e.g., \"every 5 minutes\", \"daily at 3pm\")\n        - Cron expressions (e.g., \"0 * * * *\")\n        - Simple intervals (e.g., \"5 minutes\", \"1 hour\")\n      `,\n      infoBoxTitle: 'Cron Node',\n      contextMenuTitle: 'Cron',\n      group: ['Advanced'],\n    };\n  }\n\n  getEditors(): EditorDefinition<CronNode>[] {\n    return [\n      {\n        type: 'toggle',\n        dataKey: 'executeImmediately',\n        label: 'Execute Immediately',\n        helperMessage: 'Starts the job immediately when the node is run, in addition to the schedule',\n      },\n      {\n        type: 'graphSelector',\n        dataKey: 'targetGraph',\n        useInputToggleDataKey: 'useTargetGraphInput',\n        label: 'Target Graph',\n        helperMessage: 'The subgraph to execute on schedule',\n      },\n      {\n        type: 'dropdown',\n        dataKey: 'scheduleType',\n        label: 'Schedule Type',\n        options: [\n          { label: 'Cron Expression', value: 'cron' },\n          { label: 'Simple Interval', value: 'interval' },\n        ],\n        helperMessage: 'How to specify the schedule',\n      },\n      {\n        type: 'string',\n        dataKey: 'schedule',\n        label: 'Schedule',\n        helperMessage: dedent`\n          Examples:\n          Cron: \"*/5 * * * *\", \"0 15 * * *\"\n          Interval: \"5 minutes\", \"1 hour\", \"7 days\"\n        `,\n      },\n    ];\n  }\n\n  private parseSchedule(): Schedule {\n    const { scheduleType, schedule } = this.data;\n\n    if (scheduleType === 'cron') {\n      return { type: 'cron', expression: schedule };\n    }\n\n    // Parse interval\n    const match = schedule.match(/^(\\d+)\\s*(second|seconds|minute|minutes|hour|hours|day|days|week|weeks)$/i);\n    if (!match) {\n      throw new Error('Invalid interval format. Expected: \"number unit\" (e.g., \"5 minutes\")');\n    }\n\n    const value = parseInt(match[1]!, 10);\n    let unit = match[2]!.toLowerCase() as TimeUnit;\n\n    // Normalize unit to plural\n    if (unit.endsWith('s')) {\n      unit = unit as TimeUnit;\n    } else {\n      unit = `${unit}s` as TimeUnit;\n    }\n\n    return { type: 'interval', value, unit };\n  }\n\n  private getNextRunTime(schedule: Schedule): Date {\n    const now = new Date();\n\n    if (schedule.type === 'interval') {\n      const { value, unit } = schedule;\n      const next = new Date(now);\n\n      switch (unit) {\n        case 'seconds':\n          next.setSeconds(now.getSeconds() + value);\n          break;\n        case 'minutes':\n          next.setMinutes(now.getMinutes() + value);\n          break;\n        case 'hours':\n          next.setHours(now.getHours() + value);\n          break;\n        case 'days':\n          next.setDate(now.getDate() + value);\n          break;\n        case 'weeks':\n          next.setDate(now.getDate() + value * 7);\n          break;\n      }\n\n      return next;\n    }\n\n    if (schedule.type === 'cron') {\n      const cron = cronParser.parseExpression(schedule.expression, { currentDate: now });\n\n      const next = cron.next().toDate();\n      return next;\n    }\n\n    throw new Error('Invalid schedule type');\n  }\n\n  getBody(context: RivetUIContext): NodeBody {\n    if (!this.data.targetGraph && !this.data.useTargetGraphInput) {\n      return 'No target graph selected';\n    }\n\n    const graphName = this.data.useTargetGraphInput\n      ? 'graph from input'\n      : context.project.graphs[this.data.targetGraph!]?.metadata?.name ?? 'Unknown Graph';\n    return `Executes ${graphName}\\n${this.data.schedule}`;\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    if (inputs['trigger' as PortId] !== undefined) {\n      const trigger = coerceTypeOptional(inputs['trigger' as PortId], 'boolean');\n\n      if (!trigger) {\n        return {\n          ['completed' as PortId]: { type: 'boolean', value: false },\n          ['iteration' as PortId]: { type: 'number', value: 0 },\n        };\n      }\n    }\n\n    if (!this.data.targetGraph) {\n      throw new Error('No target graph selected');\n    }\n\n    let iteration = 0;\n    const schedule = this.parseSchedule();\n\n    let lastOutputs: Outputs = {};\n\n    let didExecuteFirstTime = !this.data.executeImmediately;\n\n    while (!context.signal.aborted) {\n      const nextRun = didExecuteFirstTime ? this.getNextRunTime(schedule) : new Date();\n      const delay = nextRun.getTime() - Date.now();\n\n      didExecuteFirstTime = true;\n\n      // Emit the next run time\n      const outputs: Outputs = {\n        ['output' as PortId]: lastOutputs\n          ? { type: 'object', value: lastOutputs as Record<string, unknown> }\n          : {\n              type: 'any',\n              value: null,\n            },\n        ['iteration' as PortId]: { type: 'number', value: iteration },\n        ['completed' as PortId]: { type: 'boolean', value: false },\n        ['nextRun' as PortId]: { type: 'string', value: nextRun.toISOString() },\n      };\n\n      if (delay > 0) {\n        await new Promise((resolve) => {\n          context.signal.addEventListener('abort', resolve, { once: true });\n\n          setTimeout(resolve, delay);\n        });\n      }\n\n      if (context.signal.aborted) {\n        throw new Error('Aborted');\n      }\n\n      iteration++;\n\n      const subprocessor = context.createSubProcessor(this.data.targetGraph, { signal: context.signal });\n      lastOutputs = await subprocessor.processGraph(\n        context,\n        lastOutputs as Record<string, DataValue>,\n        context.contextValues,\n      );\n\n      // Check for break signal\n      const breakSignal = coerceTypeOptional(lastOutputs['break' as PortId], 'boolean');\n      if (breakSignal === true) {\n        return {\n          ...outputs,\n          ['completed' as PortId]: { type: 'boolean', value: true },\n        };\n      }\n    }\n\n    return {\n      ['output' as PortId]: lastOutputs\n        ? { type: 'object', value: lastOutputs as Record<string, unknown> }\n        : { type: 'any', value: null },\n      ['iteration' as PortId]: { type: 'number', value: iteration },\n      ['completed' as PortId]: { type: 'boolean', value: true },\n      ['nextRun' as PortId]: { type: 'string', value: new Date().toISOString() },\n    };\n  }\n}\n\nexport const cronNode = nodeDefinition(CronNodeImpl, 'Cron');\n"]},{"id":"NGejhK3dOT6uq9vHXV67m","data":["AudioNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport {\n  type DataRef,\n  type EditorDefinition,\n  type Inputs,\n  type InternalProcessContext,\n  type Outputs,\n} from '../../index.js';\nimport { base64ToUint8Array, expectType } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { getInputOrData } from '../../utils/inputs.js';\n\nexport type AudioNode = ChartNode<'audio', AudioNodeData>;\n\ntype AudioNodeData = {\n  data?: DataRef;\n  useDataInput: boolean;\n\n  mediaType?: 'audio/wav' | 'audio/mp3' | 'audio/ogg';\n  useMediaTypeInput: boolean;\n};\n\nexport class AudioNodeImpl extends NodeImpl<AudioNode> {\n  static create(): AudioNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'audio',\n      title: 'Audio',\n      visualData: { x: 0, y: 0, width: 300 },\n      data: {\n        useDataInput: false,\n        useMediaTypeInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useDataInput) {\n      inputDefinitions.push({\n        id: 'data' as PortId,\n        title: 'Data',\n        dataType: 'string',\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useMediaTypeInput) {\n      inputDefinitions.push({\n        id: 'mediaType' as PortId,\n        title: 'Media Type',\n        dataType: 'string',\n        coerced: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'data' as PortId,\n        title: 'Audio Data',\n        dataType: 'audio',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<AudioNode>[] {\n    return [\n      {\n        type: 'fileBrowser',\n        label: 'Audio File',\n        dataKey: 'data',\n        mediaTypeDataKey: 'mediaType',\n        useInputToggleDataKey: 'useDataInput',\n        accept: 'audio/*',\n      },\n      {\n        type: 'string',\n        label: 'Media Type',\n        dataKey: 'mediaType',\n        useInputToggleDataKey: 'useMediaTypeInput',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      contextMenuTitle: 'Audio',\n      group: 'Data',\n      infoBoxTitle: 'Audio Node',\n      infoBoxBody: 'Defines an audio sample for use with other nodes. Can convert a binary type into an audio type.',\n    };\n  }\n\n  async process(inputData: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    let data: Uint8Array;\n\n    const mediaType = getInputOrData(this.data, inputData, 'mediaType', 'string') || 'audio/wav';\n\n    if (this.chartNode.data.useDataInput) {\n      data = expectType(inputData['data' as PortId], 'binary');\n    } else {\n      const dataRef = this.data.data?.refId;\n      if (!dataRef) {\n        throw new Error('No data ref');\n      }\n\n      const encodedData = context.project.data?.[dataRef] as string;\n\n      if (!encodedData) {\n        throw new Error(`No data at ref ${dataRef}`);\n      }\n\n      data = base64ToUint8Array(encodedData);\n    }\n\n    return {\n      ['data' as PortId]: {\n        type: 'audio',\n        value: { data, mediaType },\n      },\n    };\n  }\n}\n\nexport const audioNode = nodeDefinition(AudioNodeImpl, 'Audio');\n"]},{"id":"fgpcbes3kycXjdQJ_TAXm","data":["GetAllDatasetsNode.ts","import type {\n  ChartNode,\n  EditorDefinition,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { dedent, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type GetAllDatasetsNode = ChartNode<'getAllDatasets', GetAllDatasetsNodeData>;\n\ntype GetAllDatasetsNodeData = {};\n\nexport class GetAllDatasetsNodeImpl extends NodeImpl<GetAllDatasetsNode> {\n  static create(): GetAllDatasetsNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'getAllDatasets',\n      title: 'Get All Datasets',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {},\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'datasets' as PortId,\n        title: 'Datasets',\n        dataType: 'object[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Retrieves all datasets. If no datasets exist, it returns an empty array.\n      `,\n      infoBoxTitle: 'Get All Datasets Node',\n      contextMenuTitle: 'Get All Datasets',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<GetAllDatasetsNode>[] | Promise<EditorDefinition<GetAllDatasetsNode>[]> {\n    return [];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasets = await datasetProvider.getDatasetsForProject(context.project.metadata.id);\n\n    return {\n      ['datasets' as PortId]: {\n        type: 'object[]',\n        value: datasets,\n      },\n    };\n  }\n}\n\nexport const getAllDatasetsNode = nodeDefinition(GetAllDatasetsNodeImpl, 'Get All Datasets');\n"]},{"id":"wzcITMGtN83NAIjEDZ6e9","data":["LoopUntilNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type GraphId } from '../NodeGraph.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Project } from '../Project.js';\nimport { type GraphInputNode } from './GraphInputNode.js';\nimport { type GraphOutputNode } from './GraphOutputNode.js';\nimport { type DataValue } from '../DataValue.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { dedent } from 'ts-dedent';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\ntype ConditionType = 'allOutputsSet' | 'inputEqual';\n\nexport type LoopUntilNode = ChartNode<'loopUntil', LoopUntilNodeData>;\n\nexport type LoopUntilNodeData = {\n  targetGraph: GraphId | undefined;\n  conditionType: ConditionType;\n  maxIterations?: number;\n\n  // For inputEqual condition\n  inputToCheck?: string;\n  targetValue?: string;\n\n  /** Data for each of the inputs of the subgraph */\n  inputData?: Record<string, DataValue>;\n};\n\nexport class LoopUntilNodeImpl extends NodeImpl<LoopUntilNode> {\n  static create(): LoopUntilNode {\n    const chartNode: LoopUntilNode = {\n      type: 'loopUntil',\n      title: 'Loop Until',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        targetGraph: undefined,\n        conditionType: 'allOutputsSet',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(\n    _connections: NodeConnection[],\n    _nodes: Record<NodeId, ChartNode>,\n    project: Project,\n  ): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    // Get inputs from the target graph\n    const graph = project.graphs[this.data.targetGraph ?? ('' as GraphId)];\n    if (graph) {\n      const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput') as GraphInputNode[];\n      const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();\n\n      inputIds.forEach((id) => {\n        const inputNode = inputNodes.find((node) => node.data.id === id)!;\n        inputs.push({\n          id: id as PortId,\n          title: id,\n          dataType: inputNode.data.dataType,\n        });\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(\n    _connections: NodeConnection[],\n    _nodes: Record<NodeId, ChartNode>,\n    project: Project,\n  ): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n\n    // Get outputs from the target graph\n    const graph = project.graphs[this.data.targetGraph ?? ('' as GraphId)];\n    if (graph) {\n      const outputNodes = graph.nodes.filter((node) => node.type === 'graphOutput') as GraphOutputNode[];\n      const outputIds = [...new Set(outputNodes.map((node) => node.data.id))].sort();\n\n      outputIds.forEach((id) => {\n        const outputNode = outputNodes.find((node) => node.data.id === id)!;\n        outputs.push({\n          id: id as PortId,\n          title: id,\n          dataType: outputNode.data.dataType,\n        });\n      });\n    }\n\n    // Add standard loop outputs\n    outputs.push(\n      {\n        id: 'iteration' as PortId,\n        title: 'Iterations',\n        dataType: 'number',\n        description: 'The number of iterations completed.',\n      },\n      {\n        id: 'completed' as PortId,\n        title: 'Completed',\n        dataType: 'boolean',\n        description: 'True when the loop has completed.',\n      },\n    );\n\n    return outputs;\n  }\n\n  getEditors(context: RivetUIContext): EditorDefinition<LoopUntilNode>[] {\n    const definitions: EditorDefinition<LoopUntilNode>[] = [\n      {\n        type: 'graphSelector',\n        label: 'Target Graph',\n        dataKey: 'targetGraph',\n      },\n      {\n        type: 'dropdown',\n        dataKey: 'conditionType',\n        label: 'Stop Condition',\n        options: [\n          { label: 'All Outputs Set', value: 'allOutputsSet' },\n          { label: 'Input Equals Value', value: 'inputEqual' },\n        ],\n        helperMessage: 'The condition that will stop the loop',\n      },\n      {\n        type: 'number',\n        dataKey: 'maxIterations',\n        label: 'Max Iterations',\n        helperMessage: 'Maximum number of iterations (optional, leave empty for unlimited)',\n        allowEmpty: true,\n      },\n    ];\n\n    if (this.data.conditionType === 'inputEqual') {\n      definitions.push(\n        {\n          type: 'string',\n          dataKey: 'inputToCheck',\n          label: 'Input to Check',\n          helperMessage: 'The name of the input to compare',\n        },\n        {\n          type: 'string',\n          dataKey: 'targetValue',\n          label: 'Target Value',\n          helperMessage: 'The value to compare against',\n        },\n      );\n    }\n\n    // Add dynamic editors for graph inputs\n    if (this.data.targetGraph) {\n      const graph = context.project.graphs[this.data.targetGraph];\n      if (graph) {\n        const inputNodes = graph.nodes.filter((node) => node.type === 'graphInput') as GraphInputNode[];\n        const inputIds = [...new Set(inputNodes.map((node) => node.data.id))].sort();\n\n        for (const inputId of inputIds) {\n          const inputNode = inputNodes.find((node) => node.data.id === inputId)!;\n          definitions.push({\n            type: 'dynamic',\n            dataKey: 'inputData',\n            dynamicDataKey: inputNode.data.id,\n            dataType: inputNode.data.dataType,\n            label: inputNode.data.id,\n            editor: inputNode.data.editor ?? 'auto',\n          });\n        }\n      }\n    }\n\n    return definitions;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Executes a subgraph in a loop until a condition is met. Each iteration's outputs become\n        the inputs for the next iteration. Supports different stopping conditions and optional\n        maximum iterations.\n      `,\n      infoBoxTitle: 'Loop Until Node',\n      contextMenuTitle: 'Loop Until',\n      group: ['Logic'],\n    };\n  }\n\n  getBody(context: RivetUIContext): string {\n    if (!this.data.targetGraph) {\n      return 'No target graph selected';\n    }\n\n    const graphName = context.project.graphs[this.data.targetGraph]?.metadata?.name ?? 'Unknown Graph';\n    const condition =\n      this.data.conditionType === 'allOutputsSet'\n        ? 'all outputs are set'\n        : `${this.data.inputToCheck} equals ${this.data.targetValue}`;\n\n    const maxIterations = this.data.maxIterations ? `\\nMax iterations: ${this.data.maxIterations}` : '';\n\n    return `Executes ${graphName}\\nuntil ${condition}${maxIterations}`;\n  }\n\n  private checkCondition(outputs: Outputs): boolean {\n    if (this.data.conditionType === 'allOutputsSet') {\n      // Check if any output is control-flow-excluded\n      const anyInputIsExcluded = Object.values(outputs)\n        .filter((o) => o != null)\n        .some((output) => output.type === 'control-flow-excluded');\n      return anyInputIsExcluded;\n    } else if (this.data.conditionType === 'inputEqual' && this.data.inputToCheck && this.data.targetValue) {\n      const inputValue = outputs[this.data.inputToCheck as PortId];\n      return inputValue?.value?.toString() === this.data.targetValue;\n    }\n\n    return false;\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    if (!this.data.targetGraph) {\n      throw new Error('No target graph selected');\n    }\n\n    let iteration = 0;\n    let currentInputs = { ...inputs };\n\n    // Add any default values from inputData\n    if (this.data.inputData) {\n      Object.entries(this.data.inputData).forEach(([key, value]) => {\n        if (currentInputs[key as PortId] === undefined) {\n          currentInputs[key as PortId] = value;\n        }\n      });\n    }\n\n    let lastOutputs: Outputs = {};\n\n    while (!context.signal.aborted) {\n      // Check max iterations if set\n      if (this.data.maxIterations && iteration >= this.data.maxIterations) {\n        break;\n      }\n\n      const subprocessor = context.createSubProcessor(this.data.targetGraph, { signal: context.signal });\n      lastOutputs = await subprocessor.processGraph(\n        context,\n        currentInputs as Record<string, DataValue>,\n        context.contextValues,\n      );\n\n      iteration++;\n\n      // Check if the condition is met\n      if (this.checkCondition(lastOutputs)) {\n        break;\n      }\n\n      context.onPartialOutputs?.(lastOutputs);\n\n      // Use outputs as inputs for next iteration\n      currentInputs = lastOutputs;\n    }\n\n    return {\n      ...lastOutputs,\n      ['iteration' as PortId]: { type: 'number', value: iteration },\n      ['completed' as PortId]: { type: 'boolean', value: true },\n    };\n  }\n}\n\nexport const loopUntilNode = nodeDefinition(LoopUntilNodeImpl, 'Loop Until');\n"]},{"id":"5CEWsu3YyKe2h8M_c1abm","data":["GetEmbeddingNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { getIntegration } from '../../integrations/integrations.js';\n\nexport type GetEmbeddingNode = ChartNode<'getEmbedding', GetEmbeddingNodeData>;\n\nexport type GetEmbeddingNodeData = {\n  integration: string;\n  model?: string;\n  dimensions?: number;\n  useIntegrationInput?: boolean;\n  useModelInput?: boolean;\n  useDimensionsInput?: boolean;\n};\n\nexport class GetEmbeddingNodeImpl extends NodeImpl<GetEmbeddingNode> {\n  static create(): GetEmbeddingNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'getEmbedding',\n      title: 'Get Embedding',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        integration: 'openai',\n        useIntegrationInput: false,\n        model: undefined,\n        dimensions: undefined,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'input' as PortId,\n      title: 'Input',\n      dataType: 'string',\n      required: true,\n    });\n\n    if (this.data.useIntegrationInput) {\n      inputDefinitions.push({\n        id: 'integration' as PortId,\n        title: 'Integration',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    if (this.data.useModelInput) {\n      inputDefinitions.push({\n        id: 'model' as PortId,\n        title: 'Model',\n        dataType: 'string',\n        required: false,\n      });\n    }\n\n    if (this.data.useDimensionsInput) {\n      inputDefinitions.push({\n        id: 'dimensions' as PortId,\n        title: 'Dimensions',\n        dataType: 'number',\n        required: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'embedding' as PortId,\n        title: 'Embedding',\n        dataType: 'vector',\n      },\n    ];\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<GetEmbeddingNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Integration',\n        dataKey: 'integration',\n        options: [{ label: 'OpenAI', value: 'openai' }],\n        useInputToggleDataKey: 'useIntegrationInput',\n      },\n      {\n        type: 'string',\n        label: 'Model',\n        dataKey: 'model',\n        useInputToggleDataKey: 'useModelInput',\n      },\n      {\n        type: 'number',\n        label: 'Dimensions',\n        dataKey: 'dimensions',\n        useInputToggleDataKey: 'useDimensionsInput',\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return `Using ${this.data.useIntegrationInput ? '(input)' : this.data.integration}`;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Gets a OpenAI vector embedding for the input text provided.\n\n        Can be used with the Vector Store and Vector KNN nodes.\n      `,\n      infoBoxTitle: 'Get Embedding Node',\n      contextMenuTitle: 'Get Embedding',\n      group: ['AI'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const input = coerceType(inputs['input' as PortId], 'string');\n\n    const integrationName = this.data.useIntegrationInput\n      ? coerceType(inputs['integration' as PortId], 'string')\n      : this.data.integration;\n\n    const model = this.data.useModelInput ? coerceType(inputs['model' as PortId], 'string') : this.data.model;\n\n    const dimensions = this.data.useDimensionsInput\n      ? coerceType(inputs['dimensions' as PortId], 'number')\n      : this.data.dimensions;\n\n    const embeddingGenerator = getIntegration('embeddingGenerator', integrationName, context);\n\n    const embedding = await embeddingGenerator.generateEmbedding(input, {\n      model,\n      dimensions,\n    });\n\n    return {\n      ['embedding' as PortId]: {\n        type: 'vector',\n        value: embedding,\n      },\n    };\n  }\n}\n\nexport const getEmbeddingNode = nodeDefinition(GetEmbeddingNodeImpl, 'Get Embedding');\n"]},{"id":"YPmHXri4HXpshVEwuzg5m","data":["ReadFileNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { type DataValue } from '../DataValue.js';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { getInputOrData } from '../../utils/index.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type ReadFileNode = ChartNode<'readFile', ReadFileNodeData>;\n\ntype ReadFileNodeData = {\n  path: string;\n  usePathInput: boolean;\n\n  asBinary?: boolean;\n\n  errorOnMissingFile?: boolean;\n};\n\nexport class ReadFileNodeImpl extends NodeImpl<ReadFileNode> {\n  static create(): ReadFileNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'readFile',\n      title: 'Read File',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        path: '',\n        asBinary: false,\n        usePathInput: true,\n        errorOnMissingFile: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.usePathInput) {\n      inputDefinitions.push({\n        id: 'path' as PortId,\n        title: 'Path',\n        dataType: 'string',\n        coerced: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'content' as PortId,\n        title: 'Content',\n        dataType: this.data.asBinary ? 'binary' : 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Reads the contents of the specified file and outputs it as a string.\n      `,\n      infoBoxTitle: 'Read File Node',\n      contextMenuTitle: 'Read File',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<ReadFileNode>[] {\n    return [\n      {\n        type: 'filePathBrowser',\n        label: 'Path',\n        dataKey: 'path',\n        useInputToggleDataKey: 'usePathInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Error on Missing File',\n        dataKey: 'errorOnMissingFile',\n      },\n      {\n        type: 'toggle',\n        label: 'Read as Binary',\n        dataKey: 'asBinary',\n      },\n    ];\n  }\n\n  getBody(): NodeBody {\n    return dedent`\n      ${this.data.asBinary ? 'Read as Binary' : 'Read as Text'}\n      ${this.data.usePathInput ? '' : `Path: ${this.data.path}`}\n    `;\n  }\n\n  async process(\n    inputData: Record<PortId, DataValue>,\n    context: InternalProcessContext,\n  ): Promise<Record<PortId, DataValue>> {\n    const { nativeApi } = context;\n\n    if (nativeApi == null) {\n      throw new Error('This node requires a native API to run.');\n    }\n\n    const path = getInputOrData(this.chartNode.data, inputData, 'path');\n\n    try {\n      if (this.data.asBinary) {\n        const content = await nativeApi.readBinaryFile(path);\n        const buffer = await content.arrayBuffer();\n        return {\n          ['content' as PortId]: { type: 'binary', value: new Uint8Array(buffer) },\n        };\n      } else {\n        const content = await nativeApi.readTextFile(path, undefined);\n        return {\n          ['content' as PortId]: { type: 'string', value: content },\n        };\n      }\n    } catch (err) {\n      if (this.chartNode.data.errorOnMissingFile) {\n        throw err;\n      } else {\n        return {\n          ['content' as PortId]: { type: 'control-flow-excluded', value: undefined },\n        };\n      }\n    }\n  }\n}\n\nexport const readFileNode = nodeDefinition(ReadFileNodeImpl, 'Read File');\n"]},{"id":"bvcQOyLMwToJLLjNbr-gP","data":["GraphOutputNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeOutputDefinition,\n  type PortId,\n  type NodeInputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataType } from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type GraphOutputNode = ChartNode<'graphOutput', GraphOutputNodeData>;\n\nexport type GraphOutputNodeData = {\n  id: string;\n  dataType: DataType;\n};\n\nexport class GraphOutputNodeImpl extends NodeImpl<GraphOutputNode> {\n  static create(): GraphOutputNode {\n    const chartNode: GraphOutputNode = {\n      type: 'graphOutput',\n      title: 'Graph Output',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        id: 'output',\n        dataType: 'string',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'value' as PortId,\n        title: this.data.id,\n        dataType: this.chartNode.data.dataType as DataType,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'valueOutput' as PortId,\n        title: this.data.id,\n        dataType: this.chartNode.data.dataType as DataType,\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<GraphOutputNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'ID',\n        dataKey: 'id',\n      },\n      {\n        type: 'dataTypeSelector',\n        label: 'Data Type',\n        dataKey: 'dataType',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      ${this.data.id}\n      Type: ${this.data.dataType}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Each instance of this node represents an individual output of the graph. The value passed into this node becomes part of the overall output of the graph.\n      `,\n      infoBoxTitle: 'Graph Output Node',\n      contextMenuTitle: 'Graph Output',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const value = inputs['value' as PortId] ?? { type: 'any', value: undefined };\n\n    const isExcluded = value.type === 'control-flow-excluded';\n\n    if (isExcluded && context.graphOutputs[this.data.id] == null) {\n      context.graphOutputs[this.data.id] = {\n        type: 'control-flow-excluded',\n        value: undefined,\n      };\n    } else if (\n      (context.graphOutputs[this.data.id] == null ||\n        context.graphOutputs[this.data.id]?.type === 'control-flow-excluded') &&\n      inputs['value' as PortId]\n    ) {\n      context.graphOutputs[this.data.id] = value;\n    }\n\n    if (isExcluded) {\n      return {\n        ['valueOutput' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['valueOutput' as PortId]: context.graphOutputs[this.data.id],\n    };\n  }\n}\n\nexport const graphOutputNode = nodeDefinition(GraphOutputNodeImpl, 'Graph Output');\n"]},{"id":"pH6nunBGhnnuJEmSW6rn-","data":["ChatNodeBase.ts","import { match } from 'ts-pattern';\nimport { coerceType, coerceTypeOptional } from '../../utils/coerceType.js';\nimport { getError } from '../../utils/errors.js';\nimport { dedent } from '../../utils/misc.js';\nimport {\n  OpenAIError,\n  openAiModelOptions,\n  openaiModels,\n  type ChatCompletionOptions,\n  type ChatCompletionTool,\n  chatCompletions,\n  streamChatCompletions,\n  type ChatCompletionChunkUsage,\n} from '../../utils/openai.js';\nimport { isArrayDataValue, type ChatMessage, getScalarTypeOf, type ScalarDataValue } from '../DataValue.js';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { ChartNode, NodeInputDefinition, NodeOutputDefinition, PortId } from '../NodeBase.js';\nimport type { ChatNode } from './ChatNode.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { cleanHeaders, getInputOrData } from '../../utils/inputs.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport { chatMessageToOpenAIChatCompletionMessage } from '../../utils/chatMessageToOpenAIChatCompletionMessage.js';\nimport { DEFAULT_CHAT_ENDPOINT } from '../../utils/defaults.js';\nimport type { TokenizerCallInfo } from '../../integrations/Tokenizer.js';\nimport { addWarning } from '../../utils/outputs.js';\nimport retry from 'p-retry';\nimport { base64ToUint8Array } from '../../utils/base64.js';\n\nexport type ChatNodeConfigData = {\n  model: string;\n  temperature: number;\n  useTopP: boolean;\n  top_p?: number;\n  maxTokens: number;\n  stop?: string;\n  presencePenalty?: number;\n  frequencyPenalty?: number;\n  enableFunctionUse?: boolean;\n  user?: string;\n  numberOfChoices?: number;\n  endpoint?: string;\n  overrideModel?: string;\n  overrideMaxTokens?: number;\n  headers?: { key: string; value: string }[];\n  seed?: number;\n  toolChoice?: 'none' | 'auto' | 'function';\n  toolChoiceFunction?: string;\n  responseFormat?: '' | 'text' | 'json' | 'json_schema';\n  parallelFunctionCalling?: boolean;\n  additionalParameters?: { key: string; value: string }[];\n  responseSchemaName?: string;\n  useServerTokenCalculation?: boolean;\n  outputUsage?: boolean;\n  usePredictedOutput?: boolean;\n  reasoningEffort?: '' | 'low' | 'medium' | 'high';\n\n  modalitiesIncludeText?: boolean;\n  modalitiesIncludeAudio?: boolean;\n\n  audioVoice?: string;\n  audioFormat?: 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16';\n};\n\nexport type ChatNodeData = ChatNodeConfigData & {\n  useModelInput: boolean;\n  useTemperatureInput: boolean;\n  useTopPInput: boolean;\n  useTopP: boolean;\n  useUseTopPInput: boolean;\n  useMaxTokensInput: boolean;\n  useStop: boolean;\n  useStopInput: boolean;\n  usePresencePenaltyInput: boolean;\n  useFrequencyPenaltyInput: boolean;\n  useUserInput?: boolean;\n  useNumberOfChoicesInput?: boolean;\n  useEndpointInput?: boolean;\n  useHeadersInput?: boolean;\n  useSeedInput?: boolean;\n  useToolChoiceInput?: boolean;\n  useToolChoiceFunctionInput?: boolean;\n  useResponseFormatInput?: boolean;\n  useAdditionalParametersInput?: boolean;\n  useResponseSchemaNameInput?: boolean;\n  useAudioVoiceInput?: boolean;\n  useAudioFormatInput?: boolean;\n  useReasoningEffortInput?: boolean;\n\n  /** Given the same set of inputs, return the same output without hitting GPT */\n  cache: boolean;\n\n  useAsGraphPartialOutput?: boolean;\n};\n\n// Temporary\nconst cache = new Map<string, Outputs>();\n\nexport const ChatNodeBase = {\n  defaultData: (): ChatNodeData => ({\n    model: 'gpt-4o-mini',\n    useModelInput: false,\n    temperature: 0.5,\n    useTemperatureInput: false,\n    top_p: 1,\n    useTopPInput: false,\n    useTopP: false,\n    useUseTopPInput: false,\n    maxTokens: 1024,\n    useMaxTokensInput: false,\n    useStop: false,\n    stop: '',\n    useStopInput: false,\n    presencePenalty: undefined,\n    usePresencePenaltyInput: false,\n    frequencyPenalty: undefined,\n    useFrequencyPenaltyInput: false,\n    user: undefined,\n    useUserInput: false,\n    enableFunctionUse: false,\n    cache: false,\n    useAsGraphPartialOutput: true,\n    parallelFunctionCalling: true,\n    additionalParameters: [],\n    useAdditionalParametersInput: false,\n    useServerTokenCalculation: true,\n    outputUsage: false,\n    usePredictedOutput: false,\n    modalitiesIncludeAudio: false,\n    modalitiesIncludeText: false,\n    reasoningEffort: '',\n    useReasoningEffortInput: false,\n  }),\n\n  getInputDefinitions: (data: ChatNodeData): NodeInputDefinition[] => {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (data.useEndpointInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'endpoint' as PortId,\n        title: 'Endpoint',\n        description:\n          'The endpoint to use for the OpenAI API. You can use this to replace with any OpenAI-compatible API. Leave blank for the default: https://api.openai.com/api/v1/chat/completions',\n      });\n    }\n\n    inputs.push({\n      id: 'systemPrompt' as PortId,\n      title: 'System Prompt',\n      dataType: 'string',\n      required: false,\n      description: 'The system prompt to send to the model.',\n      coerced: true,\n    });\n\n    if (data.useModelInput) {\n      inputs.push({\n        id: 'model' as PortId,\n        title: 'Model',\n        dataType: 'string',\n        required: false,\n        description: 'The model to use for the chat.',\n      });\n    }\n\n    if (data.useTemperatureInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'temperature' as PortId,\n        title: 'Temperature',\n        description:\n          'What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.',\n      });\n    }\n\n    if (data.useTopPInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'top_p' as PortId,\n        title: 'Top P',\n        description:\n          'An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.',\n      });\n    }\n\n    if (data.useUseTopPInput) {\n      inputs.push({\n        dataType: 'boolean',\n        id: 'useTopP' as PortId,\n        title: 'Use Top P',\n        description: 'Whether to use top p sampling, or temperature sampling.',\n      });\n    }\n\n    if (data.useMaxTokensInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'maxTokens' as PortId,\n        title: 'Max Tokens',\n        description: 'The maximum number of tokens to generate in the chat completion.',\n      });\n    }\n\n    if (data.useStopInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'stop' as PortId,\n        title: 'Stop',\n        description: 'A sequence where the API will stop generating further tokens.',\n      });\n    }\n\n    if (data.usePresencePenaltyInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'presencePenalty' as PortId,\n        title: 'Presence Penalty',\n        description: `Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.`,\n      });\n    }\n\n    if (data.useFrequencyPenaltyInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'frequencyPenalty' as PortId,\n        title: 'Frequency Penalty',\n        description: `Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.`,\n      });\n    }\n\n    if (data.useUserInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'user' as PortId,\n        title: 'User',\n        description:\n          'A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.',\n      });\n    }\n\n    if (data.useNumberOfChoicesInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'numberOfChoices' as PortId,\n        title: 'Number of Choices',\n        description: 'If greater than 1, the model will return multiple choices and the response will be an array.',\n      });\n    }\n\n    if (data.useHeadersInput) {\n      inputs.push({\n        dataType: 'object',\n        id: 'headers' as PortId,\n        title: 'Headers',\n        description: 'Additional headers to send to the API.',\n      });\n    }\n\n    inputs.push({\n      dataType: ['chat-message', 'chat-message[]'] as const,\n      id: 'prompt' as PortId,\n      title: 'Prompt',\n      description: 'The prompt message or messages to send to the model.',\n      coerced: true,\n    });\n\n    if (data.enableFunctionUse) {\n      inputs.push({\n        dataType: ['gpt-function', 'gpt-function[]'] as const,\n        id: 'functions' as PortId,\n        title: 'Functions',\n        description: 'Functions to use in the model. To connect multiple functions, use an Array node.',\n        coerced: false,\n      });\n    }\n\n    if (data.useSeedInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'seed' as PortId,\n        title: 'Seed',\n        coerced: true,\n        description:\n          'If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.',\n      });\n    }\n\n    if (data.useToolChoiceInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'toolChoice' as PortId,\n        title: 'Tool Choice',\n        coerced: true,\n        description:\n          'Controls which (if any) function is called by the model. `none` is the default when no functions are present. `auto` is the default if functions are present. `function` forces the model to call a function.',\n      });\n    }\n\n    if (data.useToolChoiceInput || data.useToolChoiceFunctionInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'toolChoiceFunction' as PortId,\n        title: 'Tool Choice Function',\n        coerced: true,\n        description: 'The name of the function to force the model to call.',\n      });\n    }\n\n    if (data.useResponseFormatInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'responseFormat' as PortId,\n        title: 'Response Format',\n        coerced: true,\n        description: 'The format to force the model to reply in.',\n      });\n    }\n\n    if (data.useAdditionalParametersInput) {\n      inputs.push({\n        dataType: 'object',\n        id: 'additionalParameters' as PortId,\n        title: 'Additional Parameters',\n        description: 'Additional chat completion parameters to send to the API.',\n      });\n    }\n\n    if (data.responseFormat === 'json_schema') {\n      inputs.push({\n        dataType: 'object',\n        id: 'responseSchema' as PortId,\n        title: 'Response Schema',\n        description: 'The JSON schema that the response will adhere to (Structured Outputs).',\n        required: true,\n      });\n\n      if (data.useResponseSchemaNameInput) {\n        inputs.push({\n          dataType: 'string',\n          id: 'responseSchemaName' as PortId,\n          title: 'Response Schema Name',\n          description: 'The name of the JSON schema that the response will adhere to (Structured Outputs).',\n          required: false,\n        });\n      }\n    }\n\n    if (data.usePredictedOutput) {\n      inputs.push({\n        dataType: 'string[]',\n        id: 'predictedOutput' as PortId,\n        title: 'Predicted Output',\n        description: 'The predicted output from the model.',\n        coerced: true,\n      });\n    }\n\n    if (data.useAudioVoiceInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'audioVoice' as PortId,\n        title: 'Audio Voice',\n        description: 'The voice to use for audio responses. See your model for supported voices.',\n      });\n    }\n\n    if (data.useAudioFormatInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'audioFormat' as PortId,\n        title: 'Audio Format',\n        description: 'The format to use for audio responses.',\n      });\n    }\n\n    return inputs;\n  },\n\n  getOutputDefinitions: (data: ChatNodeData): NodeInputDefinition[] => {\n    const outputs: NodeOutputDefinition[] = [];\n\n    if (data.useNumberOfChoicesInput || (data.numberOfChoices ?? 1) > 1) {\n      outputs.push({\n        dataType: 'string[]',\n        id: 'response' as PortId,\n        title: 'Responses',\n        description: 'All responses from the model.',\n      });\n    } else {\n      outputs.push({\n        dataType: 'string',\n        id: 'response' as PortId,\n        title: 'Response',\n        description: 'The textual response from the model.',\n      });\n    }\n\n    if (data.enableFunctionUse) {\n      if (data.parallelFunctionCalling) {\n        outputs.push({\n          dataType: 'object[]',\n          id: 'function-calls' as PortId,\n          title: 'Function Calls',\n          description: 'The function calls that were made, if any.',\n        });\n      } else {\n        outputs.push({\n          dataType: 'object',\n          id: 'function-call' as PortId,\n          title: 'Function Call',\n          description: 'The function call that was made, if any.',\n        });\n      }\n    }\n\n    outputs.push({\n      dataType: 'chat-message[]',\n      id: 'in-messages' as PortId,\n      title: 'Messages Sent',\n      description: 'All messages sent to the model.',\n    });\n\n    if (!(data.useNumberOfChoicesInput || (data.numberOfChoices ?? 1) > 1)) {\n      outputs.push({\n        dataType: 'chat-message[]',\n        id: 'all-messages' as PortId,\n        title: 'All Messages',\n        description: 'All messages, with the response appended.',\n      });\n    }\n\n    outputs.push({\n      dataType: 'number',\n      id: 'responseTokens' as PortId,\n      title: 'Response Tokens',\n      description: 'The number of tokens in the response from the LLM. For a multi-response, this is the sum.',\n    });\n\n    if (data.outputUsage) {\n      outputs.push({\n        dataType: 'object',\n        id: 'usage' as PortId,\n        title: 'Usage',\n        description: 'Usage statistics for the model.',\n      });\n    }\n\n    if (data.modalitiesIncludeAudio) {\n      outputs.push({\n        dataType: 'audio',\n        id: 'audio' as PortId,\n        title: 'Audio',\n        description: 'The audio response from the model.',\n      });\n\n      outputs.push({\n        dataType: 'string',\n        id: 'audioTranscript' as PortId,\n        title: 'Transcript',\n        description: 'The transcript of the audio response.',\n      });\n    }\n\n    return outputs;\n  },\n\n  getEditors: (): EditorDefinition<ChatNode>[] => {\n    return [\n      {\n        type: 'dropdown',\n        label: 'GPT Model',\n        dataKey: 'model',\n        useInputToggleDataKey: 'useModelInput',\n        options: openAiModelOptions,\n        disableIf: (data) => {\n          return !!data.overrideModel?.trim();\n        },\n        helperMessage: (data) => {\n          if (data.overrideModel?.trim()) {\n            return `Model overridden to: ${data.overrideModel}`;\n          }\n          if (data.model === 'local-model') {\n            return 'Local model is an indicator for your own convenience, it does not affect the local LLM used.';\n          }\n        },\n      },\n      {\n        type: 'group',\n        label: 'Parameters',\n        editors: [\n          {\n            type: 'number',\n            label: 'Temperature',\n            dataKey: 'temperature',\n            useInputToggleDataKey: 'useTemperatureInput',\n            min: 0,\n            max: 2,\n            step: 0.1,\n            helperMessage:\n              'What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.',\n          },\n          {\n            type: 'number',\n            label: 'Top P',\n            dataKey: 'top_p',\n            useInputToggleDataKey: 'useTopPInput',\n            min: 0,\n            max: 1,\n            step: 0.1,\n            helperMessage:\n              'An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.',\n          },\n          {\n            type: 'toggle',\n            label: 'Use Top P',\n            dataKey: 'useTopP',\n            useInputToggleDataKey: 'useUseTopPInput',\n            helperMessage: 'Whether to use top p sampling, or temperature sampling.',\n          },\n          {\n            type: 'number',\n            label: 'Max Tokens',\n            dataKey: 'maxTokens',\n            useInputToggleDataKey: 'useMaxTokensInput',\n            min: 0,\n            max: Number.MAX_SAFE_INTEGER,\n            step: 1,\n            helperMessage: 'The maximum number of tokens to generate in the chat completion.',\n          },\n          {\n            type: 'string',\n            label: 'Stop',\n            dataKey: 'stop',\n            useInputToggleDataKey: 'useStopInput',\n            helperMessage: 'A sequence where the API will stop generating further tokens.',\n          },\n          {\n            type: 'number',\n            label: 'Presence Penalty',\n            dataKey: 'presencePenalty',\n            useInputToggleDataKey: 'usePresencePenaltyInput',\n            min: 0,\n            max: 2,\n            step: 0.1,\n            allowEmpty: true,\n            helperMessage: `Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.`,\n          },\n          {\n            type: 'number',\n            label: 'Frequency Penalty',\n            dataKey: 'frequencyPenalty',\n            useInputToggleDataKey: 'useFrequencyPenaltyInput',\n            min: 0,\n            max: 2,\n            step: 0.1,\n            allowEmpty: true,\n            helperMessage: `Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.`,\n          },\n          {\n            type: 'dropdown',\n            label: 'Reasoning Effort',\n            dataKey: 'reasoningEffort',\n            useInputToggleDataKey: 'useReasoningEffortInput',\n            options: [\n              { value: '', label: 'Unset' },\n              { value: 'low', label: 'Low' },\n              { value: 'medium', label: 'Medium' },\n              { value: 'high', label: 'High' },\n            ],\n            defaultValue: '',\n            helperMessage:\n              'Adjust the level of reasoning depth the model should apply. Only applies to reasoning models such as o3-mini.',\n          },\n          {\n            type: 'dropdown',\n            label: 'Response Format',\n            dataKey: 'responseFormat',\n            useInputToggleDataKey: 'useResponseFormatInput',\n            options: [\n              { value: '', label: 'Default' },\n              { value: 'text', label: 'Text' },\n              { value: 'json', label: 'JSON Object' },\n              { value: 'json_schema', label: 'JSON Schema' },\n            ],\n            defaultValue: '',\n            helperMessage: 'The format to force the model to reply in.',\n          },\n          {\n            type: 'string',\n            label: 'Response Schema Name',\n            dataKey: 'responseSchemaName',\n            useInputToggleDataKey: 'useResponseSchemaNameInput',\n            helperMessage:\n              'The name of the JSON schema that the response will adhere to (Structured Outputs). Defaults to response_schema',\n            hideIf: (data) => data.responseFormat !== 'json_schema',\n          },\n          {\n            type: 'number',\n            label: 'Seed',\n            dataKey: 'seed',\n            useInputToggleDataKey: 'useSeedInput',\n            step: 1,\n            allowEmpty: true,\n            helperMessage:\n              'If specified, OpenAI will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.',\n          },\n        ],\n      },\n      {\n        type: 'group',\n        label: 'GPT Tools',\n        editors: [\n          {\n            type: 'toggle',\n            label: 'Enable Function Use',\n            dataKey: 'enableFunctionUse',\n          },\n          {\n            type: 'toggle',\n            label: 'Enable Parallel Function Calling',\n            dataKey: 'parallelFunctionCalling',\n            hideIf: (data) => !data.enableFunctionUse,\n          },\n          {\n            type: 'dropdown',\n            label: 'Tool Choice',\n            dataKey: 'toolChoice',\n            useInputToggleDataKey: 'useToolChoiceInput',\n            options: [\n              { value: '', label: 'Default' },\n              { value: 'none', label: 'None' },\n              { value: 'auto', label: 'Auto' },\n              { value: 'function', label: 'Function' },\n              { value: 'required', label: 'Required' },\n            ],\n            defaultValue: '',\n            helperMessage:\n              'Controls which (if any) function is called by the model. None is the default when no functions are present. Auto is the default if functions are present.',\n            hideIf: (data) => !data.enableFunctionUse,\n          },\n          {\n            type: 'string',\n            label: 'Tool Choice Function',\n            dataKey: 'toolChoiceFunction',\n            useInputToggleDataKey: 'useToolChoiceFunctionInput',\n            helperMessage: 'The name of the function to force the model to call.',\n            hideIf: (data) => data.toolChoice !== 'function' || !data.enableFunctionUse,\n          },\n        ],\n      },\n      {\n        type: 'group',\n        label: 'Features',\n        editors: [\n          {\n            type: 'toggle',\n            label: 'Enable Predicted Output',\n            dataKey: 'usePredictedOutput',\n            helperMessage:\n              'If on, enables an input port for the predicted output from the model, when many of the output tokens are known ahead of time.',\n          },\n          {\n            type: 'toggle',\n            label: 'Modalities: Text',\n            dataKey: 'modalitiesIncludeText',\n            helperMessage: 'If on, the model will include text in its responses. Only relevant for multimodal models.',\n          },\n          {\n            type: 'toggle',\n            label: 'Modalities: Audio',\n            dataKey: 'modalitiesIncludeAudio',\n            helperMessage: 'If on, the model will include audio in its responses. Only relevant for multimodal models.',\n          },\n          {\n            type: 'string',\n            label: 'Audio Voice',\n            dataKey: 'audioVoice',\n            useInputToggleDataKey: 'useAudioVoiceInput',\n            helperMessage:\n              'The voice to use for audio responses. See your model for supported voices. OpenAI voices are: alloy, ash, coral, echo, fable, onyx, nova, sage, and shimmer.',\n            hideIf: (data) => !data.modalitiesIncludeAudio,\n          },\n          {\n            type: 'dropdown',\n            label: 'Audio Format',\n            dataKey: 'audioFormat',\n            useInputToggleDataKey: 'useAudioFormatInput',\n            options: [\n              { value: 'wav', label: 'WAV' },\n              { value: 'mp3', label: 'MP3' },\n              { value: 'flac', label: 'FLAC' },\n              { value: 'opus', label: 'OPUS' },\n              { value: 'pcm16', label: 'PCM16' },\n            ],\n            defaultValue: 'wav',\n            hideIf: (data) => !data.modalitiesIncludeAudio,\n          },\n        ],\n      },\n      {\n        type: 'group',\n        label: 'Advanced',\n        editors: [\n          {\n            type: 'toggle',\n            label: 'Use Server Token Calculation',\n            dataKey: 'useServerTokenCalculation',\n            helperMessage:\n              'If on, do not calculate token counts on the client side, and rely on the server providing the token count.',\n          },\n          {\n            type: 'toggle',\n            label: 'Output Usage Statistics',\n            dataKey: 'outputUsage',\n            helperMessage: 'If on, output usage statistics for the model, such as token counts and cost.',\n          },\n          {\n            type: 'string',\n            label: 'User',\n            dataKey: 'user',\n            useInputToggleDataKey: 'useUserInput',\n            helperMessage:\n              'A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.',\n          },\n          {\n            type: 'number',\n            label: 'Number of Choices',\n            dataKey: 'numberOfChoices',\n            useInputToggleDataKey: 'useNumberOfChoicesInput',\n            min: 1,\n            max: 10,\n            step: 1,\n            defaultValue: 1,\n            helperMessage:\n              'If greater than 1, the model will return multiple choices and the response will be an array.',\n          },\n          {\n            type: 'string',\n            label: 'Endpoint',\n            dataKey: 'endpoint',\n            useInputToggleDataKey: 'useEndpointInput',\n            helperMessage:\n              'The endpoint to use for the OpenAI API. You can use this to replace with any OpenAI-compatible API. Leave blank for the default: https://api.openai.com/api/v1/chat/completions',\n          },\n          {\n            type: 'string',\n            label: 'Custom Model',\n            dataKey: 'overrideModel',\n            helperMessage: 'Overrides the model selected above with a custom string for the model.',\n          },\n          {\n            type: 'number',\n            label: 'Custom Max Tokens',\n            dataKey: 'overrideMaxTokens',\n            allowEmpty: true,\n            helperMessage:\n              'Overrides the max number of tokens a model can support. Leave blank for preconfigured token limits.',\n          },\n          {\n            type: 'keyValuePair',\n            label: 'Headers',\n            dataKey: 'headers',\n            useInputToggleDataKey: 'useHeadersInput',\n            keyPlaceholder: 'Header',\n            helperMessage: 'Additional headers to send to the API.',\n          },\n          {\n            type: 'toggle',\n            label: 'Cache In Rivet',\n            dataKey: 'cache',\n            helperMessage:\n              'If on, requests with the same parameters and messages will be cached in Rivet, for immediate responses without an API call.',\n          },\n          {\n            type: 'toggle',\n            label: 'Use for subgraph partial output',\n            dataKey: 'useAsGraphPartialOutput',\n            helperMessage:\n              'If on, streaming responses from this node will be shown in Subgraph nodes that call this graph.',\n          },\n          {\n            type: 'keyValuePair',\n            label: 'Additional Parameters',\n            dataKey: 'additionalParameters',\n            useInputToggleDataKey: 'useAdditionalParametersInput',\n            keyPlaceholder: 'Parameter',\n            valuePlaceholder: 'Value',\n            helperMessage:\n              'Additional chat completion parameters to send to the API. If the value appears to be a number, it will be sent as a number.',\n          },\n        ],\n      },\n    ];\n  },\n\n  getBody: (data: ChatNodeData): string | undefined => {\n    return dedent`\n      ${data.endpoint ? `${data.endpoint}` : ''}\n      ${data.useMaxTokensInput ? 'Max Tokens: (Using Input)' : `${data.maxTokens} tokens`}\n      Model: ${data.useModelInput ? '(Using Input)' : data.overrideModel || data.model}\n      ${data.useTopP ? 'Top P' : 'Temperature'}:\n      ${\n        data.useTopP\n          ? data.useTopPInput\n            ? '(Using Input)'\n            : data.top_p\n          : data.useTemperatureInput\n            ? '(Using Input)'\n            : data.temperature\n      }\n      ${data.useStop ? `Stop: ${data.useStopInput ? '(Using Input)' : data.stop}` : ''}\n      ${\n        (data.frequencyPenalty ?? 0) !== 0\n          ? `Frequency Penalty: ${data.useFrequencyPenaltyInput ? '(Using Input)' : data.frequencyPenalty}`\n          : ''\n      }\n      ${\n        (data.presencePenalty ?? 0) !== 0\n          ? `Presence Penalty: ${data.usePresencePenaltyInput ? '(Using Input)' : data.presencePenalty}`\n          : ''\n      }\n    `.trim();\n  },\n\n  process: async (\n    data: ChatNodeData,\n    node: ChartNode,\n    inputs: Inputs,\n    context: InternalProcessContext,\n  ): Promise<Outputs> => {\n    const output: Outputs = {};\n\n    const model = getInputOrData(data, inputs, 'model');\n    const temperature = getInputOrData(data, inputs, 'temperature', 'number');\n\n    const topP = data.useTopPInput ? coerceTypeOptional(inputs['top_p' as PortId], 'number') ?? data.top_p : data.top_p;\n\n    const useTopP = getInputOrData(data, inputs, 'useTopP', 'boolean');\n    const stop = data.useStopInput\n      ? data.useStop\n        ? coerceTypeOptional(inputs['stop' as PortId], 'string') ?? data.stop\n        : undefined\n      : data.stop;\n\n    const presencePenalty = getInputOrData(data, inputs, 'presencePenalty', 'number');\n    const frequencyPenalty = getInputOrData(data, inputs, 'frequencyPenalty', 'number');\n    const numberOfChoices = getInputOrData(data, inputs, 'numberOfChoices', 'number');\n    const endpoint = getInputOrData(data, inputs, 'endpoint');\n    const overrideModel = getInputOrData(data, inputs, 'overrideModel');\n    const seed = getInputOrData(data, inputs, 'seed', 'number');\n    const responseFormat = getInputOrData(data, inputs, 'responseFormat') as 'text' | 'json' | 'json_schema' | '';\n    const toolChoiceMode = getInputOrData(data, inputs, 'toolChoice', 'string') as 'none' | 'auto' | 'function';\n\n    const predictedOutput = data.usePredictedOutput\n      ? coerceTypeOptional(inputs['predictedOutput' as PortId], 'string[]')\n      : undefined;\n\n    const toolChoice: ChatCompletionOptions['tool_choice'] =\n      !toolChoiceMode || !data.enableFunctionUse\n        ? undefined\n        : toolChoiceMode === 'function'\n          ? {\n              type: 'function',\n              function: {\n                name: getInputOrData(data, inputs, 'toolChoiceFunction', 'string'),\n              },\n            }\n          : toolChoiceMode;\n\n    let responseSchema: object | undefined;\n\n    const responseSchemaInput = inputs['responseSchema' as PortId];\n    if (responseSchemaInput?.type === 'gpt-function') {\n      responseSchema = responseSchemaInput.value.parameters;\n    } else if (responseSchemaInput != null) {\n      responseSchema = coerceType(responseSchemaInput, 'object');\n    }\n\n    const openaiResponseFormat = !responseFormat?.trim()\n      ? undefined\n      : responseFormat === 'json'\n        ? ({\n            type: 'json_object',\n          } as const)\n        : responseFormat === 'json_schema'\n          ? {\n              type: 'json_schema' as const,\n              json_schema: {\n                name: getInputOrData(data, inputs, 'responseSchemaName', 'string') || 'response_schema',\n                strict: true,\n                schema: responseSchema ?? {},\n              },\n            }\n          : ({\n              type: 'text',\n            } as const);\n\n    const headersFromData = (data.headers ?? []).reduce(\n      (acc, header) => {\n        acc[header.key] = header.value;\n        return acc;\n      },\n      {} as Record<string, string>,\n    );\n    const additionalHeaders = data.useHeadersInput\n      ? (coerceTypeOptional(inputs['headers' as PortId], 'object') as Record<string, string> | undefined) ??\n        headersFromData\n      : headersFromData;\n\n    const additionalParametersFromData = (data.additionalParameters ?? []).reduce(\n      (acc, param) => {\n        acc[param.key] = Number.isNaN(parseFloat(param.value)) ? param.value : parseFloat(param.value);\n        return acc;\n      },\n      {} as Record<string, string | number>,\n    );\n    const additionalParameters = data.useAdditionalParametersInput\n      ? (coerceTypeOptional(inputs['additionalParameters' as PortId], 'object') as\n          | Record<string, string>\n          | undefined) ?? additionalParametersFromData\n      : additionalParametersFromData;\n\n    // If using a model input, that's priority, otherwise override > main\n    const finalModel = data.useModelInput && inputs['model' as PortId] != null ? model : overrideModel || model;\n\n    const functions = coerceTypeOptional(inputs['functions' as PortId], 'gpt-function[]');\n\n    const tools = (functions ?? []).map(\n      (fn): ChatCompletionTool => ({\n        function: fn,\n        type: 'function',\n      }),\n    );\n\n    const { messages } = getChatNodeMessages(inputs);\n\n    const isReasoningModel = finalModel.startsWith('o1') || finalModel.startsWith('o3');\n\n    const completionMessages = await Promise.all(\n      messages.map((message) => chatMessageToOpenAIChatCompletionMessage(message, { isReasoningModel })),\n    );\n\n    let { maxTokens } = data;\n\n    const openaiModel = {\n      ...(openaiModels[model as keyof typeof openaiModels] ?? {\n        maxTokens: data.overrideMaxTokens ?? 8192,\n        cost: {\n          completion: 0,\n          prompt: 0,\n        },\n        displayName: 'Custom Model',\n      }),\n    };\n\n    if (data.overrideMaxTokens) {\n      openaiModel.maxTokens = data.overrideMaxTokens;\n    }\n\n    const isMultiResponse = data.useNumberOfChoicesInput || (data.numberOfChoices ?? 1) > 1;\n\n    // Resolve to final endpoint if configured in ProcessContext\n    const configuredEndpoint = endpoint || context.settings.openAiEndpoint || DEFAULT_CHAT_ENDPOINT;\n    const resolvedEndpointAndHeaders = context.getChatNodeEndpoint\n      ? await context.getChatNodeEndpoint(configuredEndpoint, finalModel)\n      : {\n          endpoint: configuredEndpoint,\n          headers: {},\n        };\n\n    const allAdditionalHeaders = cleanHeaders({\n      ...context.settings.chatNodeHeaders,\n      ...additionalHeaders,\n      ...resolvedEndpointAndHeaders.headers,\n    });\n\n    let inputTokenCount: number = 0;\n\n    const tokenizerInfo: TokenizerCallInfo = {\n      node,\n      model: finalModel,\n      endpoint: resolvedEndpointAndHeaders.endpoint,\n    };\n\n    if (!data.useServerTokenCalculation) {\n      inputTokenCount = await context.tokenizer.getTokenCountForMessages(messages, functions, tokenizerInfo);\n\n      if (inputTokenCount >= openaiModel.maxTokens) {\n        throw new Error(\n          `The model ${model} can only handle ${openaiModel.maxTokens} tokens, but ${inputTokenCount} were provided in the prompts alone.`,\n        );\n      }\n\n      if (inputTokenCount + maxTokens > openaiModel.maxTokens) {\n        const message = `The model can only handle a maximum of ${\n          openaiModel.maxTokens\n        } tokens, but the prompts and max tokens together exceed this limit. The max tokens has been reduced to ${\n          openaiModel.maxTokens - inputTokenCount\n        }.`;\n        addWarning(output, message);\n        maxTokens = Math.floor((openaiModel.maxTokens - inputTokenCount) * 0.95); // reduce max tokens by 5% to be safe, calculation is a little wrong.\n      }\n    }\n\n    const predictionObject = predictedOutput\n      ? predictedOutput.length === 1\n        ? { type: 'content' as const, content: predictedOutput[0]! }\n        : { type: 'content' as const, content: predictedOutput.map((part) => ({ type: 'text', text: part })) }\n      : undefined;\n\n    const voice = getInputOrData(data, inputs, 'audioVoice');\n\n    let modalities: ('text' | 'audio')[] | undefined = [];\n    if (data.modalitiesIncludeText) {\n      modalities.push('text');\n    }\n    if (data.modalitiesIncludeAudio) {\n      modalities.push('audio');\n\n      if (!voice) {\n        throw new Error('Audio voice must be specified if audio is enabled.');\n      }\n    }\n\n    // Errors happen if modalities isn't supported, so omit it if it's empty\n    if (modalities.length === 0) {\n      modalities = undefined;\n    }\n\n    const audio = modalities?.includes('audio')\n      ? {\n          voice,\n          format:\n            (getInputOrData(data, inputs, 'audioFormat') as 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16' | undefined) ??\n            'wav',\n        }\n      : undefined;\n\n    const reasoningEffort = getInputOrData(data, inputs, 'reasoningEffort') as '' | 'low' | 'medium' | 'high';\n\n    try {\n      return await retry(\n        async () => {\n          const options: Omit<ChatCompletionOptions, 'auth' | 'signal'> = {\n            messages: completionMessages,\n            model: finalModel,\n            top_p: useTopP ? topP : undefined,\n            n: numberOfChoices,\n            frequency_penalty: frequencyPenalty,\n            presence_penalty: presencePenalty,\n            stop: stop || undefined,\n            tools: tools.length > 0 ? tools : undefined,\n            endpoint: resolvedEndpointAndHeaders.endpoint,\n            seed,\n            response_format: openaiResponseFormat,\n            tool_choice: toolChoice,\n            prediction: predictionObject,\n            modalities,\n            audio,\n            reasoning_effort: reasoningEffort || undefined,\n            ...additionalParameters,\n          };\n\n          const isO1Beta = finalModel.startsWith('o1-preview') || finalModel.startsWith('o1-mini');\n\n          if (isReasoningModel) {\n            options.max_completion_tokens = maxTokens;\n          } else {\n            options.temperature = useTopP ? undefined : temperature; // Not supported in o1-preview\n            options.max_tokens = maxTokens;\n          }\n\n          const cacheKey = JSON.stringify(options);\n\n          if (data.cache) {\n            const cached = cache.get(cacheKey);\n            if (cached) {\n              return cached;\n            }\n          }\n\n          const startTime = Date.now();\n\n          // Non-streaming APIs\n          if (isO1Beta || audio) {\n            const response = await chatCompletions({\n              auth: {\n                apiKey: context.settings.openAiKey ?? '',\n                organization: context.settings.openAiOrganization,\n              },\n              headers: allAdditionalHeaders,\n              signal: context.signal,\n              timeout: context.settings.chatNodeTimeout,\n              ...options,\n            });\n\n            if ('error' in response) {\n              throw new OpenAIError(400, response.error);\n            }\n\n            if (isMultiResponse) {\n              output['response' as PortId] = {\n                type: 'string[]',\n                value: response.choices.map((c) => c.message.content!),\n              };\n            } else {\n              output['response' as PortId] = {\n                type: 'string',\n                value: response.choices[0]!.message.content! ?? '',\n              };\n            }\n\n            if (!isMultiResponse) {\n              output['all-messages' as PortId] = {\n                type: 'chat-message[]',\n                value: [\n                  ...messages,\n                  {\n                    type: 'assistant',\n                    message: response.choices[0]!.message.content! ?? '',\n                    function_calls: undefined,\n                    isCacheBreakpoint: false,\n                    function_call: undefined,\n                  },\n                ],\n              };\n            }\n\n            if (modalities?.includes('audio')) {\n              const audioData = response.choices[0]!.message.audio;\n\n              output['audio' as PortId] = {\n                type: 'audio',\n                value: {\n                  data: base64ToUint8Array(audioData!.data),\n                  mediaType: audioFormatToMediaType(audio!.format),\n                },\n              };\n\n              output['audioTranscript' as PortId] = {\n                type: 'string',\n                value: response.choices[0]!.message.audio!.transcript,\n              };\n            }\n\n            output['duration' as PortId] = { type: 'number', value: Date.now() - startTime };\n\n            if (response.usage) {\n              output['usage' as PortId] = {\n                type: 'object',\n                value: response.usage,\n              };\n\n              const costs =\n                finalModel in openaiModels ? openaiModels[finalModel as keyof typeof openaiModels].cost : undefined;\n\n              const promptCostPerThousand = costs?.prompt ?? 0;\n              const completionCostPerThousand = costs?.completion ?? 0;\n              const audioPromptCostPerThousand = costs\n                ? 'audioPrompt' in costs\n                  ? (costs.audioPrompt as number)\n                  : 0\n                : 0;\n              const audioCompletionCostPerThousand = costs\n                ? 'audioCompletion' in costs\n                  ? (costs.audioCompletion as number)\n                  : 0\n                : 0;\n\n              const promptCost = getCostForTokens(\n                response.usage.prompt_tokens_details.text_tokens,\n                'prompt',\n                promptCostPerThousand,\n              );\n              const completionCost = getCostForTokens(\n                response.usage.completion_tokens_details.text_tokens,\n                'completion',\n                completionCostPerThousand,\n              );\n              const audioPromptCost = getCostForTokens(\n                response.usage.prompt_tokens_details.audio_tokens,\n                'prompt',\n                audioPromptCostPerThousand,\n              );\n              const audioCompletionCost = getCostForTokens(\n                response.usage.completion_tokens_details.audio_tokens,\n                'completion',\n                audioCompletionCostPerThousand,\n              );\n\n              output['cost' as PortId] = {\n                type: 'number',\n                value: promptCost + completionCost + audioPromptCost + audioCompletionCost,\n              };\n            }\n\n            Object.freeze(output);\n            cache.set(cacheKey, output);\n\n            return output;\n          }\n\n          const chunks = streamChatCompletions({\n            auth: {\n              apiKey: context.settings.openAiKey ?? '',\n              organization: context.settings.openAiOrganization,\n            },\n            headers: allAdditionalHeaders,\n            signal: context.signal,\n            timeout: context.settings.chatNodeTimeout,\n            ...options,\n          });\n\n          const responseChoicesParts: string[][] = [];\n\n          // First array is the function calls per choice, inner array is the functions calls inside the choice\n          const functionCalls: {\n            type: 'function';\n            id: string;\n            name: string;\n            arguments: string;\n            lastParsedArguments?: unknown;\n          }[][] = [];\n\n          let usage: ChatCompletionChunkUsage | undefined;\n\n          let throttleLastCalledTime = Date.now();\n          const onPartialOutput = (output: Outputs) => {\n            const now = Date.now();\n            if (now - throttleLastCalledTime > (context.settings.throttleChatNode ?? 100)) {\n              context.onPartialOutputs?.(output);\n              throttleLastCalledTime = now;\n            }\n          };\n\n          for await (const chunk of chunks) {\n            if (chunk.usage) {\n              usage = chunk.usage;\n            }\n\n            if (!chunk.choices) {\n              // Could be error for some reason 🤷‍♂️ but ignoring has worked for me so far.\n              continue;\n            }\n\n            for (const { delta, index } of chunk.choices) {\n              if (delta.content != null) {\n                responseChoicesParts[index] ??= [];\n                responseChoicesParts[index]!.push(delta.content);\n              }\n\n              if (delta.tool_calls) {\n                // Are we sure that tool_calls will always be full and not a bunch of deltas?\n                functionCalls[index] ??= [];\n\n                for (const toolCall of delta.tool_calls) {\n                  functionCalls[index]![toolCall.index] ??= {\n                    type: 'function',\n                    arguments: '',\n                    lastParsedArguments: undefined,\n                    name: '',\n                    id: '',\n                  };\n\n                  if (toolCall.id) {\n                    functionCalls[index]![toolCall.index]!.id = toolCall.id;\n                  }\n\n                  if (toolCall.function.name) {\n                    functionCalls[index]![toolCall.index]!.name += toolCall.function.name;\n                  }\n\n                  if (toolCall.function.arguments) {\n                    functionCalls[index]![toolCall.index]!.arguments += toolCall.function.arguments;\n\n                    try {\n                      functionCalls[index]![toolCall.index]!.lastParsedArguments = JSON.parse(\n                        functionCalls[index]![toolCall.index]!.arguments,\n                      );\n                    } catch (error) {\n                      // Ignore\n                    }\n                  }\n                }\n              }\n            }\n\n            if (isMultiResponse) {\n              output['response' as PortId] = {\n                type: 'string[]',\n                value: responseChoicesParts.map((parts) => parts.join('')),\n              };\n            } else {\n              output['response' as PortId] = {\n                type: 'string',\n                value: responseChoicesParts[0]?.join('') ?? '',\n              };\n            }\n\n            if (functionCalls.length > 0) {\n              if (isMultiResponse) {\n                output['function-call' as PortId] = {\n                  type: 'object[]',\n                  value: functionCalls.map((functionCalls) => ({\n                    name: functionCalls[0]?.name,\n                    arguments: functionCalls[0]?.lastParsedArguments,\n                    id: functionCalls[0]?.id,\n                  })),\n                };\n              } else {\n                if (data.parallelFunctionCalling) {\n                  output['function-calls' as PortId] = {\n                    type: 'object[]',\n                    value: functionCalls[0]!.map((functionCall) => ({\n                      name: functionCall.name,\n                      arguments: functionCall.lastParsedArguments,\n                      id: functionCall.id,\n                    })),\n                  };\n                } else {\n                  output['function-call' as PortId] = {\n                    type: 'object',\n                    value: {\n                      name: functionCalls[0]![0]?.name,\n                      arguments: functionCalls[0]![0]?.lastParsedArguments,\n                      id: functionCalls[0]![0]?.id,\n                    } as Record<string, unknown>,\n                  };\n                }\n              }\n            }\n\n            onPartialOutput(output);\n          }\n\n          // Call one last time manually to ensure the last output is sent\n          context.onPartialOutputs?.(output);\n\n          if (!isMultiResponse) {\n            output['all-messages' as PortId] = {\n              type: 'chat-message[]',\n              value: [\n                ...messages,\n                {\n                  type: 'assistant',\n                  message: responseChoicesParts[0]?.join('') ?? '',\n                  function_call: functionCalls[0]\n                    ? {\n                        name: functionCalls[0][0]!.name,\n                        arguments: functionCalls[0][0]!.arguments, // Needs the stringified one here in chat list\n                        id: functionCalls[0][0]!.id,\n                      }\n                    : undefined,\n                  function_calls: functionCalls[0]\n                    ? functionCalls[0].map((fc) => ({\n                        name: fc.name,\n                        arguments: fc.arguments,\n                        id: fc.id,\n                      }))\n                    : undefined,\n                },\n              ],\n            };\n          }\n\n          const endTime = Date.now();\n\n          if (responseChoicesParts.length === 0 && functionCalls.length === 0) {\n            throw new Error('No response from OpenAI');\n          }\n\n          let outputTokenCount = 0;\n\n          if (usage) {\n            inputTokenCount = usage.prompt_tokens;\n            outputTokenCount = usage.completion_tokens;\n          }\n\n          output['in-messages' as PortId] = { type: 'chat-message[]', value: messages };\n          output['requestTokens' as PortId] = { type: 'number', value: inputTokenCount * (numberOfChoices ?? 1) };\n\n          if (!data.useServerTokenCalculation) {\n            let responseTokenCount = 0;\n            for (const choiceParts of responseChoicesParts) {\n              responseTokenCount += await context.tokenizer.getTokenCountForString(choiceParts.join(), tokenizerInfo);\n            }\n            outputTokenCount = responseTokenCount;\n          }\n\n          output['responseTokens' as PortId] = { type: 'number', value: outputTokenCount };\n\n          const outputTokensForCostCalculation = usage?.completion_tokens_details\n            ? usage.completion_tokens_details.rejected_prediction_tokens > 0\n              ? usage.completion_tokens_details.rejected_prediction_tokens\n              : usage.completion_tokens\n            : outputTokenCount;\n\n          const promptCostPerThousand =\n            model in openaiModels ? openaiModels[model as keyof typeof openaiModels].cost.prompt : 0;\n          const completionCostPerThousand =\n            model in openaiModels ? openaiModels[model as keyof typeof openaiModels].cost.completion : 0;\n\n          const promptCost = getCostForTokens(inputTokenCount, 'prompt', promptCostPerThousand);\n          const completionCost = getCostForTokens(\n            outputTokensForCostCalculation,\n            'completion',\n            completionCostPerThousand,\n          );\n\n          const cost = promptCost + completionCost;\n\n          if (usage) {\n            output['usage' as PortId] = {\n              type: 'object',\n              value: {\n                ...usage,\n                prompt_cost: promptCost,\n                completion_cost: completionCost,\n                total_cost: cost,\n              },\n            };\n          } else {\n            output['usage' as PortId] = {\n              type: 'object',\n              value: {\n                prompt_tokens: inputTokenCount,\n                completion_tokens: outputTokenCount,\n              },\n            };\n          }\n\n          output['cost' as PortId] = { type: 'number', value: cost };\n          output['__hidden_token_count' as PortId] = { type: 'number', value: inputTokenCount + outputTokenCount };\n\n          const duration = endTime - startTime;\n\n          output['duration' as PortId] = { type: 'number', value: duration };\n\n          Object.freeze(output);\n          cache.set(cacheKey, output);\n\n          return output;\n        },\n        {\n          forever: true,\n          retries: 10000,\n          maxRetryTime: 1000 * 60 * 5,\n          factor: 2.5,\n          minTimeout: 500,\n          maxTimeout: 5000,\n          randomize: true,\n          signal: context.signal,\n          onFailedAttempt(err) {\n            if (err.toString().includes('fetch failed') && err.cause) {\n              const cause =\n                getError(err.cause) instanceof AggregateError\n                  ? (err.cause as AggregateError).errors[0]\n                  : getError(err.cause);\n\n              err = cause;\n            }\n\n            context.trace(`ChatNode failed, retrying: ${err.toString()}`);\n\n            if (context.signal.aborted) {\n              throw new Error('Aborted');\n            }\n\n            const { retriesLeft } = err;\n\n            if (!(err instanceof OpenAIError)) {\n              if ('code' in err) {\n                throw err;\n              }\n\n              return; // Just retry?\n            }\n\n            if (err.status === 429) {\n              if (retriesLeft) {\n                context.onPartialOutputs?.({\n                  ['response' as PortId]: {\n                    type: 'string',\n                    value: 'OpenAI API rate limit exceeded, retrying...',\n                  },\n                });\n                return;\n              }\n            }\n\n            if (err.status === 408) {\n              if (retriesLeft) {\n                context.onPartialOutputs?.({\n                  ['response' as PortId]: {\n                    type: 'string',\n                    value: 'OpenAI API timed out, retrying...',\n                  },\n                });\n                return;\n              }\n            }\n\n            // We did something wrong (besides rate limit)\n            if (err.status >= 400 && err.status < 500) {\n              throw new Error(err.message);\n            }\n          },\n        },\n      );\n    } catch (error) {\n      context.trace(getError(error).stack ?? 'Missing stack');\n      throw new Error(`Error processing ChatNode: ${(error as Error).message}`);\n    }\n  },\n};\n\nexport function getChatNodeMessages(inputs: Inputs) {\n  const prompt = inputs['prompt' as PortId];\n\n  let messages: ChatMessage[] = match(prompt)\n    .with({ type: 'chat-message' }, (p) => [p.value])\n    .with({ type: 'chat-message[]' }, (p) => p.value)\n    .with({ type: 'string' }, (p): ChatMessage[] => [{ type: 'user', message: p.value }])\n    .with({ type: 'string[]' }, (p): ChatMessage[] => p.value.map((v) => ({ type: 'user', message: v })))\n    .otherwise((p): ChatMessage[] => {\n      if (!p) {\n        return [];\n      }\n\n      if (isArrayDataValue(p)) {\n        const stringValues = (p.value as readonly unknown[]).map((v) =>\n          coerceType(\n            {\n              type: getScalarTypeOf(p.type),\n              value: v,\n            } as ScalarDataValue,\n            'string',\n          ),\n        );\n\n        return stringValues.filter((v) => v != null).map((v) => ({ type: 'user', message: v }));\n      }\n\n      const coercedMessage = coerceTypeOptional(p, 'chat-message');\n      if (coercedMessage != null) {\n        return [coercedMessage];\n      }\n\n      const coercedString = coerceTypeOptional(p, 'string');\n      return coercedString != null ? [{ type: 'user', message: coerceType(p, 'string') }] : [];\n    });\n\n  const systemPrompt = inputs['systemPrompt' as PortId];\n  if (systemPrompt) {\n    if (messages.length > 0 && messages.at(0)!.type === 'system') {\n      // Delete the first system message if it's already there\n      messages.splice(0, 1);\n    }\n\n    messages = [{ type: 'system', message: coerceType(systemPrompt, 'string') }, ...messages];\n  }\n\n  return { messages, systemPrompt };\n}\n\nexport function getCostForTokens(tokenCount: number, type: 'prompt' | 'completion', costPerThousand: number) {\n  return (tokenCount / 1000) * costPerThousand;\n}\n\nfunction audioFormatToMediaType(format: 'wav' | 'mp3' | 'flac' | 'opus' | 'pcm16') {\n  switch (format) {\n    case 'wav':\n      return 'audio/wav';\n    case 'mp3':\n      return 'audio/mpeg';\n    case 'flac':\n      return 'audio/flac';\n    case 'opus':\n      return 'audio/opus';\n    case 'pcm16':\n      return 'audio/wav';\n  }\n}\n"]},{"id":"h-VrGhdHo1PNwJ6HrCubd","data":["ExtractRegexNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { expectType, expectTypeOptional } from '../../utils/expectType.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type ExtractRegexNode = ChartNode<'extractRegex', ExtractRegexNodeData>;\n\nexport type ExtractRegexNodeData = {\n  regex: string;\n  useRegexInput: boolean;\n  errorOnFailed: boolean;\n  multilineMode?: boolean;\n};\n\nexport class ExtractRegexNodeImpl extends NodeImpl<ExtractRegexNode> {\n  static create(): ExtractRegexNode {\n    const chartNode: ExtractRegexNode = {\n      type: 'extractRegex',\n      title: 'Extract Regex',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        regex: '([a-zA-Z]+)',\n        useRegexInput: false,\n        errorOnFailed: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      },\n    ];\n\n    if (this.chartNode.data.useRegexInput) {\n      inputs.push({\n        id: 'regex' as PortId,\n        title: 'Regex',\n        dataType: 'string',\n        required: false,\n        coerced: false,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const regex = this.chartNode.data.regex;\n    try {\n      const regExp = new RegExp(regex, 'g');\n      const captureGroupCount = countCaptureGroups(regExp);\n\n      const outputs: NodeOutputDefinition[] = [];\n\n      for (let i = 0; i < captureGroupCount; i++) {\n        outputs.push({\n          id: `output${i + 1}` as PortId,\n          title: `Output ${i + 1}`,\n          dataType: 'string',\n        });\n      }\n\n      outputs.push({\n        id: 'matches' as PortId,\n        title: 'Matches',\n        dataType: 'string[]',\n      });\n\n      outputs.push(\n        {\n          id: 'succeeded' as PortId,\n          title: 'Succeeded',\n          dataType: 'boolean',\n        },\n        {\n          id: 'failed' as PortId,\n          title: 'Failed',\n          dataType: 'boolean',\n        },\n      );\n\n      return outputs;\n    } catch (err) {\n      return [];\n    }\n  }\n\n  getEditors(): EditorDefinition<ExtractRegexNode>[] {\n    return [\n      {\n        type: 'custom',\n        customEditorId: 'ExtractRegexNodeAiAssist',\n        label: 'AI Assist',\n      },\n      {\n        type: 'toggle',\n        label: 'Error on failed',\n        dataKey: 'errorOnFailed',\n      },\n      {\n        type: 'toggle',\n        label: 'Multiline mode',\n        dataKey: 'multilineMode',\n      },\n      {\n        type: 'code',\n        label: 'Regex',\n        dataKey: 'regex',\n        useInputToggleDataKey: 'useRegexInput',\n        language: 'regex',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.useRegexInput ? '(Using regex input)' : this.data.regex;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Extracts data from the input text using the configured regular expression. The regular expression can contain capture groups to extract specific parts of the text.\n\n        Each capture group corresponds to an output port of the node.\n      `,\n      infoBoxTitle: 'Extract With Regex Node',\n      contextMenuTitle: 'Extract With Regex',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const inputString = expectType(inputs['input' as PortId], 'string');\n    const regex = expectTypeOptional(inputs['regex' as PortId], 'string') ?? this.chartNode.data.regex;\n\n    const regExp = new RegExp(regex, this.data.multilineMode ? 'gm' : 'g');\n\n    let matches = [];\n    let match;\n    let firstMatch;\n\n    while ((match = regExp.exec(inputString)) !== null) {\n      if (!firstMatch) {\n        firstMatch = match;\n      }\n      matches.push(match[1]!);\n    }\n\n    matches = matches.filter((m) => m);\n\n    if (matches.length === 0 && this.chartNode.data.errorOnFailed) {\n      throw new Error(`No match found for regex ${regex}`);\n    }\n\n    const outputArray: DataValue = {\n      type: 'string[]',\n      value: matches,\n    };\n\n    if (!firstMatch) {\n      if (this.chartNode.data.errorOnFailed) {\n        throw new Error(`No match found for regex ${regex}`);\n      }\n      return {\n        ['succeeded' as PortId]: {\n          type: 'boolean',\n          value: false,\n        },\n        ['failed' as PortId]: {\n          type: 'boolean',\n          value: true,\n        },\n      };\n    }\n\n    const output: Record<PortId, DataValue> = {};\n\n    for (let i = 1; i < firstMatch.length; i++) {\n      output[`output${i}` as PortId] = {\n        type: 'string',\n        value: firstMatch[i]!,\n      };\n    }\n\n    output['matches' as PortId] = outputArray;\n\n    output['succeeded' as PortId] = {\n      type: 'boolean',\n      value: true,\n    };\n    output['failed' as PortId] = {\n      type: 'boolean',\n      value: false,\n    };\n\n    return output;\n  }\n}\n\nfunction countCaptureGroups(regex: RegExp): number {\n  const regexSource = regex.source;\n  let count = 0;\n  let inCharacterClass = false;\n\n  for (let i = 0; i < regexSource.length; i++) {\n    const currentChar = regexSource[i];\n    const prevChar = i > 0 ? regexSource[i - 1] : null;\n\n    if (currentChar === '[' && prevChar !== '\\\\') {\n      inCharacterClass = true;\n    } else if (currentChar === ']' && prevChar !== '\\\\') {\n      inCharacterClass = false;\n    } else if (currentChar === '(' && prevChar !== '\\\\' && !inCharacterClass) {\n      if (regexSource[i + 1] !== '?' || regexSource[i + 2] === ':') {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n\nexport const extractRegexNode = nodeDefinition(ExtractRegexNodeImpl, 'Extract Regex');\n"]},{"id":"IQ3Wvf0qRgdnx0RFgLS8y","data":["NumberNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type NumberNode = ChartNode<'number', NumberNodeData>;\n\nexport type NumberNodeData = {\n  value?: number;\n  useValueInput?: boolean;\n  round?: boolean;\n  roundTo?: number;\n};\n\nexport class NumberNodeImpl extends NodeImpl<NumberNode> {\n  static create(): NumberNode {\n    const chartNode: NumberNode = {\n      type: 'number',\n      title: 'Number',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        value: 0,\n        round: false,\n        roundTo: 0,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return this.data.useValueInput\n      ? [\n          {\n            dataType: 'any',\n            id: 'input' as PortId,\n            title: 'Input',\n          },\n        ]\n      : [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'number',\n        id: 'value' as PortId,\n        title: 'Value',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<NumberNode>[] {\n    return [\n      { type: 'number', label: 'Value', dataKey: 'value', useInputToggleDataKey: 'useValueInput' },\n      { type: 'toggle', label: 'Round', dataKey: 'round' },\n      { type: 'number', label: 'Round To', dataKey: 'roundTo' },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return this.data.useValueInput ? `(Input to number)` : (this.data.value ?? 0).toLocaleString();\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Outputs a number constant, or converts an input value into a number.\n\n        Can be configured to round the number to a certain number of decimal places.\n      `,\n      infoBoxTitle: 'Number Node',\n      contextMenuTitle: 'Number',\n      group: ['Numbers'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    let value = this.data.useValueInput\n      ? coerceTypeOptional(inputs['input' as PortId], 'number') ?? this.data.value ?? 0\n      : this.data.value ?? 0;\n\n    const { roundTo = 0, round = false } = this.data;\n\n    if (round) {\n      value = Math.round(value * Math.pow(10, roundTo)) / Math.pow(10, roundTo);\n    }\n\n    return {\n      ['value' as PortId]: {\n        type: 'number',\n        value,\n      },\n    };\n  }\n}\n\nexport const numberNode = nodeDefinition(NumberNodeImpl, 'Number');\n"]},{"id":"iPJkX2Uonln6iNLaez0wC","data":["CommentNode.ts","import { type ChartNode, type NodeId, type NodeInputDefinition, type NodeOutputDefinition } from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { type DataValue } from '../DataValue.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type CommentNode = ChartNode<'comment', CommentNodeData>;\n\nexport type CommentNodeData = {\n  text: string;\n  color?: string;\n  backgroundColor?: string;\n  height: number;\n};\n\nexport class CommentNodeImpl extends NodeImpl<CommentNode> {\n  static create(): CommentNode {\n    const chartNode: CommentNode = {\n      type: 'comment',\n      title: 'Comment',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 600,\n      },\n      data: {\n        text: '',\n        height: 600,\n        color: 'rgba(255,255,255,1)',\n        backgroundColor: 'rgba(0,0,0,0.05)',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [];\n  }\n\n  getEditors(): EditorDefinition<CommentNode>[] {\n    return [\n      {\n        type: 'color',\n        label: 'Color',\n        dataKey: 'color',\n      },\n      {\n        type: 'color',\n        label: 'Background Color',\n        dataKey: 'backgroundColor',\n      },\n      {\n        type: 'code',\n        label: 'Text',\n        dataKey: 'text',\n        language: 'markdown',\n        theme: 'vs-dark',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        A comment node is a node that does nothing. It is useful for adding notes to a graph.\n      `,\n      infoBoxTitle: 'Comment Node',\n      contextMenuTitle: 'Comment',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(): Promise<Record<string, DataValue>> {\n    return {};\n  }\n}\n\nexport const commentNode = nodeDefinition(CommentNodeImpl, 'Comment');\n"]},{"id":"p-l3m3XVRr-NRDiN3zIZY","data":["ReplaceDatasetNode.ts","import type { ChartNode, NodeId, PortId, NodeInputDefinition, NodeOutputDefinition } from '../NodeBase.js';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { nanoid } from 'nanoid/non-secure';\n\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { getInputOrData, coerceType, newId, inferType } from '../../utils/index.js';\nimport { arrayizeDataValue, unwrapDataValue } from '../DataValue.js';\nimport type { DatasetId, DatasetRow } from '../Dataset.js';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\n\nexport type ReplaceDatasetNode = ChartNode<'replaceDataset', ReplaceDatasetNodeData>;\n\ntype ReplaceDatasetNodeData = {\n  datasetId: DatasetId;\n  useDatasetIdInput?: boolean;\n};\n\nexport class ReplaceDatasetNodeImpl extends NodeImpl<ReplaceDatasetNode> {\n  static create(): ReplaceDatasetNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'replaceDataset',\n      title: 'Replace Dataset',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        datasetId: '' as DatasetId,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    inputDefinitions.push({\n      id: 'data' as PortId,\n      dataType: 'object[]',\n      title: 'Data',\n      description:\n        'The new data of the dataset. If empty, the dataset will be cleared. May be an array of array of strings, or an array of DatasetRow objects with { id, data } properties. If a string[][], IDs will be generated.',\n    });\n\n    if (this.data.useDatasetIdInput) {\n      inputDefinitions.push({\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n        description: 'The ID of the dataset to replace.',\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'dataset' as PortId,\n        title: 'Dataset',\n        dataType: 'object[]',\n        description: 'The new data of the dataset. An array of DatasetRow objects with { id, data } properties.',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Replaces the data in a dataset with the given data. If no data is given, the dataset will be cleared instead.\n      `,\n      infoBoxTitle: 'Replace Dataset Node',\n      contextMenuTitle: 'Replace Dataset',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<ReplaceDatasetNode>[] | Promise<EditorDefinition<ReplaceDatasetNode>[]> {\n    return [\n      {\n        type: 'datasetSelector',\n        label: 'Dataset',\n        dataKey: 'datasetId',\n        useInputToggleDataKey: 'useDatasetIdInput',\n      },\n    ];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId = getInputOrData(this.data, inputs, 'datasetId', 'string') as DatasetId;\n    const dataInput = inputs['data' as PortId];\n\n    if (!dataInput) {\n      await datasetProvider.putDatasetData(datasetId, { id: datasetId, rows: [] });\n      return {\n        ['dataset' as PortId]: {\n          type: 'object[]',\n          value: [],\n        },\n      };\n    }\n\n    let dataArrays = unwrapDataValue(dataInput).value as unknown[][] | unknown[] | DatasetRow[];\n    if (!Array.isArray(dataArrays)) {\n      throw new Error('Data input must be either an array of rows, or an array of columns for a single row.');\n    }\n\n    const isDatasetRow = (row: unknown): row is DatasetRow => {\n      return typeof row === 'object' && row != null && 'id' in row && 'data' in row;\n    };\n\n    const firstElem = dataArrays[0];\n    if (!Array.isArray(firstElem) && !isDatasetRow(firstElem)) {\n      dataArrays = [dataArrays as unknown[]];\n    }\n\n    const rows = (dataArrays as unknown[][] | DatasetRow[]).map((row): DatasetRow => {\n      if (Array.isArray(row)) {\n        return {\n          id: newId(),\n          data: row.map((value) => coerceType(inferType(value), 'string')),\n        };\n      }\n\n      if ('id' in row && 'data' in row) {\n        return row;\n      }\n\n      throw new Error('Data input must be an array of strings or DatasetRows');\n    });\n\n    await datasetProvider.putDatasetData(datasetId, {\n      id: datasetId,\n      rows,\n    });\n\n    return {\n      ['dataset' as PortId]: {\n        type: 'object[]',\n        value: rows,\n      },\n    };\n  }\n}\n\nexport const replaceDatasetNode = nodeDefinition(ReplaceDatasetNodeImpl, 'Replace Dataset');\n"]},{"id":"JhxYou5Fv605bVU8q0jBU","data":["ExternalCallNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type AnyDataValue, type ArrayDataValue } from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { getError } from '../../utils/errors.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { omit } from 'lodash-es';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type ExternalCallNode = ChartNode<'externalCall', ExternalCallNodeData>;\n\nexport type ExternalCallNodeData = {\n  functionName: string;\n  useFunctionNameInput: boolean;\n  useErrorOutput: boolean;\n};\n\nexport class ExternalCallNodeImpl extends NodeImpl<ExternalCallNode> {\n  static create(): ExternalCallNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'externalCall',\n      title: 'External Call',\n      visualData: { x: 0, y: 0, width: 150 },\n      data: {\n        functionName: '',\n        useFunctionNameInput: false,\n        useErrorOutput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useFunctionNameInput) {\n      inputDefinitions.push({\n        id: 'functionName' as PortId,\n        title: 'Function Name',\n        dataType: 'string',\n      });\n    }\n\n    inputDefinitions.push({\n      id: 'arguments' as PortId,\n      title: 'Arguments',\n      dataType: 'any[]',\n    });\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'result' as PortId,\n        title: 'Result',\n        dataType: 'any',\n      },\n    ];\n\n    if (this.chartNode.data.useErrorOutput) {\n      outputs.push({\n        id: 'error' as PortId,\n        title: 'Error',\n        dataType: 'string',\n      });\n    }\n\n    return outputs;\n  }\n\n  getEditors(): EditorDefinition<ExternalCallNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Function Name',\n        dataKey: 'functionName',\n        useInputToggleDataKey: 'useFunctionNameInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Use Error Output',\n        dataKey: 'useErrorOutput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return this.data.useFunctionNameInput ? '(Using Input)' : this.data.functionName;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Provides a way to call into the host project from inside a Rivet graph when Rivet graphs are integrated into another project.\n      `,\n      infoBoxTitle: 'External Call Node',\n      contextMenuTitle: 'External Call',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const functionName = this.chartNode.data.useFunctionNameInput\n      ? coerceType(inputs['functionName' as PortId], 'string')\n      : this.chartNode.data.functionName;\n\n    const args = inputs['arguments' as PortId];\n    let arrayArgs: ArrayDataValue<AnyDataValue> = {\n      type: 'any[]',\n      value: [],\n    };\n\n    if (args) {\n      if (args.type.endsWith('[]') === false) {\n        arrayArgs = {\n          type: 'any[]',\n          value: [args.value],\n        };\n      } else {\n        arrayArgs = args as ArrayDataValue<AnyDataValue>;\n      }\n    }\n\n    const fn = context.externalFunctions[functionName];\n    const externalContext = omit(context, ['setGlobal']);\n\n    if (!fn) {\n      if (this.data.useErrorOutput) {\n        return {\n          ['result' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n          ['error' as PortId]: {\n            type: 'string',\n            value: `Function ${functionName} not was not defined using setExternalCall`,\n          },\n        };\n      } else {\n        throw new Error(`Function ${functionName} not was not defined using setExternalCall`);\n      }\n    }\n\n    if (this.data.useErrorOutput) {\n      try {\n        const result = await fn(externalContext, ...arrayArgs.value);\n        return {\n          ['result' as PortId]: result,\n          ['cost' as PortId]: {\n            type: 'number',\n            value: result.cost ?? 0,\n          },\n          ['error' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n        };\n      } catch (error) {\n        return {\n          ['result' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n          ['error' as PortId]: {\n            type: 'string',\n            value: getError(error).message,\n          },\n        };\n      }\n    }\n    const result = await fn(externalContext, ...arrayArgs.value);\n    return {\n      ['result' as PortId]: result,\n    };\n  }\n}\n\nexport const externalCallNode = nodeDefinition(ExternalCallNodeImpl, 'External Call');\n"]},{"id":"NWvSECQnD7nCgUE04b1zX","data":["FilterNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type DataValue } from '../../index.js';\nimport { zip } from 'lodash-es';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type FilterNode = ChartNode<'filter', FilterNodeData>;\n\nexport type FilterNodeData = {};\n\nexport class FilterNodeImpl extends NodeImpl<FilterNode> {\n  static create(): FilterNode {\n    const chartNode: FilterNode = {\n      type: 'filter',\n      title: 'Filter',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'array' as PortId,\n        title: 'Array',\n        dataType: 'any[]',\n        required: true,\n      },\n      {\n        id: 'include' as PortId,\n        title: 'Include',\n        dataType: 'boolean[]',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'filtered' as PortId,\n        title: 'Filtered',\n        dataType: 'any[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in both an array of values, and an array of booleans of the same length, and filters the array where the corresponding boolean is true.\n      `,\n      infoBoxTitle: 'Filter Node',\n      contextMenuTitle: 'Filter',\n      group: ['Lists'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const array = coerceType(inputs['array' as PortId], 'any[]');\n    const include = coerceType(inputs['include' as PortId], 'boolean[]');\n\n    const zipped = zip(array, include);\n\n    const filtered = zipped.filter(([_, include]) => include).map(([value, _]) => value);\n\n    return {\n      ['filtered' as PortId]: {\n        type: inputs['array' as PortId]?.type ?? 'any',\n        value: filtered,\n      } as DataValue,\n    };\n  }\n}\n\nexport const filterNode = nodeDefinition(FilterNodeImpl, 'Filter');\n"]},{"id":"FPyZoWqw4IQ4fz39gzRJs","data":["SetGlobalNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type DataType,\n  type ScalarDataValue,\n  isArrayDataType,\n  isScalarDataType,\n  scalarDefaults,\n  unwrapDataValue,\n} from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/coerceType.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\n\nexport type SetGlobalNode = ChartNode<'setGlobal', SetGlobalNodeData>;\n\nexport type SetGlobalNodeData = {\n  id: string;\n  useIdInput: boolean;\n  dataType: DataType;\n};\n\nexport class SetGlobalNodeImpl extends NodeImpl<SetGlobalNode> {\n  static create(): SetGlobalNode {\n    const chartNode: SetGlobalNode = {\n      type: 'setGlobal',\n      title: 'Set Global',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        id: 'variable-name',\n        dataType: 'string',\n        useIdInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs = [\n      {\n        id: 'value' as PortId,\n        title: 'Value',\n        dataType: this.chartNode.data.dataType as DataType,\n      },\n    ];\n\n    if (this.data.useIdInput) {\n      inputs.push({\n        id: 'id' as PortId,\n        title: 'Variable ID',\n        dataType: 'string',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'saved-value' as PortId,\n        title: 'Value',\n        dataType: this.data.dataType,\n      },\n      {\n        id: 'previous-value' as PortId,\n        title: 'Previous Value',\n        dataType: this.data.dataType,\n      },\n      {\n        id: 'variable_id_out' as PortId,\n        title: 'Variable ID',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<SetGlobalNode>[] {\n    return [\n      {\n        type: 'string',\n        dataKey: 'id',\n        useInputToggleDataKey: 'useIdInput',\n        label: 'ID',\n      },\n      {\n        type: 'dataTypeSelector',\n        dataKey: 'dataType',\n        label: 'Data Type',\n        useInputToggleDataKey: 'useIdInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      ${this.data.id}\n      Type: ${this.data.dataType}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Sets a global value that is shared across all graphs and subgraphs. The id of the global value and the value itself are configured in this node.\n      `,\n      infoBoxTitle: 'Set Global Node',\n      contextMenuTitle: 'Set Global',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const rawValue = inputs['value' as PortId]!;\n    if (!rawValue) {\n      return {};\n    }\n\n    const id = this.data.useIdInput ? coerceType(inputs['id' as PortId], 'string') : this.data.id;\n\n    if (!id) {\n      throw new Error('Missing variable ID');\n    }\n\n    let previousValue = context.getGlobal(this.data.id);\n    if (!previousValue && isArrayDataType(this.data.dataType)) {\n      previousValue = { type: this.data.dataType, value: [] };\n    } else if (!previousValue && isScalarDataType(this.data.dataType)) {\n      previousValue = { type: this.data.dataType, value: scalarDefaults[this.data.dataType] } as ScalarDataValue;\n    }\n\n    const value = unwrapDataValue(rawValue);\n\n    context.setGlobal(id, value);\n\n    return {\n      ['saved-value' as PortId]: value,\n      ['previous-value' as PortId]: previousValue,\n      ['variable_id_out' as PortId]: { type: 'string', value: id },\n    };\n  }\n}\n\nexport const setGlobalNode = nodeDefinition(SetGlobalNodeImpl, 'Set Global');\n"]},{"id":"RS89pXQB6WuaRyGHPWO4w","data":["CodeNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { type DataValue } from '../DataValue.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../EditorDefinition.js';\nimport { type NodeBodySpec } from '../NodeBodySpec.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { InternalProcessContext } from '../ProcessContext.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\n\nexport type CodeNode = ChartNode<'code', CodeNodeData>;\n\nconst maskInput = (name: string) => name.trim().replace(/[^a-zA-Z0-9_]/g, '_');\nconst asValidNames = (names: string[]): string[] => Array(...new Set(names.map(maskInput))).filter(Boolean);\n\nexport type CodeNodeData = {\n  code: string;\n  inputNames: string | string[];\n  outputNames: string | string[];\n  allowFetch?: boolean;\n  allowRequire?: boolean;\n  allowRivet?: boolean;\n  allowProcess?: boolean;\n  allowConsole?: boolean;\n};\n\nexport class CodeNodeImpl extends NodeImpl<CodeNode> {\n  static create(): CodeNode {\n    const chartNode: CodeNode = {\n      type: 'code',\n      title: 'Code',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n      },\n      data: {\n        code: dedent`\n          // This is a code node, you can write and JS in here and it will be executed.\n          // Inputs are accessible via an object \\`inputs\\` and data is typed (i.e. inputs.foo.type, inputs.foo.value)\n          // Return an object with named outputs that match the output names specified in the node's config.\n          // Output values must by typed as well (e.g. { bar: { type: 'string', value: 'bar' } }\n          return {\n            output1: {\n              type: inputs.input1.type,\n              value: inputs.input1.value\n            }\n          };\n        `,\n        inputNames: 'input1',\n        outputNames: 'output1',\n        allowFetch: false,\n        allowRequire: false,\n        allowRivet: false,\n        allowProcess: false,\n        allowConsole: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputNames = this.data.inputNames\n      ? Array.isArray(this.data.inputNames)\n        ? this.data.inputNames\n        : [this.data.inputNames]\n      : [];\n\n    return asValidNames(inputNames).map((inputName) => {\n      return {\n        type: 'any',\n        id: inputName.trim() as PortId,\n        title: inputName.trim(),\n        dataType: 'string',\n        required: false,\n      };\n    });\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputNames = this.data.outputNames\n      ? Array.isArray(this.data.outputNames)\n        ? this.data.outputNames\n        : [this.data.outputNames]\n      : [];\n\n    return asValidNames(outputNames).map((outputName) => {\n      return {\n        id: outputName.trim() as PortId,\n        title: outputName.trim(),\n        dataType: 'any',\n      };\n    });\n  }\n\n  getEditors(): EditorDefinition<CodeNode>[] {\n    return [\n      {\n        type: 'custom',\n        customEditorId: 'CodeNodeAIAssist',\n        label: 'AI Assist',\n      },\n      {\n        type: 'code',\n        label: 'Code',\n        dataKey: 'code',\n        language: 'javascript',\n      },\n      {\n        type: 'stringList',\n        label: 'Inputs',\n        dataKey: 'inputNames',\n      },\n      {\n        type: 'stringList',\n        label: 'Outputs',\n        dataKey: 'outputNames',\n      },\n      {\n        type: 'toggle',\n        label: 'Allow using `fetch`',\n        dataKey: 'allowFetch',\n      },\n      {\n        type: 'toggle',\n        label: 'Allow using `require`',\n        dataKey: 'allowRequire',\n        helperMessage: 'This is only available when using the Node executor.',\n      },\n      {\n        type: 'toggle',\n        label: 'Allow using `Rivet`',\n        dataKey: 'allowRivet',\n      },\n      {\n        type: 'toggle',\n        label: 'Allow using `process`',\n        dataKey: 'allowProcess',\n        helperMessage: 'This is only available when using the Node executor.',\n      },\n      {\n        type: 'toggle',\n        label: 'Allow using `console`',\n        dataKey: 'allowConsole',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    const trimmed = this.data.code\n      .split('\\n')\n      .slice(0, 15)\n      .map((line) => (line.length > 50 ? line.slice(0, 50) + '...' : line))\n      .join('\\n')\n      .trim();\n\n    return {\n      type: 'colorized',\n      text: trimmed,\n      language: 'javascript',\n      fontSize: 12,\n      fontFamily: 'monospace',\n    };\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Executes a piece of JavaScript code. See the Rivet Documentation for more information on how to write code for the Code Node.\n      `,\n      infoBoxTitle: 'Code Node',\n      contextMenuTitle: 'Code',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const outputs = await context.codeRunner.runCode(this.data.code, inputs, {\n      includeFetch: this.data.allowFetch ?? false,\n      includeRequire: this.data.allowRequire ?? false,\n      includeRivet: this.data.allowRivet ?? false,\n      includeProcess: this.data.allowProcess ?? false,\n      includeConsole: this.data.allowConsole ?? false,\n    });\n\n    if (outputs == null || typeof outputs !== 'object' || ('then' in outputs && typeof outputs.then === 'function')) {\n      throw new Error('Code node must return an object with output values.');\n    }\n\n    const missingOutputs = this.getOutputDefinitions().filter((output) => !(output.id in outputs));\n    if (missingOutputs.length > 0) {\n      throw new Error(\n        `Code node must return an object with output values for all outputs. To not run an output, return { \"type\": \"control-flow-excluded\", \"value\": undefiend }. To return undefined, return { \"type\": \"any\", \"value\": undefined }. Missing: ${missingOutputs\n          .map((output) => output.id)\n          .join(', ')}`,\n      );\n    }\n\n    return outputs;\n  }\n}\n\nexport const codeNode = nodeDefinition(CodeNodeImpl, 'Code');\n"]},{"id":"HR7QfJ-qGuu68AefPgF1I","data":["ImageNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport {\n  type DataRef,\n  type EditorDefinition,\n  type Inputs,\n  type InternalProcessContext,\n  type Outputs,\n} from '../../index.js';\nimport { base64ToUint8Array } from '../../utils/base64.js';\nimport { expectType } from '../../utils/expectType.js';\n\nexport type ImageNode = ChartNode<'image', ImageNodeData>;\n\ntype ImageNodeData = {\n  data?: DataRef;\n  useDataInput: boolean;\n  mediaType: 'image/png' | 'image/jpeg' | 'image/gif';\n  useMediaTypeInput: boolean;\n};\n\nexport class ImageNodeImpl extends NodeImpl<ImageNode> {\n  static create(): ImageNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'image',\n      title: 'Image',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        useDataInput: false,\n        mediaType: 'image/png',\n        useMediaTypeInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.useDataInput) {\n      inputDefinitions.push({\n        id: 'data' as PortId,\n        title: 'Data',\n        dataType: 'binary',\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useMediaTypeInput) {\n      inputDefinitions.push({\n        id: 'mediaType' as PortId,\n        title: 'Media Type',\n        dataType: 'string',\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'image' as PortId,\n        title: 'Image',\n        dataType: 'image',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ImageNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Media Type',\n        dataKey: 'mediaType',\n        options: [\n          { value: 'image/png', label: 'PNG' },\n          { value: 'image/jpeg', label: 'JPEG' },\n          { value: 'image/gif', label: 'GIF' },\n        ],\n        useInputToggleDataKey: 'useMediaTypeInput',\n      },\n      {\n        type: 'imageBrowser',\n        label: 'Image',\n        dataKey: 'data',\n        useInputToggleDataKey: 'useDataInput',\n        mediaTypeDataKey: 'mediaType',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      contextMenuTitle: 'Image',\n      group: 'Data',\n      infoBoxTitle: 'Image Node',\n      infoBoxBody: 'Defines a static image for use with other nodes. Can convert a binary type into an image type.',\n    };\n  }\n\n  async process(inputData: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    let data: Uint8Array;\n\n    if (this.chartNode.data.useDataInput) {\n      data = expectType(inputData['data' as PortId], 'binary');\n    } else {\n      const dataRef = this.data.data?.refId;\n      if (!dataRef) {\n        throw new Error('No data ref');\n      }\n\n      const encodedData = context.project.data?.[dataRef] as string;\n\n      if (!encodedData) {\n        throw new Error(`No data at ref ${dataRef}`);\n      }\n\n      data = base64ToUint8Array(encodedData);\n    }\n\n    const mediaType = this.chartNode.data.useMediaTypeInput\n      ? expectType(inputData['mediaType' as PortId], 'string')\n      : this.chartNode.data.mediaType;\n\n    return {\n      ['image' as PortId]: {\n        type: 'image',\n        value: { mediaType: mediaType as 'image/png' | 'image/jpeg' | 'image/gif', data },\n      },\n    };\n  }\n}\n\nexport const imageNode = nodeDefinition(ImageNodeImpl, 'Image');\n"]},{"id":"9E9tiH4zCv2ImsbamIMyD","data":["IfElseNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { type ArrayDataValue, type DataValue, type ScalarDataValue } from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type IfElseNode = ChartNode<'ifElse', IfElseNodeData>;\n\nexport type IfElseNodeData = {\n  /** If true, unconnected input ports are control-flow-excluded. */\n  unconnectedControlFlowExcluded?: boolean;\n};\n\nexport class IfElseNodeImpl extends NodeImpl<IfElseNode> {\n  static create = (): IfElseNode => {\n    const chartNode: IfElseNode = {\n      type: 'ifElse',\n      title: 'If/Else',\n      id: nanoid() as NodeId,\n      data: {\n        // Legacy behavior is false\n        unconnectedControlFlowExcluded: true,\n      },\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n    };\n    return chartNode;\n  };\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'if' as PortId,\n        title: 'If',\n        dataType: 'any',\n        description:\n          'If this is truthy, the `true` value will be passed through the output port. Otherwise, the `false` value will be passed through the output port. An unconnected port is considered false. A `Not Ran` value is considered false.',\n      },\n      {\n        id: 'true' as PortId,\n        title: 'True',\n        dataType: 'any',\n        description: 'The value to pass through the output port if the condition is truthy. ',\n      },\n      {\n        id: 'false' as PortId,\n        title: 'False',\n        dataType: 'any',\n        description: 'The value to pass through the output port if the condition is not truthy.',\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'Output',\n        dataType: 'any',\n        description: 'The `true` or `false` value, depending on the `if` condition.',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in three inputs: a condition, a true value, and a false value. If the condition is truthy, the true value is passed through the output port. If the condition is not truthy, the false value is passed through the output port.\n\n        This node can \"consume\" a \\`Not Ran\\` to continue a graph from that point.\n      `,\n      infoBoxTitle: 'If/Else Node',\n      contextMenuTitle: 'If/Else',\n      group: ['Logic'],\n    };\n  }\n\n  getEditors(): EditorDefinition<IfElseNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: \"Don't run unconnected ports\",\n        dataKey: 'unconnectedControlFlowExcluded',\n      },\n    ];\n  }\n\n  async process(inputData: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const unconnectedValue: DataValue = this.data.unconnectedControlFlowExcluded\n      ? { type: 'control-flow-excluded', value: undefined }\n      : {\n          type: 'any',\n          value: undefined,\n        };\n\n    const ifValue = inputData['if' as PortId];\n    const trueValue = inputData['true' as PortId] ?? unconnectedValue;\n    const falseValue = inputData['false' as PortId] ?? unconnectedValue;\n\n    if (!(trueValue || falseValue)) {\n      return {\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    if (ifValue?.type === 'control-flow-excluded') {\n      return {\n        ['output' as PortId]: falseValue,\n      };\n    }\n\n    if (ifValue?.value == null) {\n      return {\n        ['output' as PortId]: falseValue,\n      };\n    }\n\n    if (ifValue?.type && ifValue.type === 'boolean') {\n      return {\n        ['output' as PortId]: ifValue.value ? trueValue : falseValue,\n      };\n    }\n\n    if (ifValue?.type === 'string') {\n      return {\n        ['output' as PortId]: ifValue.value.length > 0 ? trueValue : falseValue,\n      };\n    }\n\n    if (ifValue?.type === 'chat-message') {\n      const asString = coerceType(ifValue, 'string');\n\n      return {\n        ['output' as PortId]: asString ? trueValue : falseValue,\n      };\n    }\n\n    if (ifValue?.type.endsWith('[]')) {\n      return {\n        ['output' as PortId]: (ifValue as ArrayDataValue<ScalarDataValue>).value.length > 0 ? trueValue : falseValue,\n      };\n    }\n\n    if (ifValue?.type === 'any' || ifValue?.type === 'object') {\n      return {\n        ['output' as PortId]: !!ifValue.value ? trueValue : falseValue,\n      };\n    }\n\n    return {\n      ['output' as PortId]: falseValue,\n    };\n  }\n}\n\nexport const ifElseNode = nodeDefinition(IfElseNodeImpl, 'If/Else');\n"]},{"id":"IX92lNjfxviyNiTLh41EH","data":["HashNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type EditorDefinition, type Inputs, type Outputs } from '../../index.js';\nimport * as crypto from 'crypto-js';\nimport { match } from 'ts-pattern';\nimport { dedent } from 'ts-dedent';\nimport { coerceType } from '../../utils/coerceType.js';\n\nconst { SHA256, SHA512, MD5, SHA1 } = crypto;\n\nexport type HashNode = ChartNode<'hash', HashNodeData>;\n\nexport type HashNodeData = {\n  algorithm: 'md5' | 'sha1' | 'sha256' | 'sha512';\n};\n\nexport class HashNodeImpl extends NodeImpl<HashNode> {\n  static create(): HashNode {\n    const chartNode: HashNode = {\n      type: 'hash',\n      title: 'Hash',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        algorithm: 'sha256',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'hash' as PortId,\n        title: 'Hash',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<HashNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Algorithm',\n        dataKey: 'algorithm',\n        options: [\n          { value: 'md5', label: 'MD5' },\n          { value: 'sha1', label: 'SHA1' },\n          { value: 'sha256', label: 'SHA256' },\n          { value: 'sha512', label: 'SHA512' },\n        ],\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return algorithmDisplayName[this.data.algorithm];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Computes a hash of the input value using the configured hash function.\n      `,\n      infoBoxTitle: 'Hash Node',\n      contextMenuTitle: 'Hash',\n      group: ['Data'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const inputText = coerceType(inputs['input' as PortId], 'string');\n\n    const hash = match(this.data.algorithm)\n      .with('md5', () => MD5(inputText).toString())\n      .with('sha1', () => SHA1(inputText).toString())\n      .with('sha256', () => SHA256(inputText).toString())\n      .with('sha512', () => SHA512(inputText).toString())\n      .exhaustive();\n\n    return {\n      ['hash' as PortId]: {\n        type: 'string',\n        value: hash,\n      },\n    };\n  }\n}\n\nconst algorithmDisplayName: Record<HashNodeData['algorithm'], string> = {\n  md5: 'MD5',\n  sha1: 'SHA-1',\n  sha256: 'SHA-256',\n  sha512: 'SHA-512',\n};\n\nexport const hashNode = nodeDefinition(HashNodeImpl, 'Hash');\n"]},{"id":"D8zOEjXNv-7RKF-V04GQI","data":["ToYamlNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\n// @ts-ignore\nimport yaml from 'yaml';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { coerceType } from '../../utils/index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type ToYamlNode = ChartNode<'toYaml', ToYamlNodeData>;\n\nexport type ToYamlNodeData = {};\n\nexport class ToYamlNodeImpl extends NodeImpl<ToYamlNode> {\n  static create(): ToYamlNode {\n    const chartNode: ToYamlNode = {\n      type: 'toYaml',\n      title: 'To YAML',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'object' as PortId,\n        title: 'Object',\n        dataType: 'object',\n        required: true,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'yaml' as PortId,\n        title: 'YAML',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Turns the input object into YAML text.\n      `,\n      infoBoxTitle: 'To YAML Node',\n      contextMenuTitle: 'To YAML',\n      group: ['Text'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const object = coerceType(inputs['object' as PortId], 'object');\n\n    const toYaml = yaml.stringify(object, null, {\n      indent: 2,\n      aliasDuplicateObjects: false,\n    });\n\n    return {\n      ['yaml' as PortId]: {\n        type: 'string',\n        value: toYaml,\n      },\n    };\n  }\n}\n\nexport const toYamlNode = nodeDefinition(ToYamlNodeImpl, 'To YAML');\n"]},{"id":"2NYZyw4nbAKoO_3kQZiJU","data":["RandomNumberNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\n\nexport type RandomNumberNode = ChartNode<'randomNumber', RandomNumberNodeData>;\n\nexport type RandomNumberNodeData = {\n  min?: number;\n  max?: number;\n  integers?: boolean;\n  maxInclusive?: boolean;\n  useMinInput?: boolean;\n  useMaxInput?: boolean;\n};\n\nexport class RandomNumberNodeImpl extends NodeImpl<RandomNumberNode> {\n  static create(): RandomNumberNode {\n    const chartNode: RandomNumberNode = {\n      type: 'randomNumber',\n      title: 'RNG',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 150,\n      },\n      data: {\n        min: 0,\n        max: 1,\n        integers: false,\n        maxInclusive: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    if (this.data.useMinInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'min' as PortId,\n        title: 'Min',\n      });\n    }\n    if (this.data.useMaxInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'max' as PortId,\n        title: 'Max',\n      });\n    }\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'number',\n        id: 'value' as PortId,\n        title: 'Value',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<RandomNumberNode>[] {\n    return [\n      { type: 'number', label: 'Min', dataKey: 'min', useInputToggleDataKey: 'useMinInput' },\n      { type: 'number', label: 'Max', dataKey: 'max', useInputToggleDataKey: 'useMaxInput' },\n      { type: 'toggle', label: 'Integers', dataKey: 'integers' },\n      { type: 'toggle', label: 'Max Inclusive', dataKey: 'maxInclusive' },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return dedent`\n      Min: ${this.data.useMinInput ? '(Input)' : this.data.min ?? 0}\n      Max: ${this.data.useMaxInput ? '(Input)' : this.data.max ?? 1}\n      ${this.data.integers ? 'Integers' : 'Floats'}\n      ${this.data.maxInclusive ? 'Max Inclusive' : 'Max Exclusive'}\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Outputs a random number between the configured min and max values.\n\n        Can be configured to output only integers, and whether the max value is inclusive or exclusive.\n      `,\n      infoBoxTitle: 'RNG Node',\n      contextMenuTitle: 'RNG',\n      group: ['Numbers'],\n    };\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const min = this.data.useMinInput\n      ? coerceTypeOptional(inputs['min' as PortId], 'number') ?? this.data.min ?? 0\n      : this.data.min ?? 0;\n\n    let max = this.data.useMaxInput\n      ? coerceTypeOptional(inputs['max' as PortId], 'number') ?? this.data.max ?? 1\n      : this.data.max ?? 1;\n\n    if (this.data.integers && this.data.maxInclusive) {\n      max += 1;\n    }\n    let value = Math.random() * (max - min) + min;\n\n    if (this.data.integers) {\n      value = Math.floor(value);\n    }\n\n    return {\n      ['value' as PortId]: {\n        type: 'number',\n        value,\n      },\n    };\n  }\n}\n\nexport const randomNumberNode = nodeDefinition(RandomNumberNodeImpl, 'Random Number');\n"]},{"id":"jjSI5co7T6a9R_Tt6vAYQ","data":["AssembleMessageNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { type ChatMessage, type ChatMessageMessagePart, arrayizeDataValue, unwrapDataValue } from '../DataValue.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { orderBy } from 'lodash-es';\nimport { coerceTypeOptional, dedent, getInputOrData } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport { match } from 'ts-pattern';\n\nexport type AssembleMessageNode = ChartNode<'assembleMessage', AssembleMessageNodeData>;\n\nexport type AssembleMessageNodeData = {\n  type: 'system' | 'user' | 'assistant' | 'function';\n  useTypeInput: boolean;\n\n  toolCallId: string;\n  useToolCallIdInput?: boolean;\n};\n\nconst messageTypeToTitle: Record<ChatMessage['type'], string> = {\n  assistant: 'Assistant',\n  function: 'Function Tool Call',\n  system: 'System',\n  user: 'User',\n};\n\nexport class AssembleMessageNodeImpl extends NodeImpl<AssembleMessageNode> {\n  static create(): AssembleMessageNode {\n    const chartNode: AssembleMessageNode = {\n      type: 'assembleMessage',\n      title: 'Assemble Message',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        type: 'user',\n        useTypeInput: false,\n        toolCallId: '',\n        useToolCallIdInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const messageCount = this.#getInputPortCount(connections);\n\n    if (this.data.useTypeInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'type' as PortId,\n        title: 'Type',\n        description: 'The type of message to assemble.',\n      });\n    }\n\n    if (this.data.useToolCallIdInput) {\n      inputs.push({\n        dataType: 'string',\n        id: 'toolCallId' as PortId,\n        title: 'Tool Call ID',\n        description: 'The ID of the tool call to associate with the message.',\n      });\n    }\n\n    for (let i = 1; i <= messageCount; i++) {\n      inputs.push({\n        dataType: ['string', 'image', 'string[]', 'image[]', 'object', 'object[]', 'document', 'document[]'] as const,\n        id: `part${i}` as PortId,\n        title: `Part ${i}`,\n        description: 'A part of the message to assemble.',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'chat-message',\n        id: 'message' as PortId,\n        title: 'Message',\n        description: 'The assembled message.',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<AssembleMessageNode>[] {\n    return [\n      {\n        type: 'dropdown',\n        label: 'Type',\n        dataKey: 'type',\n        options: [\n          { value: 'system', label: 'System' },\n          { value: 'user', label: 'User' },\n          { value: 'assistant', label: 'Assistant' },\n          { value: 'function', label: 'Function' },\n        ],\n        defaultValue: 'user',\n        useInputToggleDataKey: 'useTypeInput',\n      },\n      {\n        type: 'string',\n        label: 'Tool Call ID',\n        dataKey: 'toolCallId',\n        useInputToggleDataKey: 'useToolCallIdInput',\n        hideIf: (data) => data.type !== 'function',\n      },\n    ];\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const messageConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('part'),\n    );\n\n    let maxMessageNumber = 0;\n    for (const connection of messageConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('part', ''));\n      if (messageNumber > maxMessageNumber) {\n        maxMessageNumber = messageNumber;\n      }\n    }\n\n    return maxMessageNumber + 1;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Assembles a single chat message from multiple parts. This is similar to a Prompt node, but works with multimodal\n        models, as you can include text, images, and documents in the message.\n      `,\n      infoBoxTitle: 'Assemble Message Node',\n      contextMenuTitle: 'Assemble Message',\n      group: 'AI',\n    };\n  }\n\n  getBody(_context: RivetUIContext): NodeBody | Promise<NodeBody> {\n    return dedent`\n      ${this.data.useTypeInput ? '(Type From Input)' : messageTypeToTitle[this.data.type]}\n      ${\n        this.data.useTypeInput || this.data.type === 'function'\n          ? `Tool Call ID: ${this.data.useToolCallIdInput ? '(From Input)' : this.data.toolCallId}`\n          : ``\n      }\n    `;\n  }\n\n  async process(inputs: Inputs): Promise<Outputs> {\n    const output: Outputs = {};\n\n    const type = getInputOrData(this.data, inputs, 'type');\n\n    type MultiMessage = ChatMessage & { message: ChatMessageMessagePart[] };\n    const outMessage: MultiMessage = match(type)\n      .with(\n        'system',\n        (type): MultiMessage => ({\n          type,\n          message: [],\n        }),\n      )\n      .with(\n        'user',\n        (type): MultiMessage => ({\n          type,\n          message: [],\n        }),\n      )\n      .with(\n        'assistant',\n        (type): MultiMessage => ({\n          type,\n          message: [],\n          function_call: undefined, // Not supported yet in Assemble Message node\n          function_calls: undefined, // Not supported yet in Assemble Message node\n        }),\n      )\n      .with(\n        'function',\n        (type): MultiMessage => ({\n          type,\n          message: [],\n          name: getInputOrData(this.data, inputs, 'toolCallId'),\n        }),\n      )\n      .otherwise(() => {\n        throw new Error(`Invalid type: ${type}`);\n      });\n\n    const inputParts = orderBy(\n      Object.entries(inputs).filter(([key]) => key.startsWith('part')),\n      ([key]) => key,\n      'asc',\n    );\n\n    for (const [, inputPart] of inputParts) {\n      if (!inputPart || inputPart.type === 'control-flow-excluded' || !inputPart.value) {\n        continue;\n      }\n\n      const inPart = arrayizeDataValue(unwrapDataValue(inputPart));\n      for (const message of inPart) {\n        if (message.type === 'string') {\n          outMessage.message.push(message.value);\n        } else if (message.type === 'image') {\n          outMessage.message.push({\n            type: 'image',\n            data: message.value.data,\n            mediaType: message.value.mediaType,\n          });\n        } else if (message.type === 'object') {\n          if (\n            message.value &&\n            'type' in message.value &&\n            message.value.type === 'url_reference' &&\n            typeof message.value.url === 'string'\n          ) {\n            outMessage.message.push({\n              type: 'url',\n              url: message.value.url,\n            });\n          }\n        } else if (message.type === 'document') {\n          outMessage.message.push({\n            type: 'document',\n            data: message.value.data,\n            mediaType: message.value.mediaType,\n            context: message.value.context,\n            title: message.value.title,\n            enableCitations: message.value.enableCitations,\n          });\n        } else {\n          const coerced = coerceTypeOptional(message, 'string');\n\n          if (coerced) {\n            outMessage.message.push(coerced);\n          }\n        }\n      }\n    }\n\n    output['message' as PortId] = {\n      type: 'chat-message',\n      value: outMessage,\n    };\n\n    return output;\n  }\n}\n\nexport const assembleMessageNode = nodeDefinition(AssembleMessageNodeImpl, 'Assemble Prompt');\n"]},{"id":"PiLJY17LR1s3aUKrLzBkz","data":["ListGraphsNode.ts","import type {\n  ChartNode,\n  EditorDefinition,\n  GraphId,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { dedent, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type ListGraphsNode = ChartNode<'listGraphs', ListSubgraphsData>;\n\ntype ListSubgraphsData = {};\n\nexport class ListGraphsNodeImpl extends NodeImpl<ListGraphsNode> {\n  static create(): ListGraphsNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'listGraphs',\n      title: 'List Graphs',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {},\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'graphs' as PortId,\n        title: 'Graphs',\n        dataType: 'graph-reference[]',\n      },\n      {\n        id: 'graph-names' as PortId,\n        title: 'Graph Names',\n        dataType: 'string[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Lists all graphs in the project.\n      `,\n      infoBoxTitle: 'List Graphs Node',\n      contextMenuTitle: 'List Graphs',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<ListGraphsNode>[] | Promise<EditorDefinition<ListGraphsNode>[]> {\n    return [];\n  }\n\n  async process(_inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const graphs = Object.values(context.project.graphs);\n\n    return {\n      ['graphs' as PortId]: {\n        type: 'graph-reference[]',\n        value: graphs.map((graph) => ({\n          graphId: graph.metadata!.id ?? ('' as GraphId),\n          graphName: graph.metadata!.name ?? '',\n        })),\n      },\n      ['graph-names' as PortId]: {\n        type: 'string[]',\n        value: graphs.map((graph) => graph.metadata!.name ?? ''),\n      },\n    };\n  }\n}\n\nexport const listGraphsNode = nodeDefinition(ListGraphsNodeImpl, 'List Graphs');\n"]},{"id":"Zxke5NDKe_il0Q730d3cN","data":["TextNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\nimport { extractInterpolationVariables, interpolate } from '../../utils/interpolation.js';\n\nexport type TextNode = ChartNode<'text', TextNodeData>;\n\nexport type TextNodeData = {\n  text: string;\n};\n\nexport class TextNodeImpl extends NodeImpl<TextNode> {\n  static create(): TextNode {\n    const chartNode: TextNode = {\n      type: 'text',\n      title: 'Text',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {\n        text: '{{input}}',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    // Extract inputs from text, everything like {{input}}\n    const inputNames = extractInterpolationVariables(this.data.text);\n    return (\n      inputNames?.map((inputName) => {\n        return {\n          type: 'string',\n          // id and title should not have the {{ and }}\n          id: inputName as PortId,\n          title: inputName,\n          dataType: 'string',\n          required: false,\n        };\n      }) ?? []\n    );\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'Output',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<TextNode>[] {\n    return [\n      {\n        type: 'custom',\n        label: 'AI Assist',\n        customEditorId: 'TextNodeAiAssist',\n      },\n      {\n        type: 'code',\n        label: 'Text',\n        dataKey: 'text',\n        language: 'prompt-interpolation-markdown',\n        theme: 'prompt-interpolation',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    const truncated = this.data.text.split('\\n').slice(0, 15).join('\\n').trim();\n\n    return {\n      type: 'colorized',\n      language: 'prompt-interpolation-markdown',\n      theme: 'prompt-interpolation',\n      text: truncated,\n    };\n  }\n\n  async process(inputs: Record<string, DataValue>): Promise<Record<string, DataValue>> {\n    const inputMap = Object.keys(inputs).reduce(\n      (acc, key) => {\n        const stringValue = coerceTypeOptional(inputs[key], 'string') ?? '';\n\n        acc[key] = stringValue;\n        return acc;\n      },\n      {} as Record<string, string>,\n    );\n\n    const outputValue = interpolate(this.chartNode.data.text, inputMap);\n\n    return {\n      output: {\n        type: 'string',\n        value: outputValue,\n      },\n    };\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Outputs a string of text. It can also interpolate values using <span style=\"color: var(--primary)\">{{tags}}</span>.\n\n        The inputs are dynamic based on the interpolation tags.\n      `,\n      contextMenuTitle: 'Text',\n      infoBoxTitle: 'Text Node',\n      group: ['Common', 'Text'],\n    };\n  }\n}\n\nexport const textNode = nodeDefinition(TextNodeImpl, 'Text');\n"]},{"id":"fnCHS4E_BKQnzmCPl3dFA","data":["ExtractJsonNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport { expectType } from '../../utils/index.js';\nimport { dedent } from 'ts-dedent';\n\nexport type ExtractJsonNode = ChartNode<'extractJson', ExtractJsonNodeData>;\n\nexport type ExtractJsonNodeData = {};\n\nexport class ExtractJsonNodeImpl extends NodeImpl<ExtractJsonNode> {\n  static create(): ExtractJsonNode {\n    const chartNode: ExtractJsonNode = {\n      type: 'extractJson',\n      title: 'Extract JSON',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'Output',\n        dataType: 'object',\n      },\n      {\n        id: 'noMatch' as PortId,\n        title: 'No Match',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Finds and parses the first JSON object in the input text.\n\n        Outputs the parsed object.\n      `,\n      infoBoxTitle: 'Extract JSON Node',\n      contextMenuTitle: 'Extract JSON',\n      group: ['Objects'],\n    };\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const inputString = expectType(inputs['input' as PortId], 'string');\n\n    try {\n      const parsed = JSON.parse(inputString);\n      return {\n        ['output' as PortId]: {\n          type: 'object',\n          value: parsed,\n        },\n        ['noMatch' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    } catch (_err: unknown) {\n      // Fall back to more manual parsing\n    }\n\n    // Find the first { or [ and the last } or ], and try parsing everything in between including them.\n\n    const firstBracket = inputString.indexOf('{');\n    const lastBracket = inputString.lastIndexOf('}');\n    const firstSquareBracket = inputString.indexOf('[');\n    const lastSquareBracket = inputString.lastIndexOf(']');\n\n    const firstIndex =\n      firstBracket >= 0 && firstSquareBracket >= 0\n        ? Math.min(firstBracket, firstSquareBracket)\n        : firstBracket >= 0\n          ? firstBracket\n          : firstSquareBracket;\n\n    const lastIndex =\n      lastBracket >= 0 && lastSquareBracket >= 0\n        ? Math.max(lastBracket, lastSquareBracket)\n        : lastBracket >= 0\n          ? lastBracket\n          : lastSquareBracket;\n\n    const substring = inputString.substring(firstIndex, lastIndex + 1);\n\n    let jsonObject: Record<string, unknown> | undefined = undefined;\n    try {\n      jsonObject = JSON.parse(substring);\n    } catch (err) {\n      return {\n        ['noMatch' as PortId]: {\n          type: 'string',\n          value: inputString,\n        },\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['output' as PortId]: {\n        type: 'object',\n        value: jsonObject!,\n      },\n      ['noMatch' as PortId]: {\n        type: 'control-flow-excluded',\n        value: undefined,\n      },\n    };\n  }\n}\n\nexport const extractJsonNode = nodeDefinition(ExtractJsonNodeImpl, 'Extract JSON');\n"]},{"id":"ijDJHr7xctkOhHMY4eWX8","data":["ReadDirectoryNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type NodeBodySpec } from '../../index.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { createTreeFromPaths } from '../../utils/paths.js';\nimport { getInputOrData } from '../../utils/inputs.js';\n\nexport type ReadDirectoryNode = ChartNode<'readDirectory', ReadDirectoryNodeData>;\n\ntype ReadDirectoryNodeData = {\n  path: string;\n  usePathInput: boolean;\n\n  recursive: boolean;\n  useRecursiveInput: boolean;\n\n  includeDirectories: boolean;\n  useIncludeDirectoriesInput: boolean;\n\n  filterGlobs: string[];\n  useFilterGlobsInput: boolean;\n\n  relative: boolean;\n  useRelativeInput: boolean;\n\n  ignores?: string[];\n  useIgnoresInput: boolean;\n};\n\ntype TreeNode = {\n  path: string;\n  name: string;\n  isDirectory: boolean;\n  children: TreeNode[];\n};\n\nexport class ReadDirectoryNodeImpl extends NodeImpl<ReadDirectoryNode> {\n  static create(): ReadDirectoryNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'readDirectory',\n      title: 'Read Directory',\n      visualData: { x: 0, y: 0 },\n      data: {\n        path: 'examples',\n        recursive: false,\n        usePathInput: false,\n        useRecursiveInput: false,\n        includeDirectories: false,\n        useIncludeDirectoriesInput: false,\n        filterGlobs: [],\n        useFilterGlobsInput: false,\n        relative: false,\n        useRelativeInput: false,\n        ignores: [],\n        useIgnoresInput: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.usePathInput) {\n      inputDefinitions.push({\n        id: 'path' as PortId,\n        title: 'Path',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useRecursiveInput) {\n      inputDefinitions.push({\n        id: 'recursive' as PortId,\n        title: 'Recursive',\n        dataType: 'boolean',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useIncludeDirectoriesInput) {\n      inputDefinitions.push({\n        id: 'includeDirectories' as PortId,\n        title: 'Include Directories',\n        dataType: 'boolean',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useFilterGlobsInput) {\n      inputDefinitions.push({\n        id: 'filterGlobs' as PortId,\n        title: 'Filter Globs',\n        dataType: 'string[]',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useRelativeInput) {\n      inputDefinitions.push({\n        id: 'relative' as PortId,\n        title: 'Relative',\n        dataType: 'boolean',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'rootPath' as PortId,\n        title: 'Root Path',\n        dataType: 'string',\n      },\n      {\n        id: 'paths' as PortId,\n        title: 'Paths',\n        dataType: 'string[]',\n      },\n      {\n        id: 'tree' as PortId,\n        title: 'Tree',\n        dataType: 'object',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      Path: ${this.data.usePathInput ? '(Input)' : this.data.path}\n      Recursive: ${this.data.useRecursiveInput ? '(Input)' : this.data.recursive}\n      Include Directories: ${this.data.useIncludeDirectoriesInput ? '(Input)' : this.data.includeDirectories}\n      Relative: ${this.data.useRelativeInput ? '(Input)' : this.data.relative}\n      Filters: ${\n        this.data.useFilterGlobsInput\n          ? '(Input)'\n          : this.data.filterGlobs.length > 0\n            ? this.data.filterGlobs.join(', ')\n            : 'None'\n      }\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Reads the contents of the specified directory and outputs:\n        1. An array of filenames\n        2. The root path of the search\n        3. A tree structure representing the directory hierarchy\n      `,\n      infoBoxTitle: 'Read Directory Node',\n      contextMenuTitle: 'Read Directory',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { nativeApi } = context;\n\n    if (nativeApi == null) {\n      throw new Error('This node requires a native API to run.');\n    }\n\n    const path = getInputOrData(this.data, inputs, 'path');\n    const recursive = getInputOrData(this.data, inputs, 'recursive', 'boolean');\n    const includeDirectories = getInputOrData(this.data, inputs, 'includeDirectories', 'boolean');\n    const filterGlobs = getInputOrData(this.data, inputs, 'filterGlobs', 'string[]');\n    const relative = getInputOrData(this.data, inputs, 'relative', 'boolean');\n    const ignores = getInputOrData(this.data, inputs, 'ignores', 'string[]');\n\n    try {\n      const files = await nativeApi.readdir(path, undefined, {\n        recursive,\n        includeDirectories,\n        filterGlobs,\n        relative,\n        ignores,\n      });\n\n      const tree = createTreeFromPaths(files, path);\n\n      return {\n        ['paths' as PortId]: { type: 'string[]', value: files },\n        ['rootPath' as PortId]: { type: 'string', value: path },\n        ['tree' as PortId]: { type: 'object', value: tree as unknown as Record<string, unknown> },\n      };\n    } catch (err) {\n      return {\n        ['paths' as PortId]: { type: 'string[]', value: ['(no such path)'] },\n        ['rootPath' as PortId]: { type: 'string', value: path },\n        ['tree' as PortId]: {\n          type: 'object',\n          value: {\n            path,\n            name: path.split('/').pop() || path,\n            isDirectory: true,\n            children: [],\n          },\n        },\n      };\n    }\n  }\n}\n\nexport const readDirectoryNode = nodeDefinition(ReadDirectoryNodeImpl, 'Read Directory');\n"]},{"id":"W-h6o3i7I6FqAH7cRrwdD","data":["SplitNode.ts","import type {\n  ChartNode,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  EditorDefinition,\n  PortId,\n  Inputs,\n  InternalProcessContext,\n  Outputs,\n  NodeBodySpec,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { coerceType, dedent, getInputOrData, handleEscapeCharacters, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type SplitNode = ChartNode<'split', SplitNodeData>;\n\ntype SplitNodeData = {\n  delimiter: string;\n  useDelimiterInput?: boolean;\n  regex?: boolean;\n};\n\nexport class SplitNodeImpl extends NodeImpl<SplitNode> {\n  static create(): SplitNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'split',\n      title: 'Split Text',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        delimiter: ',',\n        regex: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'string' as PortId,\n        title: 'String',\n        dataType: 'string',\n      },\n    ];\n\n    if (this.data.useDelimiterInput) {\n      inputs.push({\n        id: 'delimiter' as PortId,\n        title: 'Delimiter',\n        dataType: 'string',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'splitString' as PortId,\n        title: 'Split',\n        dataType: 'string[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Splits a string by the provided delimiter.\n      `,\n      infoBoxTitle: 'Split Text Node',\n      contextMenuTitle: 'Split Text',\n      group: ['Text'],\n    };\n  }\n\n  getEditors(): EditorDefinition<SplitNode>[] | Promise<EditorDefinition<SplitNode>[]> {\n    return [\n      {\n        type: 'toggle',\n        label: 'Regex',\n        dataKey: 'regex',\n      },\n      {\n        type: 'code',\n        label: 'Delimiter',\n        language: 'plaintext',\n        dataKey: 'delimiter',\n        useInputToggleDataKey: 'useDelimiterInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | NodeBodySpec[] | undefined {\n    if (this.data.useDelimiterInput) {\n      return '(Delimiter from input)';\n    }\n\n    const normalized = handleEscapeCharacters(this.data.delimiter);\n\n    if (normalized === '\\n') {\n      return '(New line)';\n    }\n\n    if (normalized === '\\r\\n') {\n      return '(New line (windows))';\n    }\n\n    if (normalized === '\\t') {\n      return '(Tab)';\n    }\n\n    if (normalized === ' ') {\n      return '(Space)';\n    }\n\n    return normalized;\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const delimiter = getInputOrData(this.data, inputs, 'delimiter');\n\n    const normalizedDelimiter = this.data.regex ? new RegExp(delimiter) : handleEscapeCharacters(delimiter);\n\n    const stringToSplit = coerceType(inputs['string' as PortId], 'string');\n\n    const splitString = stringToSplit.split(normalizedDelimiter);\n\n    return {\n      ['splitString' as PortId]: {\n        type: 'string[]',\n        value: splitString,\n      },\n    };\n  }\n}\n\nexport const splitNode = nodeDefinition(SplitNodeImpl, 'Split String');\n"]},{"id":"5J44TTB9jCwAYdZ1tRTqP","data":["ChatLoopNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type ChatMessage, type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { ChatNodeBase, type ChatNodeData } from './ChatNodeBase.js';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type ChatLoopNode = ChartNode<'chatLoop', ChatLoopNodeData>;\n\nexport type ChatLoopNodeData = ChatNodeData & {\n  userPrompt: string;\n  renderingFormat?: 'text' | 'markdown';\n};\n\nexport class ChatLoopNodeImpl extends NodeImpl<ChatLoopNode> {\n  static create(): ChatLoopNode {\n    const chartNode: ChatLoopNode = {\n      type: 'chatLoop',\n      title: 'Chat Loop',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        ...ChatNodeBase.defaultData(),\n        userPrompt: 'Your response:',\n        renderingFormat: 'markdown',\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return ChatNodeBase.getInputDefinitions(this.data);\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        dataType: 'string[]',\n        id: 'conversation' as PortId,\n        title: 'Full Conversation',\n      },\n      {\n        dataType: 'string',\n        id: 'lastMessage' as PortId,\n        title: 'Last Message',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Creates an interactive chat loop with an AI model. The node will:\n        1. Send the initial prompt to the AI\n        2. Show the AI's response and prompt for user input\n        3. Send the user's input back to the AI\n        4. Repeat steps 2-3 until the user ends the conversation\n\n        The conversation history is maintained and sent with each new message.\n      `,\n      contextMenuTitle: 'Chat Loop',\n      infoBoxTitle: 'Chat Loop Node',\n      group: ['Convenience'],\n    };\n  }\n\n  getEditors(): EditorDefinition<ChatLoopNode>[] {\n    return [\n      ...ChatNodeBase.getEditors(),\n      {\n        type: 'code',\n        label: 'User Prompt',\n        dataKey: 'userPrompt',\n        language: 'plain-text',\n      },\n      {\n        type: 'group',\n        label: 'Rendering',\n        editors: [\n          {\n            type: 'dropdown',\n            dataKey: 'renderingFormat',\n            label: 'Format',\n            options: [\n              { label: 'Text', value: 'text' },\n              { label: 'Markdown', value: 'markdown' },\n            ],\n            defaultValue: 'markdown',\n          },\n        ],\n      },\n    ];\n  }\n\n  getBody() {\n    return ChatNodeBase.getBody(this.data);\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const conversation: ChatMessage[] = [];\n    let continueChat = true;\n\n    conversation.push(...coerceType(inputs['prompt' as PortId], 'chat-message[]'));\n\n    // Initial chat call\n    const initialResponse = await ChatNodeBase.process(this.data, this.chartNode, inputs, context);\n    const firstMessage = coerceType(initialResponse['response' as PortId], 'string');\n    conversation.push({\n      type: 'assistant',\n      message: firstMessage,\n      function_calls: undefined,\n      function_call: undefined,\n    });\n\n    let messageToUser = firstMessage;\n\n    while (continueChat) {\n      // Get user input\n      const userResponse = await context.requestUserInput([messageToUser], this.data.renderingFormat ?? 'text');\n\n      // Check if user wants to end conversation\n      if (!userResponse || userResponse.value.length === 0 || userResponse.value[0]?.length === 0) {\n        continueChat = false;\n        break;\n      }\n\n      // Add user message to conversation\n      conversation.push({\n        type: 'user',\n        message: userResponse.value[0]!,\n      });\n\n      // Prepare next AI message\n      const chatInputs = {\n        ...inputs,\n        prompt: {\n          type: 'chat-message[]',\n          value: conversation,\n        },\n      };\n\n      // Get AI response\n      const aiResponse = await ChatNodeBase.process(this.data, this.chartNode, chatInputs, context);\n      const aiMessage = coerceType(aiResponse['response' as PortId], 'string');\n      conversation.push({\n        type: 'assistant',\n        message: aiMessage,\n        function_calls: undefined,\n        function_call: undefined,\n      });\n\n      messageToUser = aiMessage;\n    }\n\n    return {\n      ['conversation' as PortId]: {\n        type: 'chat-message[]',\n        value: conversation,\n      },\n      ['lastMessage' as PortId]: {\n        type: 'chat-message',\n        value: conversation.at(-1)!,\n      },\n    };\n  }\n}\n\nexport const chatLoopNode = nodeDefinition(ChatLoopNodeImpl, 'Chat Loop');\n"]},{"id":"823JW5Vxo10kcNxTTTLnj","data":["GraphReferenceNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type GraphId } from '../NodeGraph.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type EditorDefinition, type NodeBody } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport type { RivetUIContext } from '../RivetUIContext.js';\nimport { coerceType } from '../../utils/index.js';\n\nexport type GraphReferenceNode = ChartNode<'graphReference', GraphReferenceNodeData>;\n\nexport type GraphReferenceNodeData = {\n  graphId: GraphId;\n  useGraphIdOrNameInput: boolean;\n};\n\nexport class GraphReferenceNodeImpl extends NodeImpl<GraphReferenceNode> {\n  static create(): GraphReferenceNode {\n    const chartNode: GraphReferenceNode = {\n      type: 'graphReference',\n      title: 'Graph Reference',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 275,\n      },\n      data: {\n        graphId: '' as GraphId,\n        useGraphIdOrNameInput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    if (this.data.useGraphIdOrNameInput) {\n      inputs.push({\n        id: 'graph-name-or-id' as PortId,\n        dataType: 'string',\n        title: 'Graph Name Or ID',\n        description: 'The name or ID of the graph to get a reference to.',\n        required: true,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'graph' as PortId,\n        dataType: 'graph-reference',\n        title: 'Graph',\n        description: 'A reference to the graph.',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<GraphReferenceNode>[] {\n    const definitions: EditorDefinition<GraphReferenceNode>[] = [\n      {\n        type: 'graphSelector',\n        label: 'Graph',\n        dataKey: 'graphId',\n        useInputToggleDataKey: 'useGraphIdOrNameInput',\n      },\n    ];\n\n    return definitions;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Gets a reference to another graph, that can be used to pass around graphs to call using a Call Graph node.\n      `,\n      infoBoxTitle: 'Graph Reference Node',\n      contextMenuTitle: 'Graph Reference',\n      group: ['Advanced'],\n    };\n  }\n\n  getBody(context: RivetUIContext): string {\n    if (this.data.useGraphIdOrNameInput) {\n      return '(Graph from input)';\n    }\n\n    const graph = context.project.graphs[this.data.graphId];\n\n    if (!graph) {\n      return '(Graph not found)';\n    }\n\n    return graph.metadata!.name ?? '(Unnamed Graph)';\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    if (this.data.useGraphIdOrNameInput) {\n      const graphIdOrName = coerceType(inputs['graph-name-or-id' as PortId], 'string');\n\n      let graph = context.project.graphs[graphIdOrName as GraphId];\n\n      if (!graph) {\n        graph = Object.values(context.project.graphs).find((graph) => graph.metadata!.name === graphIdOrName);\n      }\n\n      if (!graph) {\n        return {\n          ['graph' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n        };\n      }\n\n      return {\n        ['graph' as PortId]: {\n          type: 'graph-reference',\n          value: {\n            graphId: graph.metadata!.id ?? ('' as GraphId),\n            graphName: graph.metadata!.name ?? '',\n          },\n        },\n      };\n    }\n\n    const graph = context.project.graphs[this.data.graphId];\n\n    if (!graph) {\n      return {\n        ['graph' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['graph' as PortId]: {\n        type: 'graph-reference',\n        value: {\n          graphId: graph.metadata!.id ?? ('' as GraphId),\n          graphName: graph.metadata!.name ?? '',\n        },\n      },\n    };\n  }\n}\n\nexport const graphReferenceNode = nodeDefinition(GraphReferenceNodeImpl, 'Graph Reference');\n"]},{"id":"Wo7ebYooHzZIo60B4i0Ud","data":["ChatNode.ts","import { type ChartNode, type NodeId, type NodeInputDefinition, type NodeOutputDefinition } from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { ChatNodeBase, type ChatNodeData } from './ChatNodeBase.js';\n\nexport type ChatNode = ChartNode<'chat', ChatNodeData>;\n\nexport class ChatNodeImpl extends NodeImpl<ChatNode> {\n  static create(): ChatNode {\n    const chartNode: ChatNode = {\n      type: 'chat',\n      title: 'Chat',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: ChatNodeBase.defaultData(),\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    return ChatNodeBase.getInputDefinitions(this.data);\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return ChatNodeBase.getOutputDefinitions(this.data);\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Makes a call to an LLM chat model. Supports GPT and any OpenAI-compatible API. The settings contains many options for tweaking the model's behavior.\n\n        The \\`System Prompt\\` input specifies a system prompt as the first message to the model. This is useful for providing context to the model.\n\n        The \\`Prompt\\` input takes one or more strings or chat-messages (from a Prompt node) to send to the model.\n      `,\n      contextMenuTitle: 'Chat',\n      infoBoxTitle: 'Chat Node',\n      group: ['Common', 'AI'],\n    };\n  }\n\n  getEditors(): EditorDefinition<ChatNode>[] {\n    return ChatNodeBase.getEditors();\n  }\n\n  getBody() {\n    return ChatNodeBase.getBody(this.data);\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    return ChatNodeBase.process(this.data, this.chartNode, inputs, context);\n  }\n}\n\nexport const chatNode = nodeDefinition(ChatNodeImpl, 'Chat');\n"]},{"id":"yicJoYIOQBe_bOakXIGd5","data":["RaceInputsNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n  type NodeConnection,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition } from '../../index.js';\n\nexport type RaceInputsNode = ChartNode<'raceInputs', RaceInputsNodeData>;\n\nexport type RaceInputsNodeData = {};\n\nexport class RaceInputsNodeImpl extends NodeImpl<RaceInputsNode> {\n  static create(): RaceInputsNode {\n    const chartNode: RaceInputsNode = {\n      type: 'raceInputs',\n      title: 'Race Inputs',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 300,\n      },\n      data: {},\n    };\n\n    return chartNode;\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);\n      if (messageNumber > maxInputNumber) {\n        maxInputNumber = messageNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'result' as PortId,\n        title: 'Result',\n        dataType: 'any',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<RaceInputsNode>[] {\n    return [];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in multiple inputs and outputs the value of the first one to finish. The other inputs are cancelled.\n      `,\n      infoBoxTitle: 'Race Inputs Node',\n      contextMenuTitle: 'Race Inputs',\n      group: ['Logic'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    // GraphProcessor handles most of the racing/aborting logic for us.\n    const value = Object.entries(inputs).find(\n      ([key, value]) => key.startsWith('input') && value !== undefined && value.type !== 'control-flow-excluded',\n    );\n\n    if (!value) {\n      return {\n        ['result' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    return {\n      ['result' as PortId]: value[1],\n    };\n  }\n}\n\nexport const raceInputsNode = nodeDefinition(RaceInputsNodeImpl, 'Race Inputs');\n"]},{"id":"vi8kjyWISpOa7lvaH-2ji","data":["ReadAllFilesNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type PortId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { type DataValue } from '../DataValue.js';\nimport { NodeImpl, type NodeBody, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { getInputOrData } from '../../utils/index.js';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport type { Inputs } from '../GraphProcessor.js';\nimport { uint8ArrayToBase64 } from '../../utils/base64.js';\n\nexport type ReadAllFilesNode = ChartNode<'readAllFiles', ReadAllFilesNodeData>;\n\ntype ReadAllFilesNodeData = {\n  path: string;\n  usePathInput: boolean;\n\n  recursive: boolean;\n  useRecursiveInput: boolean;\n\n  filterGlobs: string[];\n  useFilterGlobsInput: boolean;\n\n  ignores?: string[];\n  useIgnoresInput: boolean;\n\n  asBinary?: boolean;\n  errorOnMissingFile?: boolean;\n};\n\ntype FileOutput = {\n  path: string;\n  content: string | Uint8Array;\n};\n\nexport class ReadAllFilesNodeImpl extends NodeImpl<ReadAllFilesNode> {\n  static create(): ReadAllFilesNode {\n    return {\n      id: nanoid() as NodeId,\n      type: 'readAllFiles',\n      title: 'Read All Files',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        path: '',\n        usePathInput: false,\n        recursive: false,\n        useRecursiveInput: false,\n        filterGlobs: [],\n        useFilterGlobsInput: false,\n        ignores: [],\n        useIgnoresInput: false,\n        asBinary: false,\n        errorOnMissingFile: false,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputDefinitions: NodeInputDefinition[] = [];\n\n    if (this.chartNode.data.usePathInput) {\n      inputDefinitions.push({\n        id: 'path' as PortId,\n        title: 'Path',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useRecursiveInput) {\n      inputDefinitions.push({\n        id: 'recursive' as PortId,\n        title: 'Recursive',\n        dataType: 'boolean',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useFilterGlobsInput) {\n      inputDefinitions.push({\n        id: 'filterGlobs' as PortId,\n        title: 'Filter Globs',\n        dataType: 'string[]',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    if (this.chartNode.data.useIgnoresInput) {\n      inputDefinitions.push({\n        id: 'ignores' as PortId,\n        title: 'Ignores',\n        dataType: 'string[]',\n        required: true,\n        coerced: false,\n      });\n    }\n\n    return inputDefinitions;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'files' as PortId,\n        title: 'Files',\n        dataType: 'object[]',\n      },\n      {\n        id: 'rootPath' as PortId,\n        title: 'Root Path',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ReadAllFilesNode>[] {\n    return [\n      {\n        type: 'directoryBrowser',\n        label: 'Path',\n        dataKey: 'path',\n        useInputToggleDataKey: 'usePathInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Recursive',\n        dataKey: 'recursive',\n        useInputToggleDataKey: 'useRecursiveInput',\n      },\n      {\n        type: 'stringList',\n        label: 'Filter Globs',\n        dataKey: 'filterGlobs',\n        useInputToggleDataKey: 'useFilterGlobsInput',\n      },\n      {\n        type: 'stringList',\n        label: 'Ignores',\n        dataKey: 'ignores',\n        useInputToggleDataKey: 'useIgnoresInput',\n      },\n      {\n        type: 'toggle',\n        label: 'Read as Binary',\n        dataKey: 'asBinary',\n      },\n      {\n        type: 'toggle',\n        label: 'Error on Missing File',\n        dataKey: 'errorOnMissingFile',\n      },\n    ];\n  }\n\n  getBody(): NodeBody {\n    return dedent`\n      ${this.data.asBinary ? 'Read as Binary' : 'Read as Text'}\n      Path: ${this.data.usePathInput ? '(Input)' : this.data.path}\n      Recursive: ${this.data.useRecursiveInput ? '(Input)' : this.data.recursive}\n      Filters: ${\n        this.data.useFilterGlobsInput\n          ? '(Input)'\n          : this.data.filterGlobs.length > 0\n            ? this.data.filterGlobs.join(', ')\n            : 'None'\n      }\n    `;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Reads all files in the specified directory and outputs an array of objects containing each file's path and contents.\n        Each object has a 'path' (string) and 'content' (string or binary) property.\n      `,\n      infoBoxTitle: 'Read All Files Node',\n      contextMenuTitle: 'Read All Files',\n      group: ['Input/Output'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Record<PortId, DataValue>> {\n    const { nativeApi } = context;\n\n    if (nativeApi == null) {\n      throw new Error('This node requires a native API to run.');\n    }\n\n    const path = getInputOrData(this.chartNode.data, inputs, 'path');\n\n    const recursive = getInputOrData(this.data, inputs, 'recursive', 'boolean');\n    const filterGlobs = getInputOrData(this.data, inputs, 'filterGlobs', 'string[]');\n    const ignores = getInputOrData(this.data, inputs, 'ignores', 'string[]');\n\n    try {\n      // First read the directory\n      const filePaths = await nativeApi.readdir(path, undefined, {\n        recursive,\n        includeDirectories: false, // We only want files since we're reading contents\n        filterGlobs,\n        relative: true, // Always use relative paths in output\n        ignores,\n      });\n\n      // Then read each file\n      const filePromises = filePaths.map(async (filePath): Promise<FileOutput> => {\n        try {\n          if (this.data.asBinary) {\n            const content = await nativeApi.readBinaryFile(`${path}/${filePath}`);\n            const buffer = await content.arrayBuffer();\n            return {\n              path: filePath,\n              content: (await uint8ArrayToBase64(new Uint8Array(buffer))) ?? '',\n            };\n          } else {\n            const content = await nativeApi.readTextFile(`${path}/${filePath}`, undefined);\n            return {\n              path: filePath,\n              content,\n            };\n          }\n        } catch (err) {\n          if (this.chartNode.data.errorOnMissingFile) {\n            throw err;\n          }\n          return {\n            path: filePath,\n            content: this.data.asBinary ? new Uint8Array() : '',\n          };\n        }\n      });\n\n      const files = await Promise.all(filePromises);\n\n      return {\n        ['files' as PortId]: { type: 'object[]', value: files },\n        ['rootPath' as PortId]: { type: 'string', value: path },\n      };\n    } catch (err) {\n      if (this.chartNode.data.errorOnMissingFile) {\n        throw err;\n      }\n      return {\n        ['files' as PortId]: { type: 'object[]', value: [] },\n        ['rootPath' as PortId]: { type: 'string', value: path },\n      };\n    }\n  }\n}\n\nexport const readAllFilesNode = nodeDefinition(ReadAllFilesNodeImpl, 'Read All Files');\n"]},{"id":"si46lp0tBd2lBYBai7ghf","data":["CallGraphNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { type InternalProcessContext } from '../ProcessContext.js';\nimport { dedent } from 'ts-dedent';\nimport { coerceTypeOptional } from '../../utils/coerceType.js';\nimport { looseDataValuesToDataValues, type LooseDataValue } from '../../api/looseDataValue.js';\nimport { getError } from '../../utils/errors.js';\n\nexport type CallGraphNode = ChartNode<'callGraph', CallGraphNodeData>;\n\nexport type CallGraphNodeData = {\n  useErrorOutput?: boolean;\n};\n\nexport class CallGraphNodeImpl extends NodeImpl<CallGraphNode> {\n  static create(): CallGraphNode {\n    const chartNode: CallGraphNode = {\n      type: 'callGraph',\n      title: 'Call Graph',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 200,\n      },\n      data: {\n        useErrorOutput: false,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n\n    inputs.push({\n      id: 'graph' as PortId,\n      dataType: 'graph-reference',\n      title: 'Graph',\n      description: 'The reference to the graph to call.',\n      required: true,\n    });\n\n    inputs.push({\n      id: 'inputs' as PortId,\n      dataType: 'object',\n      title: 'Inputs',\n      description:\n        'The inputs to pass to the graph. Should be an object where the keys are the input names and the values are the input values.',\n    });\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [\n      {\n        id: 'outputs' as PortId,\n        dataType: 'object',\n        title: 'Outputs',\n        description: 'The outputs of the graph.',\n      },\n    ];\n\n    if (this.data.useErrorOutput) {\n      outputs.push({\n        id: 'error' as PortId,\n        dataType: 'string',\n        title: 'Error',\n        description: 'The error message if the graph call failed.',\n      });\n    }\n\n    return outputs;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Calls another graph and passes inputs to it. Use in combination with the Graph Reference node to call dynamic graphs.\n      `,\n      infoBoxTitle: 'Call Graph Node',\n      contextMenuTitle: 'Call Graph',\n      group: ['Advanced'],\n    };\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const graphRef = coerceTypeOptional(inputs['graph' as PortId], 'graph-reference');\n    const graphInputs = coerceTypeOptional(inputs['inputs' as PortId], 'object');\n\n    if (!graphRef) {\n      return {\n        ['outputs' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    const graph = context.project.graphs[graphRef.graphId];\n\n    if (!graph) {\n      return {\n        ['outputs' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    const subGraphProcessor = context.createSubProcessor(graphRef.graphId, { signal: context.signal });\n\n    const outputs: Outputs = {};\n\n    try {\n      const startTime = Date.now();\n\n      const inputData = looseDataValuesToDataValues(graphInputs as Record<string, LooseDataValue>);\n\n      const graphOutputs = await subGraphProcessor.processGraph(context, inputData, context.contextValues);\n\n      const duration = Date.now() - startTime;\n\n      outputs['outputs' as PortId] = {\n        type: 'object',\n        value: graphOutputs,\n      };\n\n      if (this.data.useErrorOutput) {\n        outputs['error' as PortId] = {\n          type: 'control-flow-excluded',\n          value: undefined,\n        };\n      }\n\n      if (outputs['duration' as PortId] == null) {\n        outputs['duration' as PortId] = {\n          type: 'number',\n          value: duration,\n        };\n      }\n\n      return outputs;\n    } catch (err) {\n      if (!this.data.useErrorOutput) {\n        throw err;\n      }\n\n      outputs['outputs' as PortId] = {\n        type: 'control-flow-excluded',\n        value: undefined,\n      };\n\n      outputs['error' as PortId] = {\n        type: 'string',\n        value: getError(err).message,\n      };\n\n      return outputs;\n    }\n  }\n}\n\nexport const callGraphNode = nodeDefinition(CallGraphNodeImpl, 'Call Graph');\n"]},{"id":"RVH6G7HU295cXQvsmaAav","data":["DelayNode.ts","import {\n  type ChartNode,\n  type NodeConnection,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type Inputs, type Outputs } from '../GraphProcessor.js';\nimport { type EditorDefinition } from '../../index.js';\nimport { dedent } from 'ts-dedent';\nimport { getInputOrData } from '../../utils/inputs.js';\n\nexport type DelayNode = ChartNode<'delay', DelayNodeData>;\n\nexport type DelayNodeData = {\n  delay: number;\n  useDelayInput?: boolean;\n};\n\nexport class DelayNodeImpl extends NodeImpl<DelayNode> {\n  static create(): DelayNode {\n    const chartNode: DelayNode = {\n      type: 'delay',\n      title: 'Delay',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 175,\n      },\n      data: {\n        delay: 0,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(connections: NodeConnection[]): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    if (this.data.useDelayInput) {\n      inputs.push({\n        dataType: 'number',\n        id: 'delay' as PortId,\n        title: 'Delay (ms)',\n      });\n    }\n\n    for (let i = 1; i <= inputCount; i++) {\n      inputs.push({\n        dataType: 'any',\n        id: `input${i}` as PortId,\n        title: `Input ${i}`,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(connections: NodeConnection[]): NodeOutputDefinition[] {\n    const outputs: NodeOutputDefinition[] = [];\n    const inputCount = this.#getInputPortCount(connections);\n\n    for (let i = 1; i <= inputCount - 1; i++) {\n      outputs.push({\n        dataType: 'any',\n        id: `output${i}` as PortId,\n        title: `Output ${i}`,\n      });\n    }\n\n    return outputs;\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Delays the execution and then passes the input value to the output without any modifications.\n      `,\n      infoBoxTitle: 'Delay Node',\n      contextMenuTitle: 'Delay',\n      group: ['Logic'],\n    };\n  }\n\n  #getInputPortCount(connections: NodeConnection[]): number {\n    const inputNodeId = this.chartNode.id;\n    const inputConnections = connections.filter(\n      (connection) => connection.inputNodeId === inputNodeId && connection.inputId.startsWith('input'),\n    );\n\n    let maxInputNumber = 0;\n    for (const connection of inputConnections) {\n      const messageNumber = parseInt(connection.inputId.replace('input', ''), 10);\n      if (messageNumber > maxInputNumber) {\n        maxInputNumber = messageNumber;\n      }\n    }\n\n    return maxInputNumber + 1;\n  }\n\n  getEditors(): EditorDefinition<DelayNode>[] {\n    return [\n      {\n        type: 'number',\n        label: 'Delay (ms)',\n        dataKey: 'delay',\n        useInputToggleDataKey: 'useDelayInput',\n        defaultValue: 0,\n      },\n    ];\n  }\n\n  getBody(): string | undefined {\n    return `Delay ${this.data.useDelayInput ? '(Input ms)' : `${this.chartNode.data.delay}ms`}`;\n  }\n\n  async process(inputData: Inputs): Promise<Outputs> {\n    const delayAmount = getInputOrData(this.data, inputData, 'delay', 'number');\n\n    await new Promise((resolve) => setTimeout(resolve, delayAmount));\n\n    const inputCount = Object.keys(inputData).filter((key) => key.startsWith('input')).length;\n\n    const outputs: Outputs = {};\n\n    for (let i = 1; i <= inputCount; i++) {\n      const input = inputData[`input${i}` as PortId]!;\n      outputs[`output${i}` as PortId] = input;\n    }\n\n    return outputs;\n  }\n}\n\nexport const delayNode = nodeDefinition(DelayNodeImpl, 'Delay');\n"]},{"id":"pTT9SKxu-dDhbebLQbbuP","data":["DatasetNearestNeigborsNode.ts","import type {\n  ChartNode,\n  DatasetId,\n  Inputs,\n  InternalProcessContext,\n  NodeId,\n  NodeInputDefinition,\n  NodeOutputDefinition,\n  NodeUIData,\n  Outputs,\n  PortId,\n  EditorDefinition,\n} from '../../index.js';\nimport { NodeImpl } from '../NodeImpl.js';\nimport { coerceType, dedent, getInputOrData, newId } from '../../utils/index.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\n\nexport type DatasetNearestNeighborsNode = ChartNode<'datasetNearestNeighbors', DatasetNearestNeighborsNodeData>;\n\ntype DatasetNearestNeighborsNodeData = {\n  datasetId: DatasetId;\n  useDatasetIdInput?: boolean;\n\n  k: number;\n  useKInput?: boolean;\n};\n\nexport class DatasetNearestNeighborsNodeImpl extends NodeImpl<DatasetNearestNeighborsNode> {\n  static create(): DatasetNearestNeighborsNode {\n    return {\n      id: newId<NodeId>(),\n      type: 'datasetNearestNeighbors',\n      title: 'KNN Dataset',\n      visualData: { x: 0, y: 0, width: 250 },\n      data: {\n        datasetId: '' as DatasetId,\n        k: 5,\n      },\n    };\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'embedding' as PortId,\n        title: 'Embedding',\n        dataType: 'object',\n      },\n    ];\n\n    if (this.data.useDatasetIdInput) {\n      inputs.push({\n        id: 'datasetId' as PortId,\n        title: 'Dataset ID',\n        dataType: 'string',\n      });\n    }\n\n    if (this.data.useKInput) {\n      inputs.push({\n        id: 'k' as PortId,\n        title: 'K',\n        dataType: 'number',\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'nearestNeighbors' as PortId,\n        title: 'Nearest Neighbors',\n        dataType: 'object[]',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Finds the k nearest neighbors in the dataset with the provided ID, given an embedding.\n      `,\n      infoBoxTitle: 'KNN Dataset Node',\n      contextMenuTitle: 'KNN Dataset',\n      group: ['Input/Output'],\n    };\n  }\n\n  getEditors(): EditorDefinition<DatasetNearestNeighborsNode>[] {\n    return [\n      {\n        type: 'datasetSelector',\n        label: 'Dataset',\n        dataKey: 'datasetId',\n        useInputToggleDataKey: 'useDatasetIdInput',\n      },\n      {\n        type: 'number',\n        label: 'K',\n        dataKey: 'k',\n        useInputToggleDataKey: 'useKInput',\n      },\n    ];\n  }\n\n  async process(inputs: Inputs, context: InternalProcessContext): Promise<Outputs> {\n    const { datasetProvider } = context;\n\n    if (datasetProvider == null) {\n      throw new Error('datasetProvider is required');\n    }\n\n    const datasetId = getInputOrData(this.data, inputs, 'datasetId');\n    const k = getInputOrData(this.data, inputs, 'k', 'number');\n    const embedding = coerceType(inputs['embedding' as PortId], 'vector');\n\n    const nearestNeighbors = await datasetProvider.knnDatasetRows(datasetId as DatasetId, k, embedding);\n\n    return {\n      ['nearestNeighbors' as PortId]: {\n        type: 'object[]',\n        value: nearestNeighbors.map((neighbor) => ({\n          id: neighbor.id,\n          distance: neighbor.distance,\n          data: neighbor.data,\n        })),\n      },\n    };\n  }\n}\n\nexport const datasetNearestNeighborsNode = nodeDefinition(DatasetNearestNeighborsNodeImpl, 'Dataset Nearest Neighbors');\n"]},{"id":"wfJ2cEEVgLsarhczwi9t5","data":["ExtractYamlNode.ts","import {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type PortId,\n  type NodeOutputDefinition,\n} from '../NodeBase.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport { type DataValue } from '../DataValue.js';\nimport yaml from 'yaml';\nimport { expectType } from '../../utils/expectType.js';\nimport { JSONPath } from 'jsonpath-plus';\nimport { dedent } from 'ts-dedent';\nimport { type EditorDefinition, type NodeBodySpec } from '../../index.js';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type ExtractYamlNode = ChartNode<'extractYaml', ExtractYamlNodeData>;\n\nexport type ExtractYamlNodeData = {\n  rootPropertyName: string;\n  useRootPropertyNameInput?: boolean;\n  objectPath?: string;\n  useObjectPathInput?: boolean;\n};\n\nexport class ExtractYamlNodeImpl extends NodeImpl<ExtractYamlNode> {\n  static create(): ExtractYamlNode {\n    const chartNode: ExtractYamlNode = {\n      type: 'extractYaml',\n      title: 'Extract YAML',\n      id: nanoid() as NodeId,\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 250,\n      },\n      data: {\n        rootPropertyName: 'yamlDocument',\n        useRootPropertyNameInput: false,\n        useObjectPathInput: false,\n        objectPath: undefined,\n      },\n    };\n\n    return chartNode;\n  }\n\n  getInputDefinitions(): NodeInputDefinition[] {\n    const inputs: NodeInputDefinition[] = [\n      {\n        id: 'input' as PortId,\n        title: 'Input',\n        dataType: 'string',\n        required: true,\n        coerced: false,\n      },\n    ];\n\n    if (this.data.useRootPropertyNameInput) {\n      inputs.push({\n        id: 'rootPropertyName' as PortId,\n        title: 'Root Property Name',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    if (this.data.useObjectPathInput) {\n      inputs.push({\n        id: 'objectPath' as PortId,\n        title: 'Object Path',\n        dataType: 'string',\n        required: true,\n      });\n    }\n\n    return inputs;\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'Output',\n        dataType: 'object',\n      },\n      {\n        id: 'matches' as PortId,\n        title: 'Matches',\n        dataType: 'any[]',\n      },\n      {\n        id: 'noMatch' as PortId,\n        title: 'No Match',\n        dataType: 'string',\n      },\n    ];\n  }\n\n  getEditors(): EditorDefinition<ExtractYamlNode>[] {\n    return [\n      {\n        type: 'string',\n        label: 'Root Property Name',\n        dataKey: 'rootPropertyName',\n        useInputToggleDataKey: 'useRootPropertyNameInput',\n      },\n      {\n        type: 'code',\n        label: 'Object Path',\n        dataKey: 'objectPath',\n        language: 'jsonpath',\n        useInputToggleDataKey: 'useObjectPathInput',\n      },\n    ];\n  }\n\n  getBody(): string | NodeBodySpec | undefined {\n    return dedent`\n      Root: ${this.data.useRootPropertyNameInput ? '(Using Input)' : this.data.rootPropertyName}\n      ${\n        this.data.useObjectPathInput\n          ? 'Path: (Using Input)'\n          : this.data.objectPath\n            ? `Path: ${this.data.objectPath}`\n            : ``\n      }\n    `;\n  }\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Finds and parses a YAML object in the input text with a predefined root property name (configurable).\n\n        Defaults to \\`yamlDocument\\`, which means the input text must have a \\`yamlDocument:\\` root node somewhere in it. All indented text after that is considered part of the YAML.\n\n        Outputs the parsed object.\n      `,\n      infoBoxTitle: 'Extract YAML Node',\n      contextMenuTitle: 'Extract YAML',\n      group: ['Objects'],\n    };\n  }\n\n  async process(inputs: Record<PortId, DataValue>): Promise<Record<PortId, DataValue>> {\n    const inputString = expectType(inputs['input' as PortId], 'string');\n\n    const rootPropertyName = this.data.useRootPropertyNameInput\n      ? coerceType(inputs['rootPropertyName' as PortId], 'string')\n      : this.data.rootPropertyName;\n\n    const objectPath = this.data.useObjectPathInput\n      ? coerceType(inputs['objectPath' as PortId], 'string')\n      : this.data.objectPath;\n\n    const match = new RegExp(`^${rootPropertyName}:`, 'm').exec(inputString);\n    const rootPropertyStart = match?.index ?? -1;\n\n    const nextLines = inputString.slice(rootPropertyStart).split('\\n');\n    const yamlLines = [nextLines.shift()]; // remove the first line, which is the root property name\n\n    while (nextLines[0]?.startsWith(' ') || nextLines[0]?.startsWith('\\t') || nextLines[0] === '') {\n      yamlLines.push(nextLines.shift());\n    }\n\n    const potentialYaml = yamlLines.join('\\n');\n\n    let yamlObject: Record<string, unknown> | undefined = undefined;\n    try {\n      yamlObject = yaml.parse(potentialYaml);\n    } catch (err) {\n      return {\n        ['noMatch' as PortId]: {\n          type: 'string',\n          value: potentialYaml,\n        },\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    if (!yamlObject?.hasOwnProperty(rootPropertyName)) {\n      return {\n        ['noMatch' as PortId]: {\n          type: 'string',\n          value: potentialYaml,\n        },\n        ['output' as PortId]: {\n          type: 'control-flow-excluded',\n          value: undefined,\n        },\n      };\n    }\n\n    let matches: unknown[] = [];\n\n    if (objectPath) {\n      try {\n        const extractedValue = JSONPath({ json: yamlObject, path: objectPath.trim() });\n        matches = extractedValue;\n        yamlObject = extractedValue.length > 0 ? extractedValue[0] : undefined;\n      } catch (err) {\n        return {\n          ['noMatch' as PortId]: {\n            type: 'string',\n            value: potentialYaml,\n          },\n          ['output' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n          ['matches' as PortId]: {\n            type: 'control-flow-excluded',\n            value: undefined,\n          },\n        };\n      }\n    }\n\n    return {\n      ['output' as PortId]:\n        yamlObject === undefined\n          ? {\n              type: 'control-flow-excluded',\n              value: undefined,\n            }\n          : this.data.objectPath\n            ? {\n                type: 'any',\n                value: yamlObject,\n              }\n            : {\n                type: 'object',\n                value: yamlObject,\n              },\n      ['noMatch' as PortId]: {\n        type: 'control-flow-excluded',\n        value: undefined,\n      },\n      ['matches' as PortId]: {\n        type: 'any[]',\n        value: matches,\n      },\n    };\n  }\n}\n\nexport const extractYamlNode = nodeDefinition(ExtractYamlNodeImpl, 'Extract YAML');\n"]},{"id":"0NnBj0iKapvofxxKPtF0-","data":["IfNode.ts","import { NodeImpl, type NodeUIData } from '../NodeImpl.js';\nimport { nodeDefinition } from '../NodeDefinition.js';\nimport {\n  type ChartNode,\n  type NodeId,\n  type NodeInputDefinition,\n  type NodeOutputDefinition,\n  type PortId,\n} from '../NodeBase.js';\nimport {\n  type ControlFlowExcludedDataValue,\n  type ScalarDataValue,\n  type ArrayDataValue,\n  type DataValue,\n} from '../DataValue.js';\nimport { nanoid } from 'nanoid/non-secure';\nimport type { Inputs, Outputs } from '../GraphProcessor.js';\nimport { dedent } from 'ts-dedent';\nimport type { EditorDefinition } from '../EditorDefinition.js';\nimport { coerceType } from '../../utils/coerceType.js';\n\nexport type IfNode = ChartNode<'if', IfNodeData>;\n\nexport type IfNodeData = {\n  unconnectedControlFlowExcluded?: boolean;\n};\n\nexport class IfNodeImpl extends NodeImpl<IfNode> {\n  static create = (): IfNode => {\n    const chartNode: IfNode = {\n      type: 'if',\n      title: 'If',\n      id: nanoid() as NodeId,\n      data: {\n        // Legacy behavior is false\n        unconnectedControlFlowExcluded: true,\n      },\n      visualData: {\n        x: 0,\n        y: 0,\n        width: 125,\n      },\n    };\n    return chartNode;\n  };\n  getInputDefinitions(): NodeInputDefinition[] {\n    return [\n      {\n        id: 'if' as PortId,\n        title: 'If',\n        dataType: 'any',\n        description:\n          'If this is truthy, the value will be passed through the True port. Otherwise, it will be passed through the False port. An unconnected port is considered false.',\n      },\n      {\n        id: 'value' as PortId,\n        title: 'Value',\n        dataType: 'any',\n        description: 'The value to pass through the True or False port. If unconnected, it will be undefined.',\n      },\n    ];\n  }\n\n  getOutputDefinitions(): NodeOutputDefinition[] {\n    return [\n      {\n        id: 'output' as PortId,\n        title: 'True',\n        dataType: 'any',\n        description: 'The `value` passed through if the condition is truthy.',\n      },\n      {\n        id: 'falseOutput' as PortId,\n        title: 'False',\n        dataType: 'any',\n        description: 'The `value` passed through if the condition is falsy.',\n      },\n    ];\n  }\n\n  static getUIData(): NodeUIData {\n    return {\n      infoBoxBody: dedent`\n        Takes in a condition and a value. If the condition is truthy, the value is passed through the True port, and the False port is not ran.\n        If the condition is falsy, the value is passed through the False port, and the True port is not ran.\n      `,\n      infoBoxTitle: 'If Node',\n      contextMenuTitle: 'If',\n      group: ['Logic'],\n    };\n  }\n\n  getEditors(): EditorDefinition<IfNode>[] {\n    return [\n      {\n        type: 'toggle',\n        label: \"Don't run unconnected value\",\n        dataKey: 'unconnectedControlFlowExcluded',\n      },\n    ];\n  }\n\n  async process(inputData: Inputs): Promise<Outputs> {\n    const unconnectedValue: DataValue = this.data.unconnectedControlFlowExcluded\n      ? { type: 'control-flow-excluded', value: undefined }\n      : { type: 'any', value: undefined };\n\n    const ifValue = inputData['if' as PortId];\n    const value = inputData['value' as PortId] ?? unconnectedValue;\n\n    const isFalse = {\n      output: {\n        type: 'control-flow-excluded',\n        value: undefined,\n      } as ControlFlowExcludedDataValue,\n      falseOutput: value,\n    };\n\n    if (!ifValue) {\n      return isFalse;\n    }\n\n    if (ifValue.type === 'control-flow-excluded') {\n      return isFalse;\n    }\n\n    if (ifValue.type === 'string' && !ifValue.value) {\n      return isFalse;\n    }\n\n    if (ifValue.type === 'boolean' && !ifValue.value) {\n      return isFalse;\n    }\n\n    if (ifValue.type === 'chat-message') {\n      const asString = coerceType(ifValue, 'string');\n\n      if (!asString) {\n        return isFalse;\n      }\n    }\n\n    if (ifValue.type.endsWith('[]')) {\n      const value = ifValue as ArrayDataValue<ScalarDataValue>;\n\n      if (!value.value || value.value.length === 0) {\n        return isFalse;\n      }\n    }\n\n    return {\n      ['output' as PortId]: value,\n      ['falseOutput' as PortId]: {\n        type: 'control-flow-excluded',\n        value: undefined,\n      } as ControlFlowExcludedDataValue,\n    };\n  }\n}\n\nexport const ifNode = nodeDefinition(IfNodeImpl, 'If');\n"]}]}},{"meta":{"id":"tFwViTH9Bmi4b3GGXmkFS","projectId":"wHxyeNIJLo2ZrylGbkznh","name":"Node Documentation","description":""},"data":{"id":"tFwViTH9Bmi4b3GGXmkFS","rows":[{"id":"CWFzhytGqtX5TeZPDwg8y","data":["load-dataset.mdx","---\nid: load-dataset\ntitle: Load Dataset Node\nsidebar_label: Load Dataset\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Load Dataset Node Screenshot](./assets/load-dataset-node.png)\n\n## Overview\n\nThe Load Dataset Node is used to load the entire contents of a dataset into a graph. The data can then be used in other nodes in the graph.\n\nThe Load Dataset node outputs an array of dataset rows. Each row has the following structure:\n\n```json\n{\n  \"id\": \"1\", // The ID of the row\n  \"embedding\": [], // The vector embedding of the row, if it has been saved with an embedding\n  \"data\": [] // The data of the row, each element in the array corresponds to a column in the dataset\n}\n```\n\nTo access the data of a row, you can use the [Extract Object Path Node](./extract-object-path.mdx) to extract the `data` property from each row. If you use the jsonpath `$[*].data` in the Extract Object Path Node, you will get an array of arrays, where each inner array represents a row in the dataset.\n\nYou can extract a single row from the dataset by using `$[0].data` in the Extract Object Path Node. This will return an array of values, where each value corresponds to a column in the dataset.\n\nYou can extract a single column from the dataset by using `$[*].data[0]` in the Extract Object Path Node. This will return an array of values, where each value corresponds to a row in the dataset.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type | Description                                                                                                              | Default Value                                            | Notes                                                          |\n| ---------- | --------- | ------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------- | -------------------------------------------------------------- |\n| Dataset ID | `string`  | The ID of the dataset to load. This input is only available if `Use Dataset ID Input` is enabled in the editor settings. | (required if the input toggle for Dataset ID is enabled) | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type  | Description                                                                                                                              | Notes                                               |\n| ---------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |\n| Dataset    | `object[]` | The dataset that was loaded. Each object in the array represents a row in the dataset.                                                   | If the dataset does not exist, the node will error. |\n| Dataset ID | `string`   | The ID of the dataset that was loaded. This output will be the same as the Dataset ID input or the Dataset ID specified in the settings. |                                                     |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                    | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ------------------------------ | ------------- | ---------------- | --------------- |\n| Dataset | The ID of the dataset to load. | (required)    | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Load a dataset\n\n1. In the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the ID `employees`.\n2. Create a Load Dataset Node and set the Dataset ID to `employees`.\n3. Run the graph. The `Dataset` output of the Load Dataset Node should contain the entire `employees` dataset.\n\n![Load Dataset Node Example 1](./assets/load-dataset-node-example-01.png)\n\n## Error Handling\n\nThe Load Dataset Node will error if the dataset provider is not available in the context when the graph is being run. It will also error if the Dataset ID input is not provided or if the dataset does not exist.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I load multiple datasets at once?**\n\nA: No, the Load Dataset Node can only load one dataset at a time. If you want to load multiple datasets, you can use multiple Load Dataset Nodes.\n\n**Q: What happens if the dataset does not exist?**\n\nA: If the dataset does not exist, the Load Dataset Node will error.\n\n## See Also\n\n- [Append to Dataset Node](./append-to-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n"]},{"id":"wjT7A9iIFYHuN3R9JrmWK","data":["to-json.mdx","---\nid: to-json\ntitle: To JSON Node\nsidebar_label: To JSON\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![To JSON Node Screenshot](./assets/to-json-node.png)\n\n## Overview\n\nThe To JSON Node is used to convert a given input into its JSON equivalent, effectively stringifying the value. This can be useful when you need to serialize an object or array into a string format for further processing or storage.\n\nThe node provides an option to format the JSON output with indentation for easier reading.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                       | Default Value | Notes |\n| ----- | --------- | --------------------------------- | ------------- | ----- |\n| Data  | `any`     | The data to be converted to JSON. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                     | Notes |\n| ----- | --------- | ------------------------------- | ----- |\n| JSON  | `string`  | The JSON string representation. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting  | Description                                                                     | Default Value | Use Input Toggle | Input Data Type |\n| -------- | ------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Indented | If enabled, the JSON output will be formatted with indentation for readability. | True          | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Convert an object to JSON\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   {\n     \"name\": \"Claude Shannon\",\n     \"occupation\": \"Computer scientist\"\n   }\n   ```\n\n2. Create a To JSON Node and connect the Object Node to it.\n3. Run the graph. The To JSON Node should output the JSON string representation of the object.\n\n![To JSON Node Example 1](./assets/to-json-node-example-01.png)\n\n## Error Handling\n\nThe To JSON Node will throw an error if it fails to convert the input to a JSON string. This can happen if the input contains a value that is not serializable, such as a function or a circular reference.\n\n## FAQ\n\n**Q: Can I use the To JSON Node to convert a string to JSON?**\n\nA: Yes, but the output will be a JSON string representation of the original string. If you want to parse a JSON string into an object or array, use the [Extract JSON Node](./extract-json.mdx) or the [Extract Object Path Node](./extract-object-path.mdx).\n\n**Q: Can I use the To JSON Node to convert a number or boolean to JSON?**\n\nA: Yes, the To JSON Node can convert any data type to a JSON string. For numbers and booleans, the output will be the string representation of the original value.\n\n**Q: What does the \"Indented\" setting do?**\n\nA: When the \"Indented\" setting is enabled, the JSON output will be formatted with indentation and line breaks for easier reading. This can be useful when you need to inspect the JSON output for debugging purposes.\n\n## See Also\n\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"OtYBcx8_hsWGV2b6KIL90","data":["replace-dataset.mdx","---\nid: replace-dataset\ntitle: Replace Dataset Node\nsidebar_label: Replace Dataset\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Replace Dataset Node Screenshot](./assets/replace-dataset-node.png)\n\n## Overview\n\nThe Replace Dataset Node is used to either replace all of the data in a dataset in with new data, or to clear the data in a dataset, during graph execution.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type  | Description                                                                                                                                                                                                      | Default Value                                               | Notes                                                                        |\n| ---------- | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| Data       | `object[]` | The new data of the dataset. If empty, the dataset will be cleared. May be an array of array of strings, or an array of DatasetRow objects with { id, data } properties. If a string[][], IDs will be generated. | (empty)                                                     | The input will be coerced into an object array if it is not an object array. |\n| Dataset ID | `string`   | The ID of the dataset to replace. This input is only available if `Use Dataset ID Input` is enabled.                                                                                                             | (required if if the input toggle for Dataset ID is enabled) | The input will be coerced into a string if it is not a string.               |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type  | Description                                                                               | Notes                                                                               |\n| ------- | ---------- | ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |\n| Dataset | `object[]` | The new data of the dataset. An array of DatasetRow objects with { id, data } properties. | The output will be an object containing the ID, data, and embedding of the new row. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                       | Default Value | Use Input Toggle | Input Data Type |\n| ------- | --------------------------------- | ------------- | ---------------- | --------------- |\n| Dataset | The ID of the dataset to replace. | (required)    | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Replace data in a dataset\n\n1. In the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the ID `employees` and add some data to it.\n2. Create an [Array Node](./array.mdx) for the first row, and set the values to `[\"John Doe\", \"30\", \"Engineer\"]`.\n3. Create another Array Node, disable Flattening on it, and connect the first Array Node to it.\n4. Create a Replace Dataset Node and set the Dataset to `Employees`.\n5. Connect the Array Node to the `Data` input of the Replace Dataset Node.\n6. Run the graph. The `Dataset` output of the Replace Dataset Node should contain the new data that replaced the existing data in the `employees` dataset.\n\n![Replace Dataset Node Example 1.1](./assets/replace-dataset-node-example-01.png)\n\n## Error Handling\n\nThe Replace Dataset Node will error if the dataset provider is not available in the context when the graph is being run.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: What happens if the dataset does not exist?**\n\nA: If the dataset does not exist, the Replace Dataset Node will error.\n\n## See Also\n\n- [Append to Dataset Node](./append-to-dataset.mdx)\n- [Load Dataset Node](./load-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n"]},{"id":"60ZgTHblU-qWKJbM5ci5q","data":["race-inputs.mdx","---\nid: race-inputs\ntitle: Race Inputs Node\nsidebar_label: Race Inputs\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Race Inputs Node Screenshot](./assets/race-inputs-node.png)\n\n## Overview\n\nThe Race Inputs Node is used to handle multiple inputs and outputs the value of the first input to finish, force-cancelling the other inputs. This node is particularly useful when you have multiple operations such as [Chat Node](./chat.mdx) calls that can potentially fulfill the same requirement, and you want to use the result of the operation that finishes first.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                                                                                   | Default Value | Notes                                                            |\n| --------- | --------- | --------------------------------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------- |\n| Input [i] | `any`     | The ith input to be raced. The number of inputs is dynamic based on the number of connections | N/A           | Dynamic number of inputs based on how many connections there are |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                                                                  | Notes                                                                          |\n| ------ | --------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |\n| Result | `any`     | The value of the first input to finish. If no inputs finish, will not be ran | If no inputs finish, this output will not be ran, and the node will not error. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Race two Chats\n\n1. Create a new graph, and add two [Chat Nodes](./chat.mdx) to the graph.\n2. Create a [Prompt Node](./prompt.mdx), and give it a prompt message that will be answered in a short time, such as \"What is your favorite color?\". Connect it to the `Prompt` input of the first Chat Node.\n3. Create another Prompt Node, and give it a prompt message that will take a much longer time, such as \"Describe to me in detail the story of Hamlet.\" Connect it to the `Prompt` input of the second Chat Node.\n4. Connect both outputs of the Chat Nodes to a Race Inputs node.\n5. Run the graph. Notice that the first Chat finishes first, and the value of the Race Inputs node is the response from the first Chat Node. The other Chat Node gets canceled.\n\n![Race Inputs Node Example 1](./assets/race-inputs-node-example-01.png)\n\n## Error Handling\n\nThe Race Inputs Node will not error if none of the inputs finish. Instead, the `Result` output will not be ran.\n\n## FAQ\n\n**Q: What happens if none of the inputs finish?**\n\nA: If none of the inputs finish, the Race Inputs Node will not error. Instead, the `Result` output will not be ran.\n\n**Q: Can I use the Race Inputs Node with inputs of different data types?**\n\nA: Yes, the Race Inputs Node can handle inputs of any data type.\n\n**Q: What happens if one of the inputs errors?**\n\nA: If one of the inputs errors, the Race Inputs Node will not be affected. It will still output the value of the first input to finish, regardless of whether other inputs error.\n\n## See Also\n\n- [HTTP Call Node](./http-call.mdx)\n- [If Node](./if.mdx)\n- [Match Node](./match.mdx)\n- [Coalesce Node](./coalesce.mdx)\n"]},{"id":"V1QjTP5nVVIt2-L21TIFD","data":["extract-json.mdx","---\nid: extract-json\ntitle: Extract JSON Node\nsidebar_label: Extract JSON\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Extract JSON Node Screenshot](./assets/extract-json-node.png)\n\n## Overview\n\nThe Extract JSON node lets you extract an object from a string containing a JSON object or array. Data outside of the JSON object or array will be ignored.\n\nExtract JSON is very useful to extract structured data from LLM responses. Ask the LLM to reply with a JSON object, and then use Extract JSON to extract that data from its response, ignoring any text around the JSON object.\n\n### Algorithm\n\nThe node finds the first instance of `{` or `[`, and the last instance of `}` or `]` in the string. It then extracts the substring between those two points, and attempts to parse it as JSON.\n\nThis process is not iterative at the moment, so if the parsing fails because the text contains, for example, two JSON objects, with text in between, the node will error. Use this node when you are sure that the string contains only one JSON object or array.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                    | Default Value | Notes                                                          |\n| ----- | --------- | -------------------------------------------------------------- | ------------- | -------------------------------------------------------------- |\n| Input | `string`  | The string that a JSON object or array will be extracted from. | (required)    | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                                                                                                    | Notes                                                                                      |\n| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------ |\n| Output   | `object`  | The string or array that was extracted from the string.                                                                        | If there was no string or array found in the input string, then this port will not be ran. |\n| No Match | `string`  | If there was no string or object found in the input text, then this port will run, with the full contents of the input string. | If there was a string or array found in the input string, this port will not be ran.       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract a JSON object from an LLM response\n\n1. Create a [Text Node](./text.mdx), and ask the LLM to reply with JSON:\n   ```\n   Please reply to this message with a JSON object.\n   ```\n2. Create a [Chat Node](./chat.mdx), and connect the Text node to its `Prompt` input.\n3. Create an Extract JSON node, and connect the Chat node to its `Input` input.\n4. Run the graph, and note that you see the JSON object that you replied with in the Extract JSON node's output. The `No Match` output is not ran, because there was a match.\n\n![Extract JSON Example 1](./assets/extract-json-node-example-01.png)\n\n## Error Handling\n\nThis node cannot error under normal circumstances. If the input fails to extract JSON, then the `No Match` output will be executed instead of the `Result` output.\n\n## FAQ\n\n**Q: What if the string contains more than one JSON object?**\n\nA: The node will error. Use this node when you are sure that the string contains only one JSON object or array. For more complex use-cases, you may want to use a [Code Node](./code.mdx) to parse the string in a custom way.\n\n**Q: What if I just want to call `JSON.parse()`?**\n\nA: You can use a [Code Node](./code.mdx) that simply calls JSON.parse() on the input string.\n\n## See Also\n\n- [Extract YAML Node](./extract-yaml.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [To JSON Node](./to-json.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n"]},{"id":"ssAMY0YDvO96RwCKDiwmE","data":["delay.mdx","---\nid: delay\ntitle: Delay Node\nsidebar_label: Delay\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Delay Node Screenshot](./assets/delay-node.png)\n\n## Overview\n\nThe Delay Node is used to introduce a delay in the execution of the graph. It takes any number of inputs and after a specified delay, passes the input values to the outputs without any modifications. This node is useful when you need to control the timing of your graph's execution.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                                  | Default Value | Notes                                                                     |\n| --------- | --------- | -------------------------------------------- | ------------- | ------------------------------------------------------------------------- |\n| Delay     | `number`  | The delay time in milliseconds.              | 0             | This input is only available if the \"Use Delay Input\" setting is enabled. |\n| Input [i] | `any`     | The ith input that will be passed to output. | N/A           | Dynamic number of inputs based on how many connections there are.         |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title     | Data Type | Description                                          | Notes                                                                             |\n| --------- | --------- | ---------------------------------------------------- | --------------------------------------------------------------------------------- |\n| Output[i] | `any`     | The ith output from the execution of the delay node. | The output will be the same as the corresponding input after the specified delay. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting          | Description                                                                                                                                                              | Default Value | Use Input Toggle | Input Data Type |\n| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Function Name    | The delay time in milliseconds. If the \"Use Delay Input\" setting is not enabled, this value will be used as the delay.                                                   | 0             | Yes              | `number`        |\n| Use Error Output | If enabled, then the Delay node will use the \"Delay\" input as the delay time in milliseconds. If disabled, the delay time specified in the \"Delay\" setting will be used. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Delaying a Message\n\n1. Create a Text node and set its value to \"Hello, World!\".\n2. Create a Delay node and set its \"Delay\" setting to 5000 (5 seconds).\n3. Connect the output of the Text node to the first input of the Delay node.\n4. Run the graph. Note that the output of the Delay node is not displayed until after 5 seconds.\n\n![Delay Node Example 1](./assets/delay-node-example-01.png)\n\n## Error Handling\n\nThe Delay node cannot error under normal circumstances. If the delay time is negative, it will be treated as zero.\n\n## FAQ\n\n**Q: What happens if I set the delay time to zero?**\n\nA: The Delay node will pass the input to the output immediately, effectively acting as a pass-through node.\n\n**Q: Can I use the Delay node to throttle API calls?**\n\nA: Yes, you can use the Delay node to throttle API calls. For example, if you have a graph that makes an API call every time it is run, you can use the Delay node to ensure that the API call is not made more than once every 5 seconds.\n\n## See Also\n\n- [Passthrough Node](./passthrough.mdx)\n- [Race Inputs Node](./race-inputs.mdx)\n"]},{"id":"2sOlJ5JhbykEdCM8yExD1","data":["gpt-function.mdx","---\nid: gpt-function\ntitle: GPT Function Node\nsidebar_label: GPT Function\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![GPT Function Node Screenshot](./assets/gpt-function-node.png)\n\n## Overview\n\nThe GPT Function Node allows you to define a function that can be called by OpenAI's GPT in its responses. This is part of GPT's \"function-calling\" capability. The function is defined using JSON Schema.\n\nThe output of the GPT Function Node can be passed into the \"Function\" port of the [Chat Node](./chat.mdx). To enable this, you must check the \"Enable Function Calling\" setting in the Chat Node.\n\nIf you want to pass multiple functions into a Chat Node, all of the functions should be passed into an [Array Node](./array.mdx), and the Array Node goes into the \"Function\" port of the Chat Node.\n\nA function is defined using JSON Schema, which is a vocabulary that allows you to annotate and validate JSON documents. For more information on JSON Schema, see the [official website](https://json-schema.org/).\n\nYou may use interpolation values in the GPT Function schema the same way you can use them in the Text and Prompt nodes. Wrap your interpolation values in double curly braces, e.g. `{{value}}`.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n| Title   | Data Type | Description                                                                                                   | Default Value  | Notes |\n| ------- | --------- | ------------------------------------------------------------------------------------------------------------- | -------------- | ----- |\n| Input N | `string`  | Variable number of inputs for interpolated values such as {{value}} inside the schema definition of the node. | (empty string) |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type      | Description                                                                                                      | Notes |\n| -------- | -------------- | ---------------------------------------------------------------------------------------------------------------- | ----- |\n| Function | `gpt-function` | The function that was defined. This output can be connected to the \"Function\" port of a [Chat Node](./chat.mdx). |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting     | Description                                                                                                         | Default Value | Use Input Toggle | Input Data Type |\n| ----------- | ------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Name        | The name of the function. This is the name that GPT will use to call the function in its responses.                 | `newFunction` | Yes              | `string`        |\n| Description | A description of the function. This is used for documentation purposes and does not affect the function's behavior. | (empty)       | Yes              | `string`        |\n| Schema      | The JSON Schema that defines the function's parameters.                                                             | (empty)       | Yes              | `object`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Define a function that takes a single string parameter\n\n1. Create a GPT Function Node.\n2. Set the `Name` to `greet`.\n3. Set the `Description` to `A function that greets a user`.\n4. Set the `Schema` to the following:\n\n   ```json\n   {\n     \"type\": \"object\",\n     \"properties\": {\n       \"name\": {\n         \"type\": \"string\",\n         \"description\": \"The name of the user\"\n       }\n     },\n     \"required\": [\"name\"]\n   }\n   ```\n\n5. Create a [Chat Node](./chat.mdx) and enable the \"Function\" input port by checking the \"Enable Function Calling\" setting.\n6. Connect the `Function` output of the GPT Function Node to the `Function` input of the Chat Node.\n7. Set the `Prompt` of the Chat Node to the following, using a [Text Node](./text.mdx) or [Prompt Node](./prompt.mdx):\n\n   ```\n   Please call the `greet` function with the name \"John Doe\".\n   ```\n\n8. Run the graph. The Chat Node should output a call to the `greet` function with the parameter `name` set to `\"John Doe\"`.\n\n![GPT Function Node Example 1](./assets/gpt-function-node-example-01.png)\n\n## Error Handling\n\nThe GPT Function Node will error if the `Schema` is not a valid JSON string or if it does not represent a valid JSON Schema.\n\n## FAQ\n\n**Q: Can I define a function that takes multiple parameters?**\n\nA: Yes, you can define a function that takes multiple parameters by adding more properties to the `Schema`. Each property represents a parameter of the function.\n\n**Q: Can I define a function that takes an array or an object as a parameter?**\n\nA: Yes, you can define a function that takes an array or an object as a parameter by setting the `type` of the property in the `Schema` to `array` or `object`.\n\n**Q: Can I define a function that does not take any parameters?**\n\nA: Yes, you can define a function that does not take any parameters by setting the `Schema` to an empty object (`{}`).\n\n**Q: Can I use the GPT Function Node to define a function that returns a value?**\n\nA: No, the GPT Function Node only defines the function's name and parameters. The function's behavior is determined by the rest of the graph.\n\n**Q: How can I connect multiple functions to a Chat Node?**\n\nA: You can connect multiple functions to a Chat Node by passing all of the functions into an [Array Node](./array.mdx), and then connecting the Array Node to the Chat Node.\n\n## See Also\n\n- [Chat Node](./chat.mdx)\n- [Array Node](./array.mdx)\n- [JSON Schema](https://json-schema.org/)\n- [Function Calling Documentation](https://platform.openai.com/docs/guides/gpt/function-calling)\n"]},{"id":"bci78_-EQdeV8jPKhzVps","data":["append-to-dataset.mdx","---\nid: append-to-dataset\ntitle: Append to Dataset Node\nsidebar_label: Append to Dataset\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Append to Dataset Node Screenshot](./assets/append-to-dataset-node.png)\n\n## Overview\n\nThe Append to Dataset Node is used to append a row of data to a specified dataset. This node is particularly useful when you want to add new data to an existing dataset for further processing or analysis.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type              | Description                                                                                                            | Default Value                                               | Notes                                                                      |\n| ---------- | ---------------------- | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------- |\n| Data       | `string` or `string[]` | The data to be appended to the dataset. Each entry in the array corresponds to a column in the new row in the dataset. | (required)                                                  | The input will be coerced into a string array if it is not a string array. |\n| ID         | `string`               | The ID for the new row of data. If not provided, a new ID will be generated.                                           | (Automatically generated)                                   | The input will be coerced into a string if it is not a string.             |\n| Embedding  | `vector`               | An optional vector that can be associated with the new row of data.                                                    | (empty)                                                     | The input will be coerced into a vector if it is not a vector.             |\n| Dataset ID | `string`               | The ID of the dataset to append to. This input is only available if `Use Dataset ID Input` is enabled.                 | (required if if the input toggle for Dataset ID is enabled) | The input will be coerced into a string if it is not a string.             |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type | Description                                           | Notes                                                                                            |\n| ------- | --------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------ |\n| Dataset | `object`  | The new row of data that was appended to the dataset. | The output will be an object containing the ID, data, and embedding of the new row.              |\n| ID      | `string`  | The ID of the dataset that the data was appended to.  | The output will be the same as the Dataset ID input or the Dataset ID specified in the settings. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting              | Description                                                               | Default Value | Use Input Toggle | Input Data Type |\n| -------------------- | ------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Dataset              | The ID of the dataset to append to.                                       | (required)    | Yes              | `string`        |\n| Use Dataset ID Input | If enabled, the Dataset ID can be provided via the Dataset ID input port. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Append data to a dataset\n\n1. Create an [Array Node](./array.mdx) and set the values to `[\"John Doe\", \"30\", \"Engineer\"]`.\n2. In the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the ID `employees`.\n3. Create an Append to Dataset Node and set the Dataset ID to `employees`.\n4. Connect the Array Node to the `Data` input of the Append to Dataset Node.\n5. Run the graph. The `Dataset` output of the Append to Dataset Node should contain the new row of data that was appended to the `employees` dataset.\n\n![Append to Dataset Node Example 1.1](./assets/append-to-dataset-node-example-01.png)\n![Append to Dataset Node Example 1.2](./assets/append-to-dataset-node-example-01-2.png)\n\n## Error Handling\n\nThe Append to Dataset Node will error if the dataset provider is not available in the context when the graph is being run. It will also error if the `Data` input is not provided.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I append data to multiple datasets at once?**\n\nA: No, the Append to Dataset Node can only append data to one dataset at a time. If you want to append data to multiple datasets, you can use multiple Append to Dataset Nodes.\n\n**Q: What happens if the dataset does not exist?**\n\nA: If the dataset does not exist, the Append to Dataset Node will error.\n\n## See Also\n\n- [Load Dataset Node](./load-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n"]},{"id":"IH2QTeq06lesLZUxrVSPb","data":["trim-chat-messages.mdx","---\nid: trim-chat-messages\ntitle: Trim Chat Messages Node\nsidebar_label: Trim Chat Messages\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Trim Chat Messages Node Screenshot](./assets/trim-chat-messages-node.png)\n\n## Overview\n\nThe Trim Chat Messages Node is used to manage the length of chat message chains in terms of tokens. It takes an array of chat messages and trims messages from either the beginning or the end of the list until the total length of the messages is under the configured token length. This is particularly useful for setting up infinite message chains that stay under the language model's context limit.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type        | Description                         | Default Value | Notes |\n| ----- | ---------------- | ----------------------------------- | ------------- | ----- |\n| Input | `chat-message[]` | The array of chat messages to trim. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type        | Description                                                                                      | Notes |\n| ------- | ---------------- | ------------------------------------------------------------------------------------------------ | ----- |\n| Trimmed | `chat-message[]` | The array of chat messages after being trimmed to fit within the configured maximum token count. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting               | Description                                                                                                              | Default Value | Use Input Toggle | Input Data Type |\n| --------------------- | ------------------------------------------------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Max Token Count       | The maximum token count for the total length of the chat messages.                                                       | 4096          | No               | `number`        |\n| Remove From Beginning | If enabled, messages will be removed from the beginning of the list. If disabled, messages will be removed from the end. | true          | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Trim a long chat message chain\n\n1. Create an [Array Node](./array.mdx) and set the value to an array of chat messages that exceeds a certain token count.\n2. Create a Trim Chat Messages Node and connect the Array Node to its `Input` port. Set the `Max Token Count` to a value lower than the total token count of the chat messages.\n3. Run the graph. The `Trimmed` output of the Trim Chat Messages Node should contain an array of chat messages with a total token count that does not exceed the configured `Max Token Count`.\n\n   ![Trim Chat Messages Node Example 1](./assets/trim-chat-node-example-01.png)\n\n## Error Handling\n\nThe Trim Chat Messages Node does not have any notable error handling behavior. If the input is not an array of chat messages, it will be coerced into one.\n\n## FAQ\n\n**Q: What happens if the `Max Token Count` is set to a value lower than the token count of a single chat message?**\n\nA: The Trim Chat Messages Node will keep removing messages until the total token count is under the `Max Token Count`. If a single chat message exceeds the `Max Token Count`, the `Trimmed` output will be an empty array.\n\n**Q: Can I use the Trim Chat Messages Node to trim an array of strings or other data types?**\n\nA: No, the Trim Chat Messages Node is specifically designed to work with arrays of chat messages. If you need to trim an array of other data types, you may need to use a different node or a custom solution.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Chat Node](./chat.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Code Node](./code.mdx)\n"]},{"id":"W5_k63qCt-3h7xUuO7Ut9","data":["evaluate.mdx","---\nid: evaluate\ntitle: Evaluate Node\nsidebar_label: Evaluate\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Evaluate Node Screenshot](./assets/evaluate-node.png)\n\n## Overview\n\nThe Evaluate Node performs a mathematical operation on the input values and outputs the result. It supports a variety of operations including addition, subtraction, multiplication, division, exponentiation, modulus, absolute value, and negation.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                           | Default Value                   | Notes                                                          |\n| ----- | --------- | ------------------------------------- | ------------------------------- | -------------------------------------------------------------- |\n| A     | `number`  | The first operand for the operation.  | (Required)                      | The input will be coerced into a number if it is not a number. |\n| B     | `number`  | The second operand for the operation. | (Required for binary operators) | The input will be coerced into a number if it is not a number. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                  | Notes |\n| ------ | --------- | ---------------------------- | ----- |\n| Output | `number`  | The result of the operation. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                                                                      | Default Value | Use Input Toggle | Input Data Type |\n| --------- | ---------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Operation | The operation to perform on the input values. Options include `+`, `-`, `*`, `/`, `^`, `%`, `abs`, and `negate`. | `+`           | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Performing a simple addition\n\n1. Create an Evaluate Node and set the `Operation` to `+`.\n2. Create two Number nodes, set their values to `2` and `3` respectively.\n3. Connect the Number nodes to the `A` and `B` inputs of the Evaluate Node.\n4. Run the graph. The output of the Evaluate Node should be `5`.\n\n![Evaluate Node Example 1](./assets/evaluate-node-example-01.png)\n\n## Error Handling\n\nIf the operation fails (for example, if you try to divide by zero), the Evaluate node will error.\n\n## FAQ\n\n**Q: What if I want to perform a different operation based on the input?**\n\nA: You can use the `Operation` input port to dynamically change the operation based on the input. The input will be coerced into a string and must match one of the supported operations.\n\n## See Also\n\n- [Number Node](./number.mdx)\n- [Code Node](./code.mdx)\n- [Compare Node](./compare.mdx)\n"]},{"id":"jYL6PKS6SEHvXQ3Hip3HA","data":["user-input.mdx","---\nid: user-input\ntitle: User Input Node\nsidebar_label: User Input\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![User Input Node Screenshot](./assets/user-input-node.png)\n\n## Overview\n\nThe User Input Node is designed to prompt the user for input during the execution of the graph. The user's response becomes the output of this node. This node is particularly useful in interactive scenarios where user input is required to proceed with the graph execution.\n\nThe User Input Node can either use a static prompt defined in the node settings or dynamic prompts provided via the node's input.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type  | Description                               | Default Value | Notes                                                                                     |\n| --------- | ---------- | ----------------------------------------- | ------------- | ----------------------------------------------------------------------------------------- |\n| Questions | `string[]` | An array of questions to prompt the user. | N/A           | This input is only available when the \"Use Input\" toggle is enabled in the node settings. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title        | Data Type  | Description                                                                    | Notes |\n| ------------ | ---------- | ------------------------------------------------------------------------------ | ----- |\n| Answers Only | `string[]` | An array containing the user's answers to the prompted questions.              |       |\n| Q & A        | `string[]` | An array containing the questions and answers formatted as \"Question\\nAnswer\". |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                      | Default Value | Use Input Toggle | Input Data Type |\n| ------- | -------------------------------- | ------------- | ---------------- | --------------- |\n| Prompt  | The question to prompt the user. | (required)    | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Using a static prompt\n\n1. Create a User Input Node.\n2. In the node settings, set the \"Prompt\" to \"What is your name?\".\n3. Run the graph. The graph execution will pause and prompt you for input.\n4. Enter your name and press \"Submit\". The graph execution will resume and the output of the User Input Node will be the name you entered.\n\n![User Input Node Example 1](./assets/user-input-node-example-01.png)\n\n## Example 2: Using dynamic prompts\n\n1. Create a User Input Node.\n2. In the node settings, enable the \"Use Input\" toggle.\n3. Create an [Array Node](./array.mdx) and connect 2 [Text Nodes](./text.mdx) to it.\n4. Add the text \"What is your name?\" to the first Text Node and \"What is your favorite color?\" to the second Text Node.\n5. Connect the Array Node to the \"Questions\" input of the User Input Node.\n6. Run the graph. The graph execution will pause and prompt you for input.\n7. Enter your answers and press \"Submit\". The graph execution will resume and the output of the User Input Node will be an array containing your answers.\n\n![User Input Node Example 2](./assets/user-input-node-example-02.png)\n\n## Error Handling\n\nThe User Input Node does not have any error handling behavior. If the node is executed, it will always pause the graph execution and prompt the user for input.\n\n## FAQ\n\n**Q: Can I use the User Input Node to prompt the user for multiple inputs at once?**\n\nA: Yes, you can do this by connecting an Array Node to the \"Questions\" input of the User Input Node. Each item in the array will be a separate question that the user is prompted for.\n\n**Q: What happens if the user does not provide any input?**\n\nA: If the user does not provide any input and presses \"Submit\", the output of the User Input Node will be an empty string.\n\n**Q: Can I use the User Input Node to prompt the user for a password or other sensitive information?**\n\nA: No, the User Input Node does not currently support masking the user's input. All input provided by the user will be visible in the graph execution log.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Text Node](./text.mdx)\n- [Split Node](./split-text.mdx)\n- [Join Node](./join.mdx)\n"]},{"id":"YtAh8ZHPPy9j5tGEIiZA3","data":["passthrough.mdx","---\nid: passthrough\ntitle: Passthrough Node\nsidebar_label: Passthrough\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Passthrough Node Screenshot](./assets/passthrough-node.png)\n\n## Overview\n\nThe Passthrough Node is a simple node that passes the input value to the output without any modifications. This node can be useful in scenarios where you want to pass a value through a certain path in your graph without altering it, such as grouping together values from different branches of your graph, or controlling how wires flow through your graph.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                        | Default Value | Notes                                                            |\n| --------- | --------- | ---------------------------------- | ------------- | ---------------------------------------------------------------- |\n| Input [i] | `any`     | The ith input to be passed through | N/A           | Dynamic number of inputs based on how many connections there are |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type | Description                         | Notes                                                             |\n| ---------- | --------- | ----------------------------------- | ----------------------------------------------------------------- |\n| Output [i] | `any`     | The ith output from the passthrough | Dynamic number of outputs based on how many connections there are |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node does not have any specific settings.\n\n</TabItem>\n\n</Tabs>\n\n## Error Handling\n\nThe Passthrough Node does not have any error handling. If an input is missing or null, the corresponding output will also be missing or null.\n\n## FAQ\n\n**Q: What happens if an input is missing or null?**\n\nA: If an input is missing or null, the corresponding output will also be missing or null.\n\n## See Also\n\n- [If Node](./if.mdx)\n- [Match Node](./match.mdx)\n- [Coalesce Node](./coalesce.mdx)\n- [Race Inputs Node](./race-inputs.mdx)\n"]},{"id":"-rLd_mnkl7Dnwuve2FJhP","data":["array.mdx","---\nid: array\ntitle: Array Node\nsidebar_label: Array\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\nimport Admonition from '@theme/Admonition';\n\n## Overview\n\nThe Array Node is used to construct an array from one or more inputs of any type. It can also be used to merge multiple arrays into a single array using the `Flatten` setting.\n\nBy default, inputs will be flattened, so if any of the inputs are arrays themselves, they will be merged into the output array. This behavior can be disabled by unchecking the `Flatten` setting.\n\n![Array Node Screenshot](./assets/array-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                            | Default Value | Notes                                                            |\n| --------- | --------- | -------------------------------------- | ------------- | ---------------------------------------------------------------- |\n| Input [i] | any       | The ith input to be added to the array | N/A           | Dynamic number of inputs based on how many connections there are |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type | Description                              | Notes                                                                 |\n| ------- | --------- | ---------------------------------------- | --------------------------------------------------------------------- |\n| Output  | any[]     | The array created from the inputs        | The output will be a single array containing all valid inputs         |\n| Indices | number[]  | The indices of the elements in the array | The output will be an array of numbers representing the array indices |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                               | Default Value | Use Input Toggle |\n| ------- | --------------------------------------------------------- | ------------- | ---------------- |\n| Flatten | If enabled, array inputs will be flattened before joining | true          | No               |\n| Deep    | If enabled, array inputs will be flattened recursively    | false         | No               |\n\n</TabItem>\n\n</Tabs>\n\n### Example 1: Creating an Array from Multiple Inputs\n\nLet's say you have three Text nodes: one with the value `\"Hello\"`, another with the value `\"World\"`, and the last one with the value `\"!\"`. If you want to create an array from these three strings, you can do the following:\n\n1. Add an Array Node to your graph.\n2. Connect the output of the first Text node to `Input 1` of the Array Node.\n3. Connect the output of the second Text node to `Input 2` of the Array Node.\n4. Connect the output of the third Text node to `Input 3` of the Array Node.\n\nThe `Output` of the Array Node will now be `[\"Hello\", \"World\", \"!\"]`.\n\n### Example 2: Creating an Array from Array Inputs\n\nImagine you have two Array nodes: one with the value `[\"One\", \"Two\"]` and the other with the value `[\"Three\", \"Four\"]`. If you want to create a new array from these two arrays, you can do the following:\n\n1. Add an Array Node to your graph.\n2. Connect the output of the first Array node to `Input 1` of the Array Node.\n3. Connect the output of the second Array node to `Input 2` of the Array Node.\n4. Enable the `Flatten` setting.\n\nThe `Output` of the Array Node will now be `[\"One\", \"Two\", \"Three\", \"Four\"]`.\n\n### Example 3: Creating an Array without Flattening\n\nIf you want to create an array from arrays without flattening them, you can do the same steps as in Example 2, but leave the `Flatten` setting disabled. The `Output` of the Array Node will then be `[[\"One\", \"Two\"], [\"Three\", \"Four\"]]`.\n\n### Example 4: Using the Indices Output\n\nLet's say you have an Array Node with the value `[\"Apple\", \"Banana\", \"Cherry\"]`. If you want to create a new array where each element is a string that includes the index and the corresponding fruit name from the original array, you can do the following:\n\n1. Add a Text Node to your graph with the text `\"[{{index}}] - {{fruit}}\"`.\n2. Connect the `Output` of the Array Node to the `Fruit` input of the Text Node.\n3. Connect the `Indices` output of the Array Node to the `Index` input of the Text Node.\n4. Enable the `Split` setting on the Text Node.\n\nThe `Output` of the Text Node will now be `[\"[0] - Apple\", \"[1] - Banana\", \"[2] - Cherry\"]`.\n\nIn this example, the `Indices` output of the Array Node gives us an array of indices that corresponds to the elements of the original array. We then use these indices along with the original array elements to create a new array of formatted strings. The `Split` setting ensures that the Text Node generates a separate output for each element of the input arrays.\n\n![Array Node Example 4](./assets/array-node-example-04.png)\n\n## Flattening Arrays\n\nThe Array Node has a `Flatten` setting. When enabled, this setting treats each element of an array input as a separate element to be added to the main array. This is particularly useful when you're dealing with array inputs and want to merge all elements of these arrays into a single array.\n\n:::caution\n\nNote that with flatten disabled you can get arrays of arrays. These are not well supported in Rivet and you may have to use a [Code Node](./code) to work with them.\n\n:::\n\nIf the `Deep` setting is enabled, the Array Node will recursively flatten all array inputs. This means that if an array input contains another array, the Array Node will flatten the inner array as well. You can\nuse the Array Node as a Flatten node this way.\n\n## Error Handling\n\nIf an input is missing or null, the Array Node will simply ignore it during the array creation process. This can be useful when dealing with optional inputs that may not always be present.\n\n**Q: What happens if I connect a non-array node to the Array Node?**\n\nA: The Array Node is designed to work with any type of inputs. If a non-array input is connected, the node will treat it as a single element to be added to the array.\n\n**Q: Can I connect an Array Node to another Array Node?**\n\nA: Yes, you can connect an Array Node to another Array Node. If the `Flatten` setting is enabled, each element of the input array will be treated as a separate element to be added to the main array. If `Flatten` is disabled, the input array will be added as a single element to the main array.\n\n**Q: What happens if an input is missing or null?**\n\nA: If an input is missing or null, the Array Node will simply ignore it during the array creation process. This can be useful when dealing with optional inputs that may not always be present.\n\n## See Also\n\n- [Code Node](./code.mdx)\n- [Text Node](./text.mdx)\n- [Number Node](./number.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Pop Node](./pop.mdx)\n"]},{"id":"1skaZ1qNyTAOByd604XMt","data":["_template2.mdx","#### Inputs\n\n| Title | Data Type | Description | Default Value | Notes |\n| ----- | --------- | ----------- | ------------- | ----- |\n| TITLE | DATA_TYPE | DESCRIPTION | DEFAULT_VALUE | NOTES |\n\n#### Outputs\n\n| Title | Data Type | Description | Notes |\n| ----- | --------- | ----------- | ----- |\n| TITLE | DATA_TYPE | DESCRIPTION | NOTES |\n\n#### Editor Settings\n\n| Setting | Description | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ----------- | ------------- | ---------------- | --------------- |\n| SETTING | DESCRIPTION | DEFAULT_VALUE | USE_INPUT_TOGGLE | INPUT_DATA_TYPE |\n\n#### Error Handling\n\nERROR_HANDLING_HERE\n\n#### FAQ\n\n**Q: QUESTION?**\n\nA: ANSWER\n"]},{"id":"DyeXTeC5524jz6bwFvVqo","data":["wait-for-event.mdx","---\nid: wait-for-event\ntitle: Wait For Event Node\nsidebar_label: Wait For Event\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Wait For Event Node Screenshot](./assets/wait-for-event.png)\n\n## Overview\n\nThe Wait For Event Node is used to pause the execution of a graph until a specific event is raised by a [Raise Event Node](./raise-event.mdx) or the host project. The event name can be configured in the node settings or provided dynamically via an input port.\n\nThis node is useful in scenarios where you want to wait for an external event to occur before proceeding with the graph execution. For example, you might want to wait for a user to click a button, or for an API call to complete.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                             | Default Value | Notes                                                    |\n| ----- | --------- | --------------------------------------- | ------------- | -------------------------------------------------------- |\n| Data  | `any`     | Any data to be passed through the node. | N/A           | This data will be outputted from the `Data` output port. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type | Description                                         | Notes                                                                    |\n| ---------- | --------- | --------------------------------------------------- | ------------------------------------------------------------------------ |\n| Data       | `any`     | The data passed in through the `Data` input port.   | If no data is passed into the `Data` input port, this port will not run. |\n| Event Data | `any`     | The data associated with the event that was raised. | If the event has no associated data, this port will not run.             |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting    | Description                                                                                                             | Default Value | Use Input Toggle | Input Data Type |\n| ---------- | ----------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Event Name | The name of the event to wait for. Must match the name of the event raised by the Raise Event Node or the host project. | `continue`    | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Wait for an event raised by a Raise Event Node\n\n1. Create a [Raise Event Node](./raise-event.mdx) and set the `Event Name` to `myEvent`.\n2. Create a Wait For Event Node and set the `Event Name` to `myEvent`.\n3. Connect a text node to the Data input port of the Raise Event Node with the text as `Raise Event`.\n4. Connect a text node to the Data input port of the Wait For Event Node with the text as `Waited`.\n5. Connect the output ports of the Raise Event Node and Wait For Event Node to the input ports of text nodes.\n6. Run the graph. The Wait For Event Node will wait until the Raise Event Node raises the `myEvent` event.\n7. Notice how the Wait For Event Node outputs the data from the Raise Event Node from the `Event Data` output port.\n\n![Wait For Event Node Example 1](./assets/wait-for-event-example-01.png)\n\n## Error Handling\n\nThe Wait For Event Node cannot error under normal circumstances. If the event is not raised, the node will wait indefinitely.\n\n## FAQ\n\n**Q: Can I use the Wait For Event Node to wait for multiple events?**\n\nA: No, the Wait For Event Node can only wait for a single event. If you want to wait for multiple events, you can use multiple Wait For Event Nodes.\n\n**Q: Can I use the Wait For Event Node to wait for an event raised by an API call?**\n\nA: Yes, you can use the [HTTP Call Node](./http-call.mdx) to make an API call, and then use the Wait For Event Node to wait for an event raised by the API call.\n\n## See Also\n\n- [Raise Event Node](./raise-event.mdx)\n- [HTTP Call Node](./http-call.mdx)\n- [External Call Node](./external-call.mdx)\n- [Code Node](./code.mdx)\n"]},{"id":"s0axMMM2mflBB16QT_sDv","data":["http-call.mdx","---\nid: http-call\ntitle: HTTP Call Node\nsidebar_label: HTTP Call\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![HTTP Call Node Screenshot](./assets/http-call-node.png)\n\n## Overview\n\nThe HTTP Call Node allows you to make an HTTP call to a specified URL with a given method, headers, and body. This node is particularly useful when you need to interact with external APIs or services.\n\nThe HTTP Call Node uses the Fetch API to make HTTP requests. It supports all HTTP methods (GET, POST, PUT, DELETE, etc.) and allows you to specify custom headers and a request body.\n\n:::caution\nWhen using the default [browser executor](../user-guide/executors.md), you have to worry about [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) when making HTTP requests to external APIs. If the API you are trying to call does not support CORS to `http://tauri.local` (most do not), you will run into CORS problems. This can manifest as an error `fetch failed` in the output panel.\n\nThis can be worked around by using the [Node executor](../user-guide/executors.md) in Rivet, which does not do CORS checks.\n:::\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\nThe HTTP call node only has inputs when the [Editor Settings](#editor-settings) are set to use input toggles. See that section for more information.\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title       | Data Type | Description                                                                             | Notes                                                                   |\n| ----------- | --------- | --------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- |\n| Body        | `string`  | The body of the HTTP response.                                                          | If the response body is not a string, this output will not be ran.      |\n| JSON        | `object`  | If the response body is a JSON object, this output will contain the parsed JSON object. | If the response body is not a JSON object, this output will not be ran. |\n| Status Code | `number`  | The status code of the HTTP response.                                                   |                                                                         |\n| Headers     | `object`  | The headers of the HTTP response.                                                       |                                                                         |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting                      | Description                                                                                                                                                                                         | Default Value | Use Input Toggle | Input Data Type |\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Method                       | The HTTP method to use for the request (GET, POST, PUT, DELETE, etc.).                                                                                                                              | GET           | Yes              | `string`        |\n| URL                          | The URL to make the HTTP request to.                                                                                                                                                                | (empty)       | Yes              | `string`        |\n| Headers                      | An object representing the headers to include in the HTTP request.                                                                                                                                  | (empty)       | Yes              | `object`        |\n| Body                         | The body of the HTTP request. This is typically used for POST or PUT requests. The value passed in here is not JSON stringified, so if you need a JSON body, use the [To JSON](./to-json.mdx) node. | (empty)       | Yes              | `string`        |\n| Error on non-200 status code | If enabled, the node will error if the status code of the HTTP response is not 200.                                                                                                                 | True          | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Make a GET request to an API\n\n1. Create an HTTP Call Node and set the `Method` to `GET` and the `URL` to `https://jsonplaceholder.typicode.com/todos/1`.\n2. Run the graph. You should see all of the response data, such as the headers, response code, and body, in the output panel.\n\n![HTTP Call Node Example 1](./assets/http-call-node-example-01.png)\n\n## Example 2: Make a POST request to an API\n\n1. Create an HTTP Call Node and set the `Method` to `POST` and the `URL` to `https://jsonplaceholder.typicode.com/posts`. Enable the \"Use Input\" toggle on the \"Body\" setting to enable the input port for Body.\n2. Create an [Object Node](./object.mdx) and set the object to:\n\n```json\n{\n  \"title\": \"foo\",\n  \"body\": \"bar\",\n  \"userId\": 1\n}\n```\n\n3. Create a [To JSON Node](./to-json.mdx) and connect the Object Node to the `Data` input of the To JSON Node. Connect the To JSON Node to the `Body` input of the HTTP Call Node.\n4. Create an [Extract Object Path](./extract-object-path.mdx) Node and connect the `JSON` output of the HTTP Call Node to the `Object` input of the Extract Object Path Node. Set the `Path` to `$.id`.\n5. Run the graph. You should see the created ID of the post in the Extract Object Path Node's output panel.\n\n![HTTP Call Node Example 2](./assets/http-call-node-example-02.png)\n\n## Error Handling\n\nThe HTTP Call Node will error if the HTTP request fails for any reason, such as a network error or if the server returns an error status code. If the `Error on non-200 status code` setting is enabled, the node will also error if the status code of the HTTP response is not 200.\n\n## FAQ\n\n**Q: Can I use the HTTP Call Node to make requests to any API?**\n\nA: Yes, you can use the HTTP Call Node to make requests to any API that supports the HTTP methods GET, POST, PUT, or DELETE.\n\n**Q: Can I use the HTTP Call Node to send JSON in the request body?**\n\nA: Yes, you can use a [Text Node](./text.mdx) to create a JSON string and connect it to the `Body` input of the HTTP Call Node.\n\n**Q: Can I use the HTTP Call Node to handle API authentication?**\n\nA: Yes, you can include authentication headers in the `Headers` input of the HTTP Call Node. However, for security reasons, you should not hardcode sensitive information like API keys in your graphs. Instead, consider using a [Context Node](./context.mdx) to securely pass in sensitive information from the host application.\n\n## See Also\n\n- [To JSON Node](./to-json.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Text Node](./text.mdx)\n- [Context Node](./context.mdx)\n"]},{"id":"YjFmeGsIu_tkrX7G3eFJl","data":["external-call.mdx","---\nid: external-call\ntitle: External Call Node\nsidebar_label: External Call\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![External Call Node Screenshot](./assets/external-call-node.png)\n\n## Overview\n\nWhen Rivet is running from a host application running `@ironclad/rivet-core` or `@ironclad/rivet-node`, then you can attach \"External Functions\" when running graphs or creating a GraphProcessor. The following external function `sum` will sum all of its arguments:\n\n```ts\nimport { runGraphInFile } from '@ironclad/rivet-node';\n\nawait runGraphInFile({\n  ...etc,\n  externalFunctions: {\n    sum: (...args) => {\n      return {\n        type: 'number',\n        value: args.reduce((acc, curr) => acc + curr, 0);\n      }\n    }\n  }\n})\n```\n\nYou can then call these external functions from within a graph using the `External Call` node. The function to call is configured in the editor for the External Call node, and must match the name of the function you passed to `externalFunctions` when running the graph.\n\nExternal functions are useful for many use-cases, they can do things like:\n\n- Get data from your database\n- Call web APIs\n- Get user information about who is running the graph\n- Anything else you can think of!\n\nExternal functions are extremely powerful. They can only be used when running Rivet from a host application, and are not available when running Rivet in the Rivet applicaton. The external function nodes will error when running in the Rivet application. Use [Remote Debugging](../user-guide/remote-debugging.md) to run External Call nodes in the Rivet application.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type        | Description                                   | Default Value | Notes                                                                                                                          |\n| --------- | ---------------- | --------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------ |\n| Arguments | `any` or `any[]` | The arguments to pass into the external call. | (empty array) | To pass in multiple arguments, they must be an array. You can use an [Array Node](./array.mdx) to create an array of any data. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                                                            | Notes                                                                                                              |\n| ------ | --------- | ---------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| Result | (any)     | The value returned from the external call.                             | Can be any data type, make sure you're returning what you expect!                                                  |\n| Error  | `string`  | If the external call errors, will be populated with the error message. | Only enabled if `Use Error Output` is turned on. If `Use Error Output` is turned off, the node will error instead. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting          | Description                                                                                                                                                                                                | Default Value  | Use Input Toggle | Input Data Type |\n| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------- | --------------- |\n| Function Name    | The name of the external function as defined in `externalFunctions`. Must match the function name defined in your code.                                                                                    | (empty string) | Yes              | `string`        |\n| Use Error Output | If enabled, then the External Call node will not fail, but instead any error will appear in the `Error` output port of the node. If disabled, the entire External Call node will error if the call errors. | False          | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Make a database call from a graph\n\nIn this example, we'll create a graph that makes a database call to get metadata about a single user. First, we'll define the external function that will make the database call:\n\n```ts\nimport { runGraphInFile } from '@ironclad/rivet-node';\n\nconst db = {\n  async getUser(id: string) {\n    return {\n      name: 'test user',\n    };\n  },\n};\n\nawait runGraphInFile({\n  ...etc,\n  externalFunctions: {\n    getUser: async (userId: string) => {\n      const user = await db.getUser(userId);\n      return {\n        type: 'object',\n        value: user,\n      };\n    },\n  },\n});\n```\n\nThen, in your graph, create an External Call Node, and set the `Function Name` to `getUser`. Create a [Text Node](./text.mdx) and set the text to the user's ID. Connect the Text Node to the External Call Node. The graph should look like this:\n\n![External Call Node Example 1](./assets/external-call-node-example-01.png)\n\nRun your application, and connect the [Remote Debugger](../user-guide/remote-debugging.md) to it. Then, run the graph. You should see the object returned from the database call in the External Call node.\n\n## Error Handling\n\nIf the external function errors, then the External Call node will error. If you want to handle errors in the graph, then you can enable the `Use Error Output` setting. This will cause the External Call node to not error, but instead pass the error message to the `Error` output port. If the `Error` port is populated, then the `Result` port will not be ran. You can use an [If Node](./if.mdx) to check if the `Error` port is populated, and handle the error accordingly.\n\n## FAQ\n\n**Q: Can I use external functions when running Rivet in the Rivet application?**\n\nNo, external functions are only available when running Rivet from a host application. Connect the [Remote Debugger](../user-guide/remote-debugging.md) to your host application to run external functions in the Rivet application.\n\n**Q: What do I return from an external function?**\n\nYou must return a valid [Data Value](../api-reference/core/DataValue.mdx) with a valid [Data Type](../user-guide/data-types.md), for example to return a string:\n\n```ts\n{\n  type: 'string',\n  value: 'hello world',\n}\n```\n\n**Q: Can I return a Promise from an external function?**\n\nYes, you can return a Promise from an external function. The External Call node will wait for the Promise to resolve before continuing.\n\n**Q: How are external functions different from raising events?**\n\nExternal functions are synchronous, and can return data. Raising events are asynchronous, and cannot return data. The Raise Event node will not wait for the event to be handled before continuing, while the External Call node will wait for the external function to return before continuing.\n\n## See Also\n\n- [Remote Debugging](../user-guide/remote-debugging.md)\n- [Context Node](./context.mdx)\n- [Raise Event Node](./raise-event.mdx)\n"]},{"id":"baJMpj2NnehYige1tbFbS","data":["bool.mdx","---\nid: bool\ntitle: Bool Node\nsidebar_label: Bool\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Bool Node Screenshot](./assets/bool-node.png)\n\n## Overview\n\nThe Bool Node is used to output a boolean constant or convert an input value into a boolean. This node can be useful when you need to create a boolean value for use in other nodes, such as the [If Node](./if.mdx) or [If/Else Node](./if-else.mdx).\n\nThe Bool Node can either output a constant boolean value that you set in the node's settings, or it can take an input and convert it into a boolean. The conversion follows JavaScript's rules for truthy and falsy values, with two exception:\n\n- Empty arrays are considered falsey\n- The string \"false\" is considered falsey.\n\nIf you need to treat empty arrays as truthy, or the string \"false\" as truthy, you can use the [Code Node](./code.mdx)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                                     | Default Value | Notes |\n| ----- | --------- | ----------------------------------------------------------------------------------------------- | ------------- | ----- |\n| Input | `any`     | The value to be converted to a boolean. This input is only available if `Use Input` is enabled. | N/A           |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                                                                        | Notes |\n| ----- | --------- | -------------------------------------------------------------------------------------------------- | ----- |\n| Value | `boolean` | The boolean value. If `Use Input` is enabled, this will be the input value converted to a boolean. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                                                                                | Default Value | Use Input Toggle | Input Data Type |\n| --------- | -------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Value     | The constant boolean value to output. This setting is only available if `Use Input` is disabled.                           | `false`       | Yes              | `boolean`       |\n| Use Input | If enabled, the node will convert an input value to a boolean. If disabled, the node will output a constant boolean value. | `false`       | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Using a Constant Boolean Value\n\n1. Add a Bool Node to your graph.\n2. Set the `Value` setting to `true`.\n3. Run the graph. The `Value` output of the Bool Node will be `true`.\n\n## Example 2: Converting an Input to a Boolean\n\n1. Add a Bool Node to your graph.\n2. Enable the `Use Input` setting.\n3. Add a [Text Node](./text.mdx) to your graph and set the text to `\"Hello\"`.\n4. Connect the output of the Text Node to the `Input` of the Bool Node.\n5. Run the graph. The `Value` output of the Bool Node will be `true`, because the string `\"Hello\"` is a truthy value in JavaScript.\n\n## Error Handling\n\nThe Bool Node cannot error under normal circumstances. If the `Use Input` setting is enabled and no input is connected, the node will output `false`.\n\n## FAQ\n\n**Q: What values are considered truthy and falsy in JavaScript?**\n\nA: The following values are considered falsy:\n\n- `false`\n- `0`\n- `''` (empty string)\n- `null`\n- `undefined`\n- `NaN`\n- **In Rivet, empty arrays are also considered falsy.**\n- **In Rivet, the string \"false\" is also considered falsy.**\n\nAll other values are considered truthy.\n\n**Q: Can I use the Bool Node to check if an array is empty?**\n\nA: Yes, if you connect an array to the `Input` of a Bool Node, the `Value` output will be `false` if the array is empty. If the array is not empty, the `Value` output will be `true`.\n\n**Q: Can I use the Bool Node to check if a string is empty?**\n\nA: Yes, you can connect a [Text Node](./text.mdx) to the `Input` of a Bool Node. If the string is empty, the `Value` output of the Bool Node will be `false`. If the string is not empty, the `Value` output will be `true`.\n\n**Q: Can I use the Bool Node to check if a number is zero?**\n\nA: Yes, you can connect a [Number Node](./number.mdx) to the `Input` of a Bool Node. If the number is zero, the `Value` output of the Bool Node will be `false`. If the number is not zero, the `Value` output will be `true`.\n\n## See Also\n\n- [If Node](./if.mdx)\n- [Match Node](./match.mdx)\n- [Text Node](./text.mdx)\n- [Array Node](./array.mdx)\n- [Number Node](./number.mdx)\n"]},{"id":"qtOSdA7MwAB4VFd9Nxi7S","data":["vector-store.mdx","---\ntitle: 'Vector Store'\n---\n\n# Vector Store Node\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Chat Node Screenshot](./assets/vector-store-node.png)\n\n## Overview\n\nThe Vector Store Node takes a vector embedding and stores it in a vector store. The vector store can then be used to perform similarity searches.\n\nThe Vector Store Node is used to store vectors in a vector database. It takes in a vector and data to store with the vector. This data is stored in the configured vector database integration for later retrieval.\n\nThe Vector Store Node is part of the Input/Output group of nodes.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title         | Data Type | Description                                                                                     | Default Value | Notes                                                                         |\n| ------------- | --------- | ----------------------------------------------------------------------------------------------- | ------------- | ----------------------------------------------------------------------------- |\n| Vector        | `vector`  | The vector to be stored.                                                                        | (required)    |                                                                               |\n| Data          | `any`     | The data to be stored with the vector.                                                          | (required)    |                                                                               |\n| ID            | `string`  | The ID to be used for the vector. If not provided, a unique ID will be generated automatically. | (optional)    |                                                                               |\n| Integration   | `string`  | The name of the vector database integration to use.                                             | (optional)    | Only required if `Use Integration Input` is enabled in the Editor Settings.   |\n| Collection ID | `string`  | The ID of the collection in the vector database where the vector will be stored.                | (optional)    | Only required if `Use Collection ID Input` is enabled in the Editor Settings. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                                                                         | Notes |\n| -------- | --------- | --------------------------------------------------------------------------------------------------- | ----- |\n| Complete | `boolean` | Indicates whether the vector has been successfully stored. Returns `true` if storage is successful. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                                      | Default Value | Use Input Toggle | Input Data Type |\n| ------------- | -------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Integration   | The name of the vector database integration to use.                              | `pinecone`    | Yes              | `string`        |\n| Collection ID | The ID of the collection in the vector database where the vector will be stored. | (empty)       | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Storing a vector in a vector database\n\n1. Create a Vector Store Node. Set the `Integration` to the name of your vector database integration and the `Collection ID` to the ID of the collection where you want to store the vector.\n2. Create a [Text Node](./text.mdx) or any other node that outputs data and connect a [Get Embedding Node](./get-embedding) to create a vector of the data.\n3. Connect the `Embedding` output of the Get Embedding Node to the `Vector` input of the Vector Store Node.\n4. Connect the `Output` of the Text Node to the `Data` input of the Vector Store Node.\n5. Create a [Text Node](./text.mdx) and update it's text to a unique ID for the vector. Connect the `Output` of the Text Node to the `ID` input of the Vector Store Node.\n6. Run the graph. The `Complete` output of the Vector Store Node should return `true`, indicating that the vector has been successfully stored.\n\n![Vector Store Node Example 1](./assets/vector-store-node-example-01.png)\n\n## Error Handling\n\nIf the Vector Store Node encounters an error while trying to store the vector, it will throw an error and stop the graph's execution. Common reasons for errors include:\n\n- The vector database integration is not available or not correctly configured.\n- The collection ID does not exist in the vector database.\n- The vector or data inputs are not correctly formatted.\n\n## FAQ\n\n**Q: Can I use the Vector Store Node to store vectors in any vector database?**\n\nA: The Vector Store Node can be used to store vectors in any vector database that is supported by Rivet and has been correctly configured in the host application.\n\n**Q: Can I store multiple vectors at once?**\n\nA: No, the Vector Store Node can only store one vector at a time. If you need to store multiple vectors, you can use a loop or map operation to store each vector individually.\n\n**Q: Can I update a vector that has already been stored?**\n\nA: Yes, you can update a stored vector by storing a new vector with the same ID. The new vector will replace the existing vector in the vector database.\n\n## See Also\n\n- [Pinecone](../user-guide/plugins/built-in/pinecone.md)\n"]},{"id":"0QrLBcrgxsD9lWKBkr1wi","data":["number.mdx","---\nid: number\ntitle: Number Node\nsidebar_label: Number\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Number Node Screenshot](./assets/number-node.png)\n\n## Overview\n\nThe Number Node is used to output a constant number value or convert an input value into a number. It can also be configured to round the number to a certain number of decimal places.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                              | Default Value | Notes                                                                                                |\n| ----- | --------- | ---------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------- |\n| Input | `any`     | The value to be converted into a number. | (empty)       | This input is only available if `Use Value Input` is enabled. The input will be coerced to a number. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                                                              | Notes |\n| ----- | --------- | ---------------------------------------------------------------------------------------- | ----- |\n| Value | `number`  | The output number value. This can either be a constant value or a converted input value. | None  |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting  | Description                                                                    | Default Value | Use Input Toggle | Input Data Type |\n| -------- | ------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Value    | The constant number value to be outputted.                                     | `0`           | Yes              | `number`        |\n| Round    | If enabled, the output number will be rounded to the specified decimal places. | `false`       | No               | N/A             |\n| Round To | The number of decimal places to round the output number to.                    | `0`           | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Output a constant number\n\n1. Create a Number Node.\n2. Set the `Value` to `123.456`.\n3. Run the graph. The `Value` output of the Number Node should be `123.456`.\n\n![Number Node Example 1](./assets/number-node-example-01.png)\n\n## Example 2: Convert a string to a number\n\n1. Create a Text Node and set the text to `123.456`.\n2. Create a Number Node and enable the `Use Value Input` setting.\n3. Connect the Text Node to the `Input` of the Number Node.\n4. Run the graph. The `Value` output of the Number Node should be `123.456`.\n\n![Number Node Example 2](./assets/number-node-example-02.png)\n\n## Example 3: Round a number\n\n1. Create a Number Node.\n2. Set the `Value` to `123.456`.\n3. Enable the `Round` setting and set `Round To` to `2`.\n4. Run the graph. The `Value` output of the Number Node should be `123.46`.\n\n![Number Node Example 3](./assets/number-node-example-03.png)\n\n## Error Handling\n\nThe Number Node will not error under normal circumstances. If the `Input` value cannot be converted to a number, it will default to the `Value` setting.\n\n## FAQ\n\n**Q: Can I use the Number Node to convert a boolean to a number?**\n\nA: Yes, you can use the Number Node to convert a boolean to a number. A `true` value will be converted to `1` and a `false` value will be converted to `0`.\n\n**Q: What happens if I connect a non-numeric value to the `Input` of the Number Node?**\n\nA: The Number Node will attempt to convert the input value to a number. If the conversion is not possible, the node will default to the `Value` setting.\n\n**Q: Can I use the Number Node to round a number to an integer?**\n\nA: Yes, you can use the Number Node to round a number to an integer by enabling the `Round` setting and setting `Round To` to `0`.\n\n## See Also\n\n- [Text Node](./text.mdx)\n- [Bool Node](./bool.mdx)\n- [Compare Node](./compare.mdx)\n- [Evaluate Node](./evaluate.mdx)\n- [RNG Node](./rng.mdx)\n"]},{"id":"ETzwsrqG24SrrgrRovIBS","data":["destructure.mdx","---\nid: destructure\ntitle: Destructure Node\nsidebar_label: Destructure\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Destructure Node Screenshot](./assets/destructure-node.png)\n\n## Overview\n\nThe Destructure Node is used to extract multiple values from an object or array at once. It uses JSONPath notation to navigate through the input value and extract the values at the specified paths. This node is similar to the [Extract Object Path Node](./extract-object-path.mdx), but it allows you to specify multiple paths and extract multiple values at once, which can be more convenient than using multiple Extract Object Path nodes.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title  | Data Type | Description                        | Default Value | Notes |\n| ------ | --------- | ---------------------------------- | ------------- | ----- |\n| Object | `object`  | The object to extract values from. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type | Description                                                    | Notes                                                                                                                                     |\n| ---------- | --------- | -------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| (JSONPath) | `any`     | The value extracted from the object at the corresponding path. | If the value is not found, this port is not ran. The number of outputs is dynamic based on the number of paths specified in the settings. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                                                      | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ------------------------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Paths   | One or more JSONPath expressions. Each expression will correspond to an output port of the node. | `['$.value']` | No               | `string[]`      |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract multiple properties from an object\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   {\n     \"name\": \"John Doe\",\n     \"age\": 30,\n     \"job\": \"Engineer\"\n   }\n   ```\n\n2. Create a Destructure Node and set the Paths to `$.name`, `$.age`, and `$.job`.\n3. Connect the Object Node to the `Object` input of the Destructure Node.\n4. Run the graph. The Destructure Node should have three outputs: `$.name` with the value `John Doe`, `$.age` with the value `30`, and `$.job` with the value `Engineer`.\n\n![Destructure Node Example 1](./assets/destructure-node-example-01.png)\n\n## Error Handling\n\nIf a path is invalid or does not exist in the input object, the corresponding output port will not be run.\n\n## FAQ\n\n**Q: How is the Destructure Node different from the Extract Object Path Node?**\n\nA: The Destructure Node is similar to the Extract Object Path Node, but it allows you to specify multiple paths and extract multiple values at once. This can be more convenient than using multiple Extract Object Path nodes to extract multiple paths. The Destructure Node does not allow you specify a path and extract every value at that path, which is possible with the Extract Object Path Node.\n\n**Q: Can I use the Destructure Node to extract array values?**\n\nA: Yes, you can use the Destructure Node to extract array values, but only with a known length. You can use paths such as `$[0]`, `$[1]`, etc. to extract values from an array. However, you cannot use paths such as `$[*]` or `$[?]` to extract all values from an array.\n\n**Q: What happens if a path does not exist in the input object?**\n\nA: If a path does not exist in the input object, the corresponding output port will not be run.\n\n## See Also\n\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"4mTxR1e-24EzOLU4cCBzw","data":["get-dataset-row.mdx","---\nid: get-dataset-row\ntitle: Get Dataset Row Node\nsidebar_label: Get Dataset Row\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Get Dataset Row Node Screenshot](./assets/get-dataset-row-node.png)\n\n## Overview\n\nThe Get Dataset Row Node allows you to retrieve a specific row from a dataset by providing the dataset ID and the row ID. This node is particularly useful when you want to access and process specific rows of data in a dataset by their ID.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type | Description                                                                                                        | Default Value                                               | Notes                                                          |\n| ---------- | --------- | ------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------- | -------------------------------------------------------------- |\n| Row ID     | `string`  | The ID of the row to retrieve.                                                                                     | (required if if the input toggle for Row ID is enabled)     | The input will be coerced into a string if it is not a string. |\n| Dataset ID | `string`  | The ID of the dataset to retrieve the row from. This input is only available if `Use Dataset ID Input` is enabled. | (required if if the input toggle for Dataset ID is enabled) | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                 | Notes                                               |\n| ----- | --------- | ------------------------------------------- | --------------------------------------------------- |\n| Row   | `object`  | The row of data retrieved from the dataset. | If the row is not found, this port will not be ran. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                     | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ----------------------------------------------- | ------------- | ---------------- | --------------- |\n| Dataset | The ID of the dataset to retrieve the row from. | (required)    | Yes              | `string`        |\n| Row ID  | The ID of the row to retrieve.                  | (required)    | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Retrieve a row from a dataset\n\n1. In the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the name `Employees` and add a few rows of data.\n2. Create a Get Dataset Row Node and set the Dataset to `Employees` and the Row ID to the ID of one of the rows you added to the dataset. You can see the IDs as the first column in the Data Studio.\n3. Run the graph. The `Row` output of the Get Dataset Row Node should contain the data of the row you specified.\n\n![Get Dataset Row Node Example 1](./assets/get-dataset-row-node-example-01.png)\n\n## Example 2: Retrieve a dynamic row from a dataset\n\n1. In the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the name `Employees` and add a few rows of data.\n2. Create a Get Dataset Row Node and set the Dataset to `Employees` and enable the input toggle for Row ID.\n3. Create a [Text Node](./text.mdx) and set the text to the ID of one of the rows you added to the dataset. Connect the Text Node to the Row ID input of the Get Dataset Row Node.\n4. Run the graph. The `Row` output of the Get Dataset Row Node should contain the data of the row you specified.\n\n![Get Dataset Row Node Example 2](./assets/get-dataset-row-node-example-02.png)\n\n## Error Handling\n\nThe Get Dataset Row Node will error if the dataset provider is not available in the context when the graph is being run. It will also error if the Dataset ID or Row ID is not provided. If the specified row does not exist in the dataset, the `Row` output will not be ran.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I retrieve multiple rows at once?**\n\nA: No, the Get Dataset Row Node can only retrieve one row at a time. If you want to retrieve multiple rows, you can use multiple Get Dataset Row Nodes, or consider [splitting](../user-guide/splitting.md) the Get Dataset Row Node.\n\n**Q: What happens if the row does not exist?**\n\nA: If the row does not exist, the `Row` output will not be ran. No error will be thrown. You can use an [If Node](./if.mdx) to check if the `Row` output was ran.\n\n## See Also\n\n- [Load Dataset Node](./load-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Append To Dataset Node](./append-to-dataset.mdx)\n"]},{"id":"oUGwizBbKzJgJJwR-vbUb","data":["graph-input.mdx","---\nid: graph-input\ntitle: Graph Input Node\nsidebar_label: Graph Input\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Graph Input Node Screenshot](./assets/graph-input-node.png)\n\n## Overview\n\nThe Graph Input Node is used to define an input for a graph. This input can be passed in when the graph is called using the SDK, or defines one of the input ports when the graph is used as a subgraph.\n\nThe Graph Input Node is particularly useful for creating reusable subgraphs that can accept different inputs each time they are used. For example, you could create a subgraph that accepts a `string` input and outputs a `string` value with the input value appended to it. You could then use this subgraph in multiple places in your graph, passing in different values each time.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title         | Data Type | Description                                                                       | Default Value | Notes                                                                                                                                                            |\n| ------------- | --------- | --------------------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Default Value | Any       | The default value for the input if no value is provided when the graph is called. | (optional)    | The input will be coerced into the data type specified in the Editor Settings. This input is only available if the `Use Default Value Input` setting is enabled. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                                                                                                     | Notes                                                                                           |\n| ----- | --------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |\n| Data  | Any       | The value of the input. This will be the value provided when the graph is called, or the default value if no value is provided. | The data type of the output will be the same as the data type specified in the Editor Settings. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting                 | Description                                                                                                                         | Default Value | Use Input Toggle | Input Data Type |\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| ID                      | The ID of the input. This will be used to identify the input when the graph is called, and defines the name of the input in the UI. | (required)    | No               | `string`        |\n| Data Type               | The data type of the input.                                                                                                         | `string`      | No               | N/A             |\n| Default Value           | The default value for the input if no value is provided when the graph is called.                                                   | (empty)       | Yes              | Any             |\n| Use Default Value Input | If enabled, the default value can be provided via the Default Value input port.                                                     | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Define an input for a graph\n\n1. Create a Graph Input Node.\n2. In the Editor Settings, set the ID to `input1` and the Data Type to `string`. Set the Default Value to `Hello World`.\n3. Run the graph. The Graph Input Node will output the default value, `Hello World`.\n\n![Graph Input Node Example 1](./assets/graph-input-node-example-01.png)\n\n## Example 2: Use a Graph Input Node in a subgraph\n\n1. Create a new graph and add a Graph Input Node to it.\n2. In the Editor Settings, set the ID to `input1` and the Data Type to `string`.\n3. Add a [Text Node](./text.mdx) to the graph and connect the Graph Input Node to it.\n4. Save the graph and go back to the main graph.\n5. Add a [Subgraph Node](./subgraph.mdx) to the main graph and select the graph you just created.\n6. You will see that the Subgraph Node has an input port named `input1`. This is the input defined by the Graph Input Node in the subgraph.\n\n![Graph Input Node Example 2](./assets/graph-input-node-example-02.png)\n![Graph Input Node Example 2](./assets/graph-input-node-example-02-2.png)\n\n## Error Handling\n\nThe Graph Input Node will error if the input value cannot be coerced into the specified data type.\n\n## FAQ\n\n**Q: Can I use the Graph Input Node to define multiple inputs for a graph?**\n\nA: Yes, you can add multiple Graph Input Nodes to a graph to define multiple inputs. Each Graph Input Node will define a separate input for the graph.\n\n**Q: What happens if I don't provide a value for an input when calling a graph?**\n\nA: If you don't provide a value for an input when calling a graph, the Graph Input Node will use the default value specified in the Editor Settings. If the `Use Default Value Input` setting is enabled, the node will use the value provided to the Default Value input port.\n\n**Q: Can I use the Graph Input Node in the main graph?**\n\nA: Yes, you can use the Graph Input Node in the main graph to define inputs for the graph. These inputs can be provided when calling the graph using the SDK. See the [RunGraphOptions](../api-reference/node/RunGraphOptions) documentation for more info.\n\n## See Also\n\n- [Graph Output Node](./graph-output.mdx)\n- [Subgraph Node](./subgraph.mdx)\n- [Data Types](../user-guide/data-types.md)\n- [RunGraphOptions](../api-reference/node/RunGraphOptions)\n"]},{"id":"H5Xsv8IFvsZQWy02rbzpf","data":["prompt.mdx","---\nid: prompt\ntitle: Prompt Node\nsidebar_label: Prompt\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Prompt Node Screenshot](./assets/prompt-node.png)\n\n## Overview\n\nThe Prompt Node is used to create a chat message, which is a string of text with an attached \"type\" indicating who sent the message (User, Assistant, System) and optionally an attached \"name\".\n\nThe Prompt Node also provides the same interpolation capabilities as a [Text Node](./text.mdx), allowing you to dynamically insert values into the message.\n\nThis node can also compute a token count for the generated chat message, which can be useful for things like switching the LLM used based on the size of a message.\n\nA useful pattern is to use the default message `{{input}}` to convert any text into a prompt message.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title          | Data Type | Description                                                                                                                       | Default Value | Notes                                                                                                                     |\n| -------------- | --------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------- |\n| Function Call  | `object`  | An optional input that can be used to attach a function call to the chat message.                                                 | (empty)       | This input is only available if `Enable Function Call` is enabled.                                                        |\n| Type           | `string`  | The type of the chat message. This input is only available if `Use Type Input` is enabled.                                        | (empty)       | The input will be coerced into a string if it is not a string.                                                            |\n| Name           | `string`  | The name to attach to the chat message. This input is only available if `Use Name Input` is enabled.                              | (empty)       | The input will be coerced into a string if it is not a string.                                                            |\n| (custom names) | `string`  | The values to be interpolated into the prompt text. The names of these inputs are dynamically generated based on the prompt text. | (empty)       | The input will be coerced into a string if it is not a string. Each input creates a corresponding input port on the node. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title       | Data Type      | Description                                                                                                            | Notes                                                                                                       |\n| ----------- | -------------- | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| Output      | `chat-message` | The generated chat message.                                                                                            | The output will be a chat message containing the interpolated prompt text, the type, and the optional name. |\n| Token Count | `number`       | The number of tokens in the generated chat message. This output is only available if `Compute Token Count` is enabled. | The output will be a number representing the number of tokens in the chat message.                          |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting              | Description                                                                                                                                                                                                                                 | Default Value | Use Input Toggle | Input Data Type |\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Type                 | The type of the chat message. Can be one of the following: `system`, `user`, `assistant`, `function`.                                                                                                                                       | `user`        | Yes              | `string`        |\n| Name                 | The name to attach to the chat message.                                                                                                                                                                                                     | (empty)       | Yes              | `string`        |\n| Enable Function Call | If enabled, a `Function Call` input port will be added to the node, allowing you to attach a function call to the chat message.                                                                                                             | False         | No               | N/A             |\n| Compute Token Count  | If enabled, a `Token Count` output port will be added to the node, allowing you to compute the number of tokens in the chat message. This can be useful for keeping track of the total number of tokens used in a conversation with an LLM. | False         | No               | N/A             |\n| Prompt Text          | The text of the chat message. You can use `{{input}}` to dynamically insert values into the message.                                                                                                                                        | `{{input}}`   | No               | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Generate a chat message with interpolation\n\n1. Create a Prompt Node.\n2. Set the `Type` to `user`.\n3. Set the `Prompt Text` to `Hello, {{name}}!`.\n4. Create a Text Node and set the text to `John Doe`.\n5. Connect the Text Node to the `name` input of the Prompt Node.\n6. Run the graph. The `Output` of the Prompt Node should be a chat message with the type `user` and the message `Hello, John Doe!`.\n\n![Prompt Node Example 1](./assets/prompt-node-example-01.png)\n\n## Example 2: Convert an LLM response into an Assistant message\n\n1. Create a Prompt Node. Leave the content as the default `{{input}}`. Set the `Type` to `assistant`.\n2. Create a Chat Node and connect its `Output` to the `input` of the Prompt Node.\n3. Give the LLM a prompt text and run the graph. You should see the LLM response as an Assistant message in the Prompt Node.\n\n![Prompt Node Example 2](./assets/prompt-node-example-02.png)\n\n## Error Handling\n\nThe Prompt Node will error if the `Prompt Text` is not provided or if the `Type` is not one of the allowed types (`system`, `user`, `assistant`, `function`).\n\n## FAQ\n\n**Q: Can I use the Prompt Node to generate a chat message with a function call?**\n\nA: Yes, you can use the `Function Call` input to attach a function call to the chat message. This is useful for simulating function calls that the LLM has executed in the past. See the [GPT Function](./gpt-function.mdx) node for more information.\n\n## See Also\n\n- [Chat Node](./chat.mdx)\n- [Text Node](./text.mdx)\n- [GPT Function Node](./gpt-function.mdx)\n"]},{"id":"t1y8mAUAm6MUxzDzZwrkn","data":["abort-graph.mdx","---\nid: abort-graph\ntitle: Abort Graph Node\nsidebar_label: Abort Graph\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Abort Graph Node is used to stop the execution of the entire graph immediately. It can either \"successfully\" abort the graph (early-exit), or \"error\" abort the graph. This can be useful for stopping the graph under certain conditions, or for handling errors.\n\n![Abort Graph Node Screenshot](./assets/abort-graph-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title         | Data Type | Description                                                                                                                              | Default Value | Notes                                                                                                                                      |\n| ------------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\n| Data or Error | `any`     | The data or error message to be used when aborting the graph. If it's a string, it will be used as the error message for error aborting. | N/A           | None                                                                                                                                       |\n| Successfully  | `boolean` | Determines whether the graph should be aborted successfully or with an error.                                                            | true          | Only available if the \"Successfully Abort\" setting is toggled on in the node's settings. Otherwise, the node's setting value will be used. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\nThis node does not have any outputs.\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting            | Description                                                                                                           | Default Value | Use Input Toggle |\n| ------------------ | --------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- |\n| Successfully Abort | Determines whether the graph should be aborted successfully or with an error.                                         | true          | Yes              |\n| Error Message      | The error message to be used when aborting the graph with an error. Only used if \"Successfully Abort\" is not checked. | (Empty)       | No               |\n\n</TabItem>\n\n</Tabs>\n\n### Example 1: Successfully aborting a graph\n\n1. Add an Abort Graph node to your graph.\n2. Make sure the \"Successfully Abort\" setting is checked.\n3. Connect any node to the `Data or Error` input of the Abort Graph node. This could be a condition, a value, or anything else.\n4. Run your graph. The graph will abort immediately after the Abort Graph node is processed, and no subsequent nodes will be executed.\n\n### Example 2: Aborting a graph with an error\n\n1. Add an Abort Graph node to your graph.\n2. Uncheck the \"Successfully Abort\" setting.\n3. Optionally, enter an error message in the \"Error Message\" setting. This message will be used as the error message when the graph is aborted.\n4. Connect any node to the `Data or Error` input of the Abort Graph node. If this node outputs a string, it will be used as the error message when the graph is aborted.\n5. Run your graph. The graph will abort immediately after the Abort Graph node is processed, and no subsequent nodes will be executed. An error message will be displayed, either the one from the `Data or Error` input or the one from the \"Error Message\" setting.\n\n## Error Handling\n\nThe Abort Graph Node does not produce any errors itself. However, it causes the entire graph to stop executing when it is processed, either successfully or with an error.\n\n## FAQ\n\n**Q: What happens if I connect a non-string node to the `Data or Error` input?**\n\nA: If the node outputs a string, it will be used as the error message when the graph is aborted. If it does not output a string, it will be coerced into a string.\n\n**Q: What happens if I connect a node to the `Successfully` input but the \"Successfully Abort\" setting is not checked?**\n\nA: The `Successfully` input will be ignored, and the graph will be aborted with an error.\n\n**Q: What happens if I don't connect anything to the `Data or Error` input or leave the \"Error Message\" setting empty?**\n\nA: The graph will be aborted with a default error message of \"Graph aborted with error\".\n\n## See Also\n\n- [If Node](./if.mdx)\n- [If/Else Node](./if-else.mdx)\n- [Race Inputs Node](./race-inputs.mdx)\n"]},{"id":"C1S20yI8_Fsj6_-b9M06Z","data":["join.mdx","---\nid: join\ntitle: Join Node\nsidebar_label: Join\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Join Node Screenshot](./assets/join-node.png)\n\n## Overview\n\nThe Join Node is used to concatenate an array of strings into a single string. The strings are joined using a specified delimiter.\n\nThe Join Node can be used to flatten arrays of strings into a single string. This is useful when you want to format a list of items in a specific way, such as creating a comma-separated list, or joining lines of text with newline characters.\n\nThe node also supports the use of special characters as delimiters, such as newline (`\\n`), tab (`\\t`), and space (` `). To use them, put the literal character in the Join String field in the settings. For example, to use a newline character, you need to press `Enter` in the Join String field.\n\nArrays that are input into the Join Node will be flattened before being joined. If you connect an array to Input 1 such as `[\"apple\", \"banana\", \"cherry\"]`, and a single value into Input 2, such as `\"orange\"`, the output of the Join Node will be `apple, banana, cherry, orange`, if the delimiter is set to `, `.\n\nArray items and inputs will be coerced into strings before joining.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type | Description                                                                                                            | Default Value | Notes                                                                                                                                   |\n| ----------- | --------- | ---------------------------------------------------------------------------------------------------------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\n| Input [i]   | `string`  | The ith string to be joined.                                                                                           | N/A           | Dynamic number of inputs based on how many connections there are.                                                                       |\n| Join String | `string`  | The string used as a delimiter to join the inputs. This input is only available if `Use Join String Input` is enabled. | N/A           | The input will be coerced into a string if it is not a string. If not provided, the Join String specified in the settings will be used. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description        | Notes |\n| ------ | --------- | ------------------ | ----- |\n| Joined | `string`  | The joined string. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting               | Description                                                                 | Default Value | Use Input Toggle | Input Data Type |\n| --------------------- | --------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Flatten               | If enabled, the node will flatten array inputs before joining them.         | True          | No               | N/A             |\n| Join String           | The string used as a delimiter to join the inputs.                          | `\\n`          | Yes              | `string`        |\n| Use Join String Input | If enabled, the Join String can be provided via the Join String input port. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Join an array of strings with a newline\n\n1. Create an [Array Node](./array.mdx) and set the values to `[\"apple\", \"banana\", \"cherry\"]` with Text Nodes.\n2. Create a Join Node and set the Join String to `\\n` by deleting the current value and pressing `Enter` in the Join String field in the settings.\n3. Connect the Array Node to the `Input 1` port of the Join Node.\n4. Run the graph. The output of the Join Node should be:\n\n   ```\n   apple\n   banana\n   cherry\n   ```\n\n![Join Node Example 1](./assets/join-node-example-01.png)\n\n## Example 2: Join multiple inputs with a space\n\n1. Create three [Text Nodes](./text.mdx) and set their values to `Hello`, `World`, and `!`, respectively.\n2. Create a Join Node and set the Join String to ` ` (a space).\n3. Connect the Text Nodes to the `Input 1`, `Input 2`, and `Input 3` ports of the Join Node, respectively.\n4. Run the graph. The output of the Join Node should be `Hello World !`.\n\n![Join Node Example 2](./assets/join-node-example-02.png)\n\n## Error Handling\n\nThe Join Node will not error under normal circumstances. If an input is not provided, the Join Node will output an empty string.\n\n## FAQ\n\n**Q: Can I use special characters as the Join String?**\n\nA: Yes, you can use special characters such as newline (`\\n`), tab (`\\t`), and space (` `) as the Join String. To use these characters, you need to enter them literally in the Join String field in the settings. For example, to use a newline character, you need to press `Enter` in the Join String field.\n\n**Q: Can I join an array of numbers or other non-string values?**\n\nA: Yes, you can join an array of any data type. The values will be coerced into strings before being joined.\n\n**Q: Can I use a dynamic Join String?**\n\nA: Yes, you can use a dynamic Join String by enabling the input port toggle for the join string setting. This will create a new `Join String` input port on the node, and you can connect another node to this port to provide the Join String.\n\n## See Also\n\n- [Split Text Node](./split-text.mdx)\n- [Array Node](./array.mdx)\n- [Text Node](./text.mdx)\n- [Code Node](./code.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"tv8Zfruf-vYM-u3cxpP0c","data":["code.mdx","---\nid: code\ntitle: Code Node\nsidebar_label: Code\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Code Node Screenshot](./assets/code-node.png)\n\n## Overview\n\nThe Code Node allows you to run arbitrary JavaScript code during your graph's execution. This can be useful for a variety of purposes, such as:\n\n- Performing complex calculations\n- Custom, domain-specific logic that is complex to represent in Rivet nodes alone\n- Using JavaScript functions that are not available in other nodes\n\n### Code Inputs\n\nThe inputs to the code node are accessible in the special variable `inputs`. To access the input named `foo`, it is accessible on `inputs.foo`.\n\nAll inputs have the following structure:\n\n```ts\n{\n  type: string;\n  value: any;\n}\n```\n\nThe `type` of each input corresponds to a [Data Type](../user-guide/data-types.md). The `value` is the actual value of the input.\n\nFor example, if you have an input named `myNumber` that is a number, you can access it in the code node like this:\n\n```js\nconst foo = inputs.myNumber.value; // inputs.myNumber.type === 'number'\n```\n\n### Code Outputs\n\nThe code node **must** `return` an object containing the output values. Each property of the output object must correspond to one of the configured output names in the editor.\n\nEach of the values of the properties must be an object with the `{type: DataType; value: any}` structure described above.\n\nFor example, if you have an output named `myNumber` that is a number, you can return it like this:\n\n```js\nreturn {\n  myNumber: {\n    type: 'number',\n    value: 123,\n  },\n};\n```\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title          | Data Type | Description                                                                                           | Default Value | Notes                         |\n| -------------- | --------- | ----------------------------------------------------------------------------------------------------- | ------------- | ----------------------------- |\n| (custom names) | Any       | The input values passed into the code function. Dynamic based on the inputs configured in the editor. | `undefined`   | Always accepts any data type. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title          | Data Type | Description                                                           | Notes |\n| -------------- | --------- | --------------------------------------------------------------------- | ----- |\n| (custom names) | Any       | The outputs from the execution of the code node. Dynamic based on the | NOTES |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                                                                                                                                                                                                 | Default Value                  | Use Input Toggle | Input Data Type |\n| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ---------------- | --------------- |\n| Inputs  | The names of the inputs that can be accessible inside the code node. The names of the inputs configured here correspond with the properties of the provided `inputs` variable. Each input creates a corresponding input port on the node.   | A single input named `input`   | No               | N/A             |\n| Outputs | The names of the outputs that the code node will return. The names of the outputs configured here must correspond with the properties of the object returned by the Code node. Each output creates a corresponding output port on the node. | A single output named `output` | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Use `.slice` to get a substring\n\n1. Create a Code Node with the following code:\n\n   ```js\n   return {\n     output: {\n       type: 'string',\n       value: inputs.input.value.slice(0, 5),\n     },\n   };\n   ```\n\n2. Create a Text node, give it the value `Hello World`, and connect it to the Code Node's `input` port.\n3. Run the graph. Note that the Code Node's output is `Hello`.\n\n![Code Node Example 1](./assets/code-node-example-01.png)\n\n## Example 2: Concatenate two strings, and output the length and the string.\n\n1. Create a Code Node with the following code:\n\n   ```js\n   const concatenated = inputs.input1.value + inputs.input2.value;\n   return {\n     length: {\n       type: 'number',\n       value: concatenated.length,\n     },\n     output: {\n       type: 'string',\n       value: concatenated,\n     },\n   };\n   ```\n\n2. Rename the existing input of the Code node to `input1`, and add a 2nd input to `input2`. Add a 2nd output named `length`.\n3. Create two Text nodes, give them the values `Hello` and `World`, and connect them to the Code Node's `input1` and `input2` ports, respectively.\n4. Run the graph. Note that the Code Node outputs `HelloWorld` and `10`.\n\n![Code Node Example 2](./assets/code-node-example-02.png)\n\n## Error Handling\n\nIf any error happens during the execution of the Code Node, then the node will error.\n\nIf you are unsure of the type of value passed into the code node, for example when reusing it in multiple places, you can and should check the `type` of the input before using it. For example:\n\n```js\nif (inputs.input.type === 'string') {\n  // Do something with inputs.input.value\n}\n```\n\nIf you throw an `Error` in the code node, then it will error.\n\n## FAQ\n\n**Q: How is the code node implemented?**\n\nA: The Code Node is implemented using a [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function) with, as of right now, only one argument passed in to it - `inputs`. This is the same as if you were to write the following code:\n\n```js\nfunction codeNode(inputs) {\n  // Code here\n}\n```\n\n**Q: Can I use `require` or `import` in the code node?**\n\nA: No. The code node is executed in a sandboxed environment, and does not have access to the `require` or `import` functions. If you need to `require` or `import`, [use an External Call Node](./external-call.mdx) instead, or [create a Rivet plugin](../user-guide/plugins/creating-plugins.md).\n\n**Q: Can I use `async`/`await` in the code node?**\n\nA: No. The code node is executed synchronously, and does not support `async`/`await`. As you cannot use external libraries in a Code node, there is no need for `async`/`await` support anyway. Use an [External Call Node](./external-call.mdx) instead.\n\n**Q: Can I use external libraries in the code node?**\n\nA: No. The code node is executed in a sandboxed environment, and does not have access to external libraries. Use an [External Call Node](./external-call.mdx) instead.\n\n**Q: Can I use `console.log` in the code node?**\n\nA: No, the `console` variable is not available in a code node.\n\n**Q: Can the code node function like an [If Node](./if.mdx)?**\n\nA: Yes. If you return the special value `{ type: 'control-flow-excluded', value: undefined }` from the Code node, then the nodes after the Code node will be excluded from the graph's execution. This is useful if you want to conditionally execute a portion of the graph.\n\n**Q: Is there any timeout? What if I create an infinite loop?**\n\nA: There is no timeout. If you create an infinite loop, then the graph will hang indefinitely.\n\n## See Also\n\n- [External Call Node](./external-call.mdx)\n"]},{"id":"OXv4Em1eUTj2UsJ32oEF7","data":["get-all-datasets.mdx","---\nid: get-all-datasets\ntitle: Get All Datasets Node\nsidebar_label: Get All Datasets\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Get All Datasets Node Screenshot](./assets/get-all-datasets-node.png)\n\n## Overview\n\nThe Get All Datasets Node is used to retrieve all datasets available in the current project. This node is particularly useful when you want to access and manipulate multiple datasets in your graph, or search through all datasets for a specific dataset.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\nThe Get All Datasets Node does not have any inputs.\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type  | Description                                                                                | Notes                                                                           |\n| -------- | ---------- | ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------- |\n| Datasets | `object[]` | An array of all datasets in the current project. Each dataset is represented as an object. | If no datasets exist in the current project, the output will be an empty array. |\n\n### Object Structure\n\nEach dataset in the `Datasets` output is represented as an object with the following properties:\n\n| Title       | Data Type | Description                     | Notes |\n| ----------- | --------- | ------------------------------- | ----- |\n| id          | `string`  | The ID of the dataset.          |       |\n| name        | `string`  | The name of the dataset.        |       |\n| description | `string`  | The description of the dataset. |       |\n\nNote that the actual data of the dataset is not included in the output. To retrieve the data of a dataset, use the [Load Dataset Node](./load-dataset.mdx).\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\nThe Get All Datasets Node does not have any configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example: Retrieve all datasets in a project\n\n1. In the [Data Studio](../user-guide/features/data-studio.md), create a few datasets with different IDs.\n2. Create a Get All Datasets Node in your graph.\n3. Run the graph. The `Datasets` output of the Get All Datasets Node should contain an array of all datasets in the current project.\n\n![Get All Datasets Node Example](./assets/get-all-datasets-node-example-01.png)\n\n## Error Handling\n\nThe Get All Datasets Node will error if the dataset provider is not available in the context when the graph is being run.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I filter the datasets returned by the Get All Datasets Node?**\n\nA: No, the Get All Datasets Node will return all datasets in the current project. If you want to filter the datasets, you can use other nodes to process the output of the Get All Datasets Node, such as the [Filter Node](./filter.mdx) or [Extract Object Path Node](./extract-object-path.mdx)\n\n**Q: What happens if there are no datasets in the current project?**\n\nA: If there are no datasets in the current project, the `Datasets` output of the Get All Datasets Node will be an empty array.\n\n## See Also\n\n- [Load Dataset Node](./load-dataset.mdx)\n- [Append to Dataset Node](./append-to-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n"]},{"id":"J5jEyVDzxk7qjBOh_HKLg","data":["hash.mdx","---\nid: hash\ntitle: Hash Node\nsidebar_label: Hash\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Hash Node Screenshot](./assets/hash-node.png)\n\n## Overview\n\nThe Hash Node computes a hash of the input value using the configured hash function. It supports MD5, SHA-1, SHA-256, and SHA-512 hash algorithms. This node can be useful for generating unique IDs, checksums, and other purposes.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description              | Default Value | Notes                                                          |\n| ----- | --------- | ------------------------ | ------------- | -------------------------------------------------------------- |\n| Input | `string`  | The string to be hashed. | (required)    | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                   | Notes |\n| ----- | --------- | ----------------------------- | ----- |\n| Hash  | `string`  | The hash of the input string. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                              | Default Value | Use Input Toggle | Input Data Type |\n| --------- | ------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Algorithm | The hash algorithm to use. Options are MD5, SHA-1, SHA-256, and SHA-512. | SHA-256       | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Hash a string\n\n1. Create a [Text Node](./text.mdx) and set the value to `Hello, World!`.\n2. Create a Hash Node and connect the Text Node to its `Input` port.\n3. Run the graph. The `Hash` output of the Hash Node should contain the hash of the string `Hello, World!`.\n\n![Hash Node Example 1](./assets/hash-node-example-01.png)\n\n## Error Handling\n\nThe Hash Node will error if the `Input` is not provided or if an unsupported hash algorithm is specified.\n\n## FAQ\n\n**Q: Can I use the Hash Node to hash a number or other non-string value?**\n\nA: Yes, you can. The Hash Node will automatically convert non-string inputs into strings before hashing them.\n\n**Q: Can I use the Hash Node to hash a password?**\n\nA: It is not recommended to have passwords in Rivet. If you need to hash a password, you should do so outside of Rivet.\n\n**Q: Can I use the Hash Node to generate a unique ID for a piece of data?**\n\nA: Yes, you can use the Hash Node to generate a unique repeatable ID for a piece of data by hashing the data. This can be used with the [Vector Store Node](./vector-store.mdx) to store the data in a vector store with the ID as the key.\n\n## See Also\n\n- [Text Node](./text.mdx)\n- [Number Node](./number.mdx)\n- [Vector Store Node](./vector-store.mdx)\n- [RNG Node](./rng.mdx)\n"]},{"id":"KqYB8DpsgUKyqmE4a516Q","data":["assemble-prompt.mdx","---\nid: assemble-prompt\ntitle: Assemble Prompt Node\nsidebar_label: Assemble Prompt\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\nimport Admonition from '@theme/Admonition';\n\n## Overview\n\nA [Chat Node](./chat) takes in a single Prompt input which can be a single message, or an array of messages that forms the message chain. The Assemble Prompt Node is used to assemble multiple chat messages into a single prompt. It takes multiple chat messages or strings as inputs and outputs a single prompt containing all the messages.\n\nIf a string is connected to any of the inputs, it will be converted to a User type chat message with the string as the message.\n\n![Assemble Prompt Node Screenshot](./assets/assemble-prompt-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type                    | Description                                | Default Value | Notes                                                            |\n| ----------- | ---------------------------- | ------------------------------------------ | ------------- | ---------------------------------------------------------------- |\n| Message [i] | chat-message, chat-message[] | The ith chat message input to be assembled | N/A           | Dynamic number of inputs based on how many connections there are |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type      | Description                 | Notes                                                                                |\n| ------ | -------------- | --------------------------- | ------------------------------------------------------------------------------------ |\n| Prompt | chat-message[] | The assembled chat messages | The output will be a single prompt resulting from assembling all valid chat messages |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node does not have any specific settings.\n\n</TabItem>\n\n</Tabs>\n\n### Example: Assembling Multiple Chat Messages\n\nLet's say you have two [Prompt nodes](./prompt): one with the the AI's text \"How can I assist you today?\" and the user's response \"Hello\". If you want to assemble these two messages into a single prompt to feed into a Chat Node, you can do the following:\n\n1. Add an Assemble Prompt Node to your graph.\n2. Connect the output of the first Prompt node (AI's message) to `Message 1` of the Assemble Prompt Node.\n3. Connect the output of the second Prompt node (user's response) to `Message 2` of the Assemble Prompt Node.\n4. Connect the output of the Assemble Prompt Node to the `Prompt` input of a Chat Node.\n\n### Example: Appending Chat Messages in a Loop\n\nA common use case for the Assemble Prompt Node is to append chat messages in a loop. This can be achieved by using a Loop Controller Node in conjunction with the Assemble Prompt Node.\n\nHere's how you can set this up:\n\n1. Add a Loop Controller Node to your graph.\n2. Add an Assemble Prompt Node to your graph.\n3. Connect the `Output 1` of the Loop Controller Node to `Input 1` of the Assemble Prompt Node. This will feed the output of the loop back into the Assemble Prompt Node.\n4. Connect the `Output 1` of the Assemble Prompt Node to `Input 1` of the Loop Controller Node. This will effectively create a feedback loop where the Assemble Prompt Node feeds back into itself.\n5. Connect your first message to `Input 1 Default` of the Loop Controller Node. This will be the initial message that starts the loop.\n6. Any additional messages that you want to append during each loop iteration can be connected to `Input 2`, `Input 3`, etc of the Assemble Prompt Node.\n\nThe Assemble Prompt Node will flatten the output, resulting in a list of the current messages. During each loop iteration, the Assemble Prompt Node will append any additional messages connected to its inputs.\n\nThis setup allows you to dynamically append chat messages in a loop, which can be useful in various scenarios such as creating a chatbot that can carry on a conversation with a user.\n\n**Note:** If you want to control the number of loop iterations, you can do so by setting the `Max Iterations` property of the Loop Controller Node.\n\nHere's a diagram to help visualize the setup:\n\n![Loop Controller with Assemble Prompt Node](./assets/assemble-prompt-node-example-02.png)\n\nThis example demonstrates the power and flexibility of Rivet's node-based system, allowing you to create complex behaviors with just a few nodes.\n\n### Handling Missing Inputs\n\nIf an input is missing or not a chat message, the Assemble Prompt Node will simply ignore it during the assembling process. This can be useful when dealing with optional inputs that may not always be present.\n\n## Error Handling\n\nIf no valid chat message inputs are provided, the output will be an empty array.\n\n**Q: What happens if I connect a non-chat message to the Assemble Prompt Node?**\n\nA: The Assemble Prompt Node is designed to work with chat message inputs. If a non-chat message input is connected, the node will attempt to convert it to a chat message. In most cases, this will be a User type message with message being the data converted to a string. If this conversion isn't possible, the input will be ignored during the assembling process.\n\n**Q: Can I connect an Array Node to the Assemble Prompt Node?**\n\nA: Yes, you can connect an Array Node to the Assemble Prompt Node. Each element of the array will be treated as a separate chat message to be assembled (flattens the array).\n\n**Q: How does the Assemble Prompt Node handle empty strings or null values?**\n\nA: The Assemble Prompt Node will ignore any inputs that are null or not a chat message. Empty chat messages, however, will be included in the assembling operation.\n\n## See Also\n"]},{"id":"wghih7vFIcgzGMl5qy0B9","data":["all-nodes.mdx","---\ntitle: 'All Nodes'\n---\n\n# All Nodes\n\nThe following is all of the nodes built-in to the core of Rivet.\n\n## Text\n\n| Node                                                               | Description                                                                                                                                                                                                                                                                                  |\n| ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Chunk](./chunk.mdx)                                               | Splits a string into an array of strings based on a token count. Useful for avoiding token count limits in LLMs, truncating a string to a certain token count, and ensuring context is not lost between chunks by specifying an overlap percentage.                                          |\n| [Extract Markdown Code Blocks](./extract-markdown-code-blocks.mdx) | Extracts code blocks from a Markdown text, including all matched blocks and their specified languages. Especially useful when working with LLMs trained extensively on replying with markdown data.                                                                                          |\n| [Extract with Regex](./extract-with-regex.mdx)                     | Extracts one or more strings from a string using a regular expression. Useful for parsing a response to extract specific values or determining if the regex matched the input string.                                                                                                        |\n| [Join](./join.mdx)                                                 | Concatenates an array of strings into a single string using a specified delimiter. Capable of flattening arrays of strings and supports the use of special characters as delimiters.                                                                                                         |\n| [Prompt](./prompt.mdx)                                             | Creates a chat message with an attached \"type\" indicating who sent the message (User, Assistant, System) and optionally an attached \"name\". Provides interpolation capabilities to dynamically insert values into the message, and can compute a token count for the generated chat message. |\n| [Split Text](./split-text.mdx)                                     | Splits a string into an array of substrings based on a specified delimiter, which can be set either directly in the node settings or dynamically via an input port. Useful for separating a string into individual elements for further processing.                                          |\n| [Text](./text.mdx)                                                 | Outputs a string of text and supports interpolation using `{{tags}}` within the text. Useful for creating dynamic, richly formatted text and supports markdown.                                                                                                                              |\n| [To JSON](./to-json.mdx)                                           | Converts any given input into its JSON equivalent, effectively stringifying the value. Provides an option to format the JSON output with indentation for easier reading.                                                                                                                     |\n| [To YAML](./to-yaml.mdx)                                           | Converts an object into a YAML string, beneficial when you need to output your data in a YAML format. Throws an error if the input is not an object.                                                                                                                                         |\n\n## AI\n\n| Node                                           | Description                                                                                                                                                                                                                                                                                                 |\n| ---------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Assemble Prompt](./assemble-prompt.mdx)       | Assembles multiple chat messages into a single prompt. Takes multiple chat messages or strings as inputs and outputs a single prompt containing all the messages. Also capable of converting non-chat message inputs into a chat message format.                                                            |\n| [Chat](./chat.mdx)                             | Sends one or more messages to an LLM - OpenAI's GPT or any API compatible with the OpenAI API, and returns the response from the LLM. Can be used for local LLMs as long as their API is compatible with the OpenAI API.                                                                                    |\n| [GPT Function](./gpt-function.mdx)             | Allows the definition of a function that can be called by OpenAI's GPT in its responses, facilitating GPT's \"function-calling\" capability. The function is defined using JSON Schema and the output can be connected to other nodes such as the Chat Node or Array Node.                                    |\n| [Get Embedding](./get-embedding.mdx)           | Generates a vector embedding for a given input text, allowing text to be converted into a numerical representation for operations such as K-nearest neighbor search. Requires an integration, such as OpenAI, to generate the embedding.                                                                    |\n| [Trim Chat Messages](./trim-chat-messages.mdx) | Manages the length of chat message chains in terms of tokens. Trims messages from either the beginning or the end of the list until the total length of the messages is under the configured token length. Ideal for setting up infinite message chains that stay under the language model's context limit. |\n\n## Lists\n\n| Node                     | Description                                                                                                                                                                                                                                          |\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Array](./array.mdx)     | Constructs arrays from multiple inputs of any type or merges several arrays into a single one. Offers a 'Flatten' setting enabling the merging of array inputs into the output array, and a 'Deep' setting for recursive flattening of array inputs. |\n| [Filter](./filter.mdx)   | Filters elements of an array based on a corresponding array of boolean values. Useful for filtering an array based on certain conditions.                                                                                                            |\n| [Pop](./pop.mdx)         | Removes either the first or last element from an array, outputting both the removed element and the remaining array. Useful for processing array elements one by one in a loop.                                                                      |\n| [Shuffle](./shuffle.mdx) | Randomizes the order of elements in an array. Uses the Fisher-Yates (aka Knuth) shuffle algorithm to ensure a fair distribution of permutations, and does not modify the original array.                                                             |\n| [Slice](./slice.mdx)     | Extracts a specific portion of an array. Takes an array as input and outputs a new array that starts at a specified index and contains a specified number of elements.                                                                               |\n\n## Numbers\n\n| Node                       | Description                                                                                                                                                                                                                                            |\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [Evaluate](./evaluate.mdx) | Performs a variety of mathematical operations such as addition, subtraction, multiplication, division, exponentiation, modulus, absolute value, and negation on input values and provides the result. Allows dynamic operation changes based on input. |\n| [Number](./number.mdx)     | Outputs a constant number value or converts an input value into a number. Also has the ability to round the number to a specified number of decimal places.                                                                                            |\n| [RNG](./rng.mdx)           | Generates a random number within a specified range, either as integers or floating-point numbers. Useful for creating randomized behavior in your graph.                                                                                               |\n\n## Objects\n\n| Node                                             | Description                                                                                                                                                                                                                                                             |\n| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Extract JSON](./extract-json.mdx)               | Extracts a JSON object or array from a string, ignoring any data outside of the JSON structure. Particularly useful for extracting structured data from responses that contain a JSON object.                                                                           |\n| [Extract Object Path](./extract-object-path.mdx) | Allows users to run jsonpath queries on an object, a useful function for extracting data from a JSON object or array. Can handle complex queries and work with different data types including objects, arrays, and strings.                                             |\n| [Extract YAML](./extract-yaml.mdx)               | Parses a YAML object from a string, particularly useful for extracting structured data from a text string containing a YAML object. Identifies a predefined root property name in the input text and considers all indented text after that as part of the YAML object. |\n| [Object](./object.mdx)                           | Creates an object from input values and a JSON template, supporting any data type as input and outputting an object. Particularly useful for creating objects from multiple inputs.                                                                                     |\n\n## Data\n\n| Node                 | Description                                                                                                                                                                                                                                                             |\n| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Audio](./audio.mdx) | Defines an audio sample for use with other nodes, and can convert a binary type into an audio type. Can take an input representing the audio data or use an audio file specified in the node's settings.                                                                |\n| [Bool](./bool.mdx)   | Outputs a boolean constant or converts an input value into a boolean, following JavaScript's rules for truthy and falsy values. Can be used to create a boolean value for use in other nodes, or to check if an array is empty, a string is empty, or a number is zero. |\n| [Hash](./hash.mdx)   | Computes a hash of the input value using the configured hash function, supporting MD5, SHA-1, SHA-256, and SHA-512 hash algorithms. Useful for generating unique IDs, checksums, and other purposes.                                                                    |\n| [Image](./image.mdx) | Defines a static image for use with other nodes. Can convert a binary type into an image type, requires a media type (PNG, JPEG, or GIF) and a data input, which can be provided directly or dynamically.                                                               |\n\n## Logic\n\n| Node                             | Description                                                                                                                                                                                                                                                                                      |\n| -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [Abort Graph](./abort-graph.mdx) | Immediately stops the execution of the entire graph, either successfully (early-exit) or with an error. Allows for the control of graph execution under specific conditions or for error handling.                                                                                               |\n| [Coalesce](./coalesce.mdx)       | Functions like the `COALESCE` function in SQL, returning the first non-null value from a list of inputs. Particularly useful for handling a set of nodes, one of which will be run, and returning the output of the first one that actually runs.                                                |\n| [Compare](./compare.mdx)         | Performs comparison operations between two input values, supporting functions such as equality, inequality, logical operations, and more. Can handle various data types and attempts to coerce the second input to match the first if they are not of the same type.                             |\n| [Delay](./delay.mdx)             | Introduces a pause in the execution of the graph, passing input values to outputs after a specified delay. Useful for timing control in your graph's execution.                                                                                                                                  |\n| [If](./if.mdx)                   | Accepts a condition and a value. Depending on the truthiness of the condition, the value is passed through either the True or False port. Used for conditional operations and comparisons.                                                                                                       |\n| [If/Else](./if-else.mdx)         | Allows for decision-making in the control flow by choosing between two different values based on a condition. Particularly useful for ensuring that a graph always returns a value, or that a later node always receives a value even if intermediate nodes do not run.                          |\n| [Match](./match.mdx)             | Matches a string input against a series of regular expressions, routing control flow based on the content of the string. Executes the output port for each matching regular expression and the `Unmatched` output port if no match is found.                                                     |\n| [Passthrough](./passthrough.mdx) | Transfers the input value directly to the output without modification. Useful for grouping values from different branches of your graph or controlling wire flow without altering the value.                                                                                                     |\n| [Race Inputs](./race-inputs.mdx) | Manages multiple inputs, outputting the value of the first input to complete while cancelling the remaining inputs. Especially useful when dealing with multiple operations that could satisfy the same requirement, allowing for the use of the result from the operation that concludes first. |\n\n## Input/Output\n\n| Node                                         | Description                                                                                                                                                                                                                                                                     |\n| -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Append to Dataset](./append-to-dataset.mdx) | Appends a row of data to a specified dataset, making it useful for adding new data to an existing dataset for further processing or analysis. Requires a dataset provider to be available in the context when the graph is being run.                                           |\n| [Create Dataset](./create-dataset.mdx)       | Generates a new dataset with a unique ID and name. Beneficial for creating new datasets for data storage or processing and requires a dataset provider to manage the storage and retrieval of datasets.                                                                         |\n| [Get All Datasets](./get-all-datasets.mdx)   | Retrieves all datasets available in the current project, useful in accessing and manipulating multiple datasets or searching for a specific dataset. Requires a dataset provider to manage the storage and retrieval of datasets.                                               |\n| [Get Dataset Row](./get-dataset-row.mdx)     | Retrieves a specific row from a dataset by providing the dataset ID and the row ID. Useful for accessing and processing specific rows of data in a dataset by their ID.                                                                                                         |\n| [Graph Input](./graph-input.mdx)             | Defines an input for a graph, which can be passed in when the graph is called using the SDK or defines one of the input ports when the graph is used as a subgraph. Especially useful for creating reusable subgraphs that can accept different inputs each time they are used. |\n| [Graph Output](./graph-output.mdx)           | Defines the outputs of a graph, with each instance representing an individual output. Turns into an output port when the graph is used as a subgraph, and the value passed into becomes part of the overall graph output.                                                       |\n| [KNN Dataset](./knn-dataset.mdx)             | Finds the k nearest neighbors in a dataset given an embedding. Useful for locating the most similar items in a dataset to a specified item. Requires a dataset provider to manage the storage and retrieval of datasets.                                                        |\n| [Load Dataset](./load-dataset.mdx)           | Loads the entire contents of a dataset into a graph, which can then be used in other nodes. Outputs an array of dataset rows and requires a dataset provider to be available in the context when the graph is being run.                                                        |\n| [Read Directory](./read-directory.mdx)       | Reads the contents of a specified directory and outputs an array of filenames. Can be configured to read directories recursively, include directories in the output, filter the filenames, return relative paths, and ignore certain files or directories.                      |\n| [Read File](./read-file.mdx)                 | Reads the contents of a specified file from the file system and outputs it as a string. Requires a native API to be available in the context when the graph is being run and offers settings to handle errors and dynamic file paths.                                           |\n| [User Input](./user-input.mdx)               | Prompts the user for input during the execution of the graph, and the user's response becomes the output of the node. Can use a static prompt defined in the node settings or dynamic prompts provided via the node's input.                                                    |\n| [Vector Store](./vector-store.mdx)           | Stores vector embeddings in a vector database. Accepts a vector and associated data for storage, which can later be retrieved for similarity searches.                                                                                                                          |\n| [Vector KNN](./vector-knn.mdx)               | Performs a k-nearest neighbors search on vectors stored in a configured vector database integration. Particularly useful when working with vector databases like Pinecone to find the most similar vectors in the database to a given input vector.                             |\n\n## Advanced\n\n| Node                                     | Description                                                                                                                                                                                                                                                                                       |\n| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Code](./code.mdx)                       | Executes arbitrary JavaScript code during a graph's operation. Capable of performing complex calculations, custom logic and using JavaScript functions not available in other nodes. Supports customizable inputs and outputs, and includes error handling capabilities.                          |\n| [Comment](./comment.mdx)                 | Adds notes or comments to a graph, providing additional context or explanation. Always rendered behind other nodes and features a distinct, customizable appearance.                                                                                                                              |\n| [Context](./context.mdx)                 | Allows access to shared inputs across any graph, acting as a global value holder. Beneficial for accessing and passing \"global context\" to projects, such as the current date.                                                                                                                    |\n| [External Call](./external-call.mdx)     | Executes external functions within a graph when Rivet is running from a host application. Useful for tasks such as getting data from your database, calling web APIs, and retrieving user information. However, it's not available when running Rivet in the Rivet application.                   |\n| [Get Global](./get-global.mdx)           | Retrieves a global value that is shared across all graphs and subgraphs. Can be configured to retrieve the value on demand or to wait until the variable is available, making it adaptable to various execution scenarios.                                                                        |\n| [HTTP Call](./http-call.mdx)             | Makes an HTTP call to a specified URL with a given method, headers, and body. Especially useful for interacting with external APIs or services. Supports all HTTP methods and allows custom headers and a request body.                                                                           |\n| [Loop Controller](./loop-controller.mdx) | Creates loops within your graph, controlling the flow of values and maintaining the state of the loop. Contains a dynamic number of pairs of inputs and outputs, with the ability to control the continuation of the loop through a `Continue` input port.                                        |\n| [Raise Event](./raise-event.mdx)         | Triggers an event within the graph, which can be picked up by the host project or a 'Wait For Event Node' in the same graph. Requires an event name and optional event data, allowing actions to be initiated or different parts of the graph to be synchronized based on the state of the graph. |\n| [Set Global](./set-global.mdx)           | Sets a global value that is shared across all graphs and subgraphs during an execution in Rivet. Allows you to specify the ID of the global value and the value itself, which can be of any data type.                                                                                            |\n| [Subgraph](./subgraph.mdx)               | Executes another graph within the current graph, facilitating logic reuse and complex graph breakdown. Automatically updates its inputs and outputs to match the selected subgraph and has an optional error output for handling execution errors.                                                |\n| [Wait For Event](./wait-for-event.mdx)   | Pauses the execution of a graph until a specific event is signaled by a Raise Event Node or the host project. Beneficial for cases where the graph execution needs to wait for an external event, like a user's click or an API call completion.                                                  |\n"]},{"id":"W4uC9nICKEE7tQnC5W0Ov","data":["to-yaml.mdx","---\nid: to-yaml\ntitle: To YAML Node\nsidebar_label: To YAML\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![To YAML Node Screenshot](./assets/to-yaml-node.png)\n\n## Overview\n\nThe To YAML Node is used to convert an object into a YAML string. This can be useful when you need to output your data in a YAML format.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title  | Data Type | Description                    | Default Value | Notes |\n| ------ | --------- | ------------------------------ | ------------- | ----- |\n| Object | `object`  | The object to convert to YAML. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                   | Notes |\n| ----- | --------- | --------------------------------------------- | ----- |\n| YAML  | `string`  | The YAML string representation of the object. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node does not have any configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Convert an object to YAML\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   {\n     \"name\": \"Claude Shannon\",\n     \"occupation\": \"Computer scientist\"\n   }\n   ```\n\n2. Create a To YAML Node and connect the Object Node to its `Object` input.\n3. Run the graph. The To YAML Node should output the following YAML string:\n\n   ```yaml\n   name: Claude Shannon\n   occupation: Computer scientist\n   ```\n\n   ![To YAML Node Example 1](./assets/to-yaml-node-example-01.png)\n\n## Error Handling\n\nThe To YAML Node will throw an error if the input is not an object.\n\n## FAQ\n\n**Q: Can I convert an array to YAML?**\n\nA: Yes, you can convert an array to YAML. However, you must first convert the array to an object using the [Array Node](./array.mdx).\n\n**Q: Can I convert a string to YAML?**\n\nA: No, you cannot convert a string to YAML. The To YAML Node only accepts objects as input.\n\n## See Also\n\n- [To JSON Node](./to-json.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n"]},{"id":"J3TO3U7noepeiJIqXIM6s","data":["raise-event.mdx","---\nid: raise-event\ntitle: Raise Event Node\nsidebar_label: Raise Event\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Raise Event Node Screenshot](./assets/raise-event-node.png)\n\n## Overview\n\nThe Raise Event Node allows you to trigger an event from within your graph. This event can be listened for by the host project or by a [Wait For Event Node](./wait-for-event.mdx) within the same graph. This can be useful for triggering actions in your host application based on the state of your graph, or for synchronizing different parts of your graph.\n\nThe node requires an event name and optionally an event data. The event name is used to identify the event when it is raised, and the event data is any additional information that you want to associate with the event.\n\n### Toast\n\nIn the Rivet application, there is a special event named `toast` which can show a toast message. The `toast` event accepts a string as its data, which is used as the message of the toast.\n\n![Raise Event Node Toast Example](./assets/raise-event-node-toast.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type | Description                                                                                        | Default Value | Notes                                                                                      |\n| ---------- | --------- | -------------------------------------------------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------ |\n| Event Name | `string`  | The name of the event to raise. This input is only available if `Use Event Name Input` is enabled. | (required)    | The input will be coerced into a string if it is not a string.                             |\n| Data       | `any`     | The data to associate with the event.                                                              | (empty)       | The input will be coerced into the appropriate data type based on the value of the `Data`. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                                  | Notes                                                                                    |\n| ------ | --------- | -------------------------------------------- | ---------------------------------------------------------------------------------------- |\n| Result | `any`     | The data that was associated with the event. | If the `Data` input is not provided, the `Result` output will be an empty string (`\"\"`). |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting              | Description                                                               | Default Value | Use Input Toggle | Input Data Type |\n| -------------------- | ------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Event Name           | The name of the event to raise.                                           | (required)    | Yes              | `string`        |\n| Use Event Name Input | If enabled, the Event Name can be provided via the Event Name input port. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Raise an event with data\n\n1. Create a Text Node and set the text to `Hello, world!`.\n2. Create a Raise Event Node and leave the Event Name as `toast`.\n3. Connect the Text Node to the `Data` input of the Raise Event Node.\n4. Run the graph. The `Result` output of the Raise Event Node should be `Hello, world!`, and a toast message should appear in the Rivet application.\n\n![Raise Event Node Example 1](./assets/raise-event-node-toast.png)\n\n## Example 2: Wait for an Chat call to finish before continuing another part of a graph\n\n1. Create a [Chat Node](./chat.mdx) and give it a prompt using a [Text Node](./text.mdx) such as \"What is your name?\".\n2. Create a Raise Event Node, set the Event Name to `chat`, and connect the `Response` output of the Chat Node to the `Data` input of the Raise Event Node.\n3. In a separate part of the graph, add a [Wait For Event Node](./wait-for-event.mdx) and set the Event Name to `chat`.\n4. Run the graph. Notice that the Wait For Event Node will not continue until the Chat Node has finished.\n\n![Raise Event Node Example 2](./assets/raise-event-node-example-02.png)\n\n## Error Handling\n\nThe Raise Event Node will error if the `Event Name` is not provided.\n\n## FAQ\n\n**Q: How can I listen for the event that was raised?**\n\nA: You can listen for the event in your host application by using the `onUserEvent` property of [RunGraphOptions](../api-reference/node/RunGraphOptions). You can also listen for the event within the same graph by using a [Wait For Event Node](./wait-for-event.mdx).\n\n**Q: Can I pass data with the event?**\n\nA: Yes, you can pass data with the event by providing a value to the `Data` input. The data can be of any data type.\n\n**Q: What happens if I raise an event that no one is listening for?**\n\nA: If you raise an event that no one is listening for, nothing will happen. The event will be raised and then immediately discarded.\n\n**Q: How is raising event different from an [External Call Node](./external-call.mdx)?**\n\nA: The External Call Node will wait for the external call to complete before continuing, whereas the Raise Event Node will continue immediately after raising the event.\n\n## See Also\n\n- [Wait For Event Node](./wait-for-event.mdx)\n- [External Call Node](./external-call.mdx)\n- [RunGraphOptions](../api-reference/node/RunGraphOptions)\n"]},{"id":"Qgtpu5I6vulakqXPVTmJP","data":["loop-controller.mdx","---\nid: loop-controller\ntitle: Loop Controller Node\nsidebar_label: Loop Controller\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Loop Controller Node Screenshot](./assets/loop-controller-node.png)\n\n## Overview\n\nThe Loop Controller Node is a powerful node that allows you to create loops in your graph. It is the only node in Rivet that is allowed to contain cycles of nodes, including itself.\n\nThe Loop Controller Node maintains the state of the loop and controls the flow of values through the loop. All values that can change in a loop must flow through the Loop Controller Node itself.\n\nThe Loop Controller Node has a dynamic number of pairs of inputs. Each pair consists of an input and a default input. The default input is the initial state of the loop and the input is the value that changes in each iteration of the loop.\n\nThe Loop Controller Node also has a dynamic number of output ports. On the first iteration, the value of each output port is the value passed into the corresponding default input port. On subsequent iterations, the value of each output port is the value passed into the corresponding input port on the previous iteration.\n\nThe Loop Controller Node has a `Continue` input port. If the value passed into the `Continue` input port is truthy, the loop will continue executing. If the value is falsy, the loop will stop executing.\n\nFor more information on loops, see the [Loops](../user-guide/loops.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title           | Data Type | Description                                                                                          | Default Value | Notes                                                                                                      |\n| --------------- | --------- | ---------------------------------------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------- |\n| Continue        | `any`     | If the value is truthy, the loop will continue executing. If the value is falsy, the loop will stop. | `undefined`   | The input will be coerced into a boolean. If the input is not provided, the loop will continue by default. |\n| Input X         | `any`     | The value that changes in each iteration of the loop.                                                | (Required)    |                                                                                                            |\n| Input X Default | `any`     | The initial value of the loop.                                                                       | (Required)    |                                                                                                            |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                                                                        | Notes                                                                                                                                                                                                                 |\n| -------- | --------- | -------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Break    | `any`     | If the `Continue` input is falsy, this output port will run with an array of all the input values. | If the `Continue` input is truthy, this output port will not run.                                                                                                                                                     |\n| Output X | `any`     | The value of the corresponding input or default input.                                             | On the first iteration, the value is the value passed into the corresponding default input port. On subsequent iterations, the value is the value passed into the corresponding input port on the previous iteration. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting        | Description                                                                                             | Default Value | Use Input Toggle | Input Data Type |\n| -------------- | ------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Max Iterations | The maximum number of iterations that the loop can run. If the loop exceeds this number, it will error. | 100           | No               | `number`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: AI Chatting To Itself\n\nThe following example shows how you can use the Loop Controller Node to create a loop that will never break.\n\nThe AI is prompted with a single message, which is given into the Chat node. The existing message history and the AI's response are combined together to form the new message history, which feeds back into the loop controller. Effectively, the AI starts chatting with itself.\n\n[![Loop Controller Node Example 1](./assets/loop-controller-node-example-01.png)](./assets/loop-controller-node-example-01.png)\n\n:::info\n\nThis loop will never break. If you run this graph, it will eventually fail after the default of 100 iterations.\n\n:::\n\n## Example 2: Iterating Over an Array\n\nA common use-case is to iterate over an array. The following example shows how you can use the Loop Controller Node to iterate over an array, and return a new array containing ` Mapped` appended to each element.\n\nIn each iteration of the loop, we use a [Pop Node](./pop.mdx) to pop the first value off the array and append ` Mapped` to it. We then push the new value into the output array using an [Array Node](./array.mdx), which is a combination of the existing output array, and the new value. Once the input array is empty, the loop will break, using the [Compare Node](./compare.mdx).\n\nThe [Graph Output](./graph-output.mdx) node is connected to the `Break` output of the loop controller. It is given all of the inputs in an array, so the first array will be empty and the second array will contain the mapped values. You could use an [Extract Object Path Node](./extract-object-path.mdx) to extract the second array using `$[1]`.\n\n[![Loop Controller Node Example 2](./assets/loop-controller-node-example-02.png)](./assets/loop-controller-node-example-02.png)\n\n## Error Handling\n\nThe Loop Controller Node will error if the loop exceeds the maximum number of iterations specified in the `Max Iterations` setting.\n\n## FAQ\n\n**Q: Why do I need to connect something to the Break output port?**\n\nA: The graph needs to traverse from the output nodes of the graph to the input node due to how the processing works, so there needs to be a \"leaf\" node for the graph execution to start from. The \"Break\" output port is convenient to connect to, even if the loop never breaks.\n\n**Q: Why does the my loop run forever?**\n\nA: You may have not connected the \"Continue\" input port to anything. If the \"Continue\" input port is not connected to anything, it will default to `true`, which means the loop will never break.\n\nIf you have an output that is \"Not Ran\" connected to the input port, such as an [If Node](./if.mdx), the loop will never break because the \"Not Ran\" output will always be `true`.\n\n**Q: What happens if I don't connect the default input port?**\n\nA: Right now, this is undefined behavior, so try to connect all the defaults with something.\n\n**Q: How can I remember the ports better?**\n\nYou can give the nodes connected to the input ports descriptive names, as the names of the nodes connected to the input ports are what show on the loop controller. Or, you could just remember that the loop controller's inputs are in \"pairs\" so try to group them that way.\n\n**Q: Why does the loop controller have a maximum number of iterations?**\n\nA: The maximum number of iterations is there to prevent accidental infinite loops. If you have a loop that is not breaking, it will eventually error after the maximum number of iterations. If you need an truly infinite loop, you can set the maximum number of iterations to an extremely high number.\n\n## See Also\n\n- [Loops](../user-guide/loops.md)\n- [Control Flow](../user-guide/control-flow.md)\n"]},{"id":"8sb41wy7Da41p0tt2Zbvj","data":["text.mdx","---\nid: text\ntitle: Text Node\nsidebar_label: Text\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Text Node Screenshot](./assets/text-node.png)\n\n## Overview\n\nThe Text Node is used to output a string of text. It can also interpolate values using `{{tags}}` within the text. The inputs are dynamically generated based on the interpolation tags used in the text.\n\nThis node is particularly useful for creating dynamic text based on the inputs to the node. The Text Node supports markdown, so you can use it to create richly formatted text.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                                                                | Default Value | Notes                                                                                                                                                             |\n| --------- | --------- | -------------------------------------------------------------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| (dynamic) | `string`  | The inputs are dynamically generated based on the interpolation tags used. | N/A           | The input names are derived from the interpolation tags used in the text. For example, if the text contains `{{name}}`, then there will be an input named `name`. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                         | Notes |\n| ------ | --------- | ----------------------------------- | ----- |\n| Output | `string`  | The output text after interpolation |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                                                                    | Default Value | Use Input Toggle | Input Data Type |\n| ------- | -------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Text    | The text to output. You can use interpolation tags in the format `{{tag}}` to insert the values of the inputs. | `{{input}}`   | No               | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Simple Text Output\n\n1. Create a Text Node.\n2. Set the `Text` to `Hello World!`.\n3. Run the graph. The output of the Text Node will be `Hello World`.\n\n![Text Node Example 1](./assets/text-node-example-01.png)\n\n## Example 2: Interpolation\n\n1. Create a Text Node.\n2. Set the `Text` to `Hello, {{name}}!`.\n3. Create a [Text Node](./text.mdx) and set the text to `Rivet`. Connect it to the `name` input of the Text Node.\n4. Run the graph. The output of the Text Node will be `Hello, Rivet!`.\n\n![Text Node Example 2](./assets/text-node-example-02.png)\n\n## Example 3: Using Markdown\n\n1. Create a Text Node.\n2. Set the `Text` to `# Hello, {{name}}!`.\n3. Create a [Text Node](./text.mdx) and set the text to `Rivet`. Connect it to the `name` input of the Text Node.\n4. Run the graph. The output of the Text Node will be `# Hello, Rivet!`.\n\n![Text Node Example 3](./assets/text-node-example-03.png)\n\n## Error Handling\n\nThe Text Node does not have any notable error handling behavior. If an input is missing or null, the corresponding interpolation tag will be replaced with an empty string.\n\n## FAQ\n\n**Q: Can I use markdown in the Text Node?**\n\nA: Yes, the Text Node supports markdown. You can use markdown syntax in the text to create richly formatted text.\n\n**Q: Can I use the Text Node to create a template?**\n\nA: Yes, you can use the Text Node to create a template by using interpolation tags. You can then connect other nodes to the inputs of the Text Node to fill in the values of the tags.\n\n**Q: Can I use the Text Node to concatenate strings?**\n\nA: Yes, you can use the Text Node to concatenate strings by using interpolation tags. For example, you can set the text to `{{string1}}{{string2}}` to concatenate the values of `string1` and `string2`.\n\n## See Also\n\n- [Code Node](./code.mdx)\n- [Number Node](./number.mdx)\n- [Boolean Node](./bool.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [To JSON Node](./to-json.mdx)\n- [To YAML Node](./to-yaml.mdx)\n"]},{"id":"vmNexz2lZdhG_OjpCJPXV","data":["url-reference.mdx","---\nid: url-reference\ntitle: URL Reference Node\nsidebar_label: URL Reference\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![URL Reference Node Screenshot](./assets/url-reference-node.png)\n\n## Overview\n\nThe URL Reference Node is used to define a reference to a URL or convert a string into a URL reference. This node is particularly useful when used with the Assemble Message node to define URLs for attachments or images, allowing the LLM to download the image instead of having to upload the image with your chat request.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                      | Default Value | Notes                                                                   |\n| ----- | --------- | ------------------------------------------------ | ------------- | ----------------------------------------------------------------------- |\n| URL   | `string`  | The string to be converted into a URL reference. | (empty)       | This input is only available if the `Use URL Input` setting is enabled. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title         | Data Type | Description                       | Notes |\n| ------------- | --------- | --------------------------------- | ----- |\n| URL Reference | `object`  | A reference to the specified URL. | None  |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                 | Default Value | Use Input Toggle | Input Data Type |\n| ------------- | ----------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| URL           | The URL to be converted into a URL reference.               | (empty)       | Yes              | `string`        |\n| Use URL Input | If enabled, the URL can be provided via the URL input port. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Define a URL Reference\n\n1. Create a URL Reference Node.\n2. Set the `URL` setting to the URL you want to reference (e.g., `https://example.com/image.jpg`).\n3. Run the graph. The `URL Reference` output of the URL Reference Node should contain a reference to the specified URL.\n\n![URL Reference Node Example 1](./assets/url-reference-node-example-01.png)\n\n## Example 2: Convert a String into a URL Reference\n\n1. Create a URL Reference Node and enable the `Use URL Input` setting.\n2. Create a [Text Node](./text.mdx) and set the text to the URL you want to reference (e.g., `https://example.com/image.jpg`).\n3. Connect the Text Node to the `URL` input of the URL Reference Node.\n4. Run the graph. The `URL Reference` output of the URL Reference Node should contain a reference to the specified URL.\n\n![URL Reference Node Example 2](./assets/url-reference-node-example-02.png)\n\n## Error Handling\n\nThe URL Reference Node cannot error under normal circumstances. If the `URL` input is not provided, the node will use the URL specified in the settings.\n\n## FAQ\n\n**Q: Can I use the URL Reference Node to reference a file on my local machine?**\n\nA: No, the URL Reference Node is intended for referencing URLs on the internet. If you want to reference a file on your local machine, you would need to upload the file to a web server and reference the URL of the uploaded file, or use the Image Node to load the image from your local machine.\n\n**Q: What happens if I provide an invalid URL?**\n\nA: The URL Reference Node does not validate the URL. It simply creates a reference to the provided URL. If the URL is invalid, any nodes that use the URL reference may fail or behave unexpectedly.\n\n## See Also\n\n- [Assemble Message Node](./assemble-message.mdx)\n- [Text Node](./text.mdx)\n- [HTTP Call Node](./http-call.mdx)\n- [Image Node](./image.mdx)\n"]},{"id":"MufMo4t-0PzjgO63v8vYt","data":["image.mdx","---\nid: image\ntitle: Image Node\nsidebar_label: Image\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Image Node Screenshot](./assets/image-node.png)\n\n## Overview\n\nThe Image Node is used to define a static image for use with other nodes. It can convert a binary type into an image type. The node requires a media type (PNG, JPEG, or GIF) and a data input.\n\nThe data input can be provided in two ways:\n\n- Directly in the node's editor settings, using the image browser.\n- Dynamically, by connecting another node to the Image Node's `Data` input port.\n\nThe media type can also be provided in two ways:\n\n- Directly in the node's editor settings, using the dropdown menu.\n- Dynamically, by connecting another node to the Image Node's `Media Type` input port.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type | Description                                      | Default Value                                               | Notes                                                                                                                                             |\n| ---------- | --------- | ------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Data       | `string`  | The data to be converted into an image.          | (required if if the input toggle for Data is enabled)       | The input will be coerced into a string if it is not a string.                                                                                    |\n| Media Type | `string`  | The media type of the image (PNG, JPEG, or GIF). | (required if if the input toggle for Media Type is enabled) | The input will be coerced into a string if it is not a string. The value must be one of the following: `image/png`, `image/jpeg`, or `image/gif`. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                 | Notes |\n| ----- | --------- | --------------------------- | ----- |\n| Image | `image`   | The image that was created. | None  |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting    | Description                                      | Default Value | Use Input Toggle | Input Data Type |\n| ---------- | ------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Media Type | The media type of the image (PNG, JPEG, or GIF). | `image/png`   | Yes              | `string`        |\n| Image      | The data to be converted into an image.          | (empty)       | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Create a static image\n\n1. Create an Image Node.\n2. In the node's editor settings, click on the `Pick Image` button. This will open the image browser.\n3. Select an image from the image browser. The selected image will be displayed in the `Image` field.\n4. Run the graph. The `Image` output of the Image Node should contain the selected image.\n\n![Image Node Example 1](./assets/image-node-example-01.png)\n\n## Error Handling\n\nThe Image Node will error if the `Data` input or the `Media Type` input is not provided. It will also error if the `Data` input cannot be converted into an image.\n\n## FAQ\n\n**Q: Can I use the Image Node to display an image in the Rivet UI?**\n\nA: Yes, the Image Node can be used to display an image in the Rivet UI. The image will be displayed in the node's output port when the graph is run.\n\n**Q: Can I use the Image Node to convert a binary type into an image?**\n\nA: Yes, you can use the Image Node to convert a binary type into an image. You will need to provide the binary data to the `Data` input of the Image Node and set the `Media Type` to the appropriate type for the image.\n\n**Q: What image formats are supported by the Image Node?**\n\nA: The Image Node supports PNG, JPEG, and GIF formats.\n\n## See Also\n\n- [Text Node](./text.mdx)\n- [Audio Node](./audio.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"5sFNfTQV7BC_sEH0Uua5n","data":["compare.mdx","---\nid: compare\ntitle: Compare Node\nsidebar_label: Compare\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Compare Node allows you to perform a comparison operation between two input values. The node supports a variety of comparison functions including equality, inequality, less than, greater than, and logical operations such as AND, OR, XOR, NAND, NOR, and XNOR.\n\n![Compare Node Screenshot](./assets/compare-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                      | Default Value | Notes |\n| ----- | --------- | -------------------------------- | ------------- | ----- |\n| A     | `any`     | The first value for comparison.  | (Required)    | None  |\n| B     | `any`     | The second value for comparison. | (Required)    | None  |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                             | Notes |\n| ------ | --------- | --------------------------------------- | ----- |\n| Output | `boolean` | The result of the comparison operation. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting             | Description                                                                                                                       | Default Value | Use Input Toggle | Input Data Type |\n| ------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Comparison Function | The comparison function to be used for the operation. Available options are '==', '<', '>', '<=', '>=', '!=', 'and', 'or', 'xor'. | '=='          | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Compare two numbers\n\n1. Create a Compare Node and set the `Comparison Function` to `>`.\n2. Create two [Number Nodes](./number.mdx), one with the value `5` and the other with the value `3`.\n3. Connect the Number Nodes to the `A` and `B` inputs of the Compare Node respectively.\n4. Run the graph. Note that the output of the Compare Node is `true`, because 5 is greater than 3.\n\n![Compare Node Example 1](./assets/compare-node-example-01.png)\n\n## Error Handling\n\nThe Compare Node does not have any specific error handling. If the inputs are not of the same type, the node will attempt to coerce the second input (`B`) to the type of the first input (`A`).\n\n## FAQ\n\n**Q: What happens if the inputs are not of the same type?**\n\nA: If the inputs are not of the same type, the node will attempt to coerce the second input (`B`) to the type of the first input (`A`). If the coercion is not possible, the comparison will be performed with the original values.\n\n**Q: Can I use the Compare Node to compare arrays or objects?**\n\nA: Yes, you can use the Compare Node to compare arrays or objects. However, the comparison will be performed using JavaScript's strict equality (`===`), which may not give the expected results for arrays or objects. For a deep comparison of arrays or objects, consider using a [Code Node](./code.mdx).\n\n## See Also\n\n- [If Node](./if.mdx)\n- [Match Node](./match.mdx)\n- [Code Node](./code.mdx)\n"]},{"id":"viYJAMmjZ0ys_CNcD7Yxz","data":["assemble-message.mdx","---\nid: assemble-message\ntitle: Assemble Message Node\nsidebar_label: Assemble Message\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Assemble Message Node Screenshot](./assets/assemble-message-node.png)\n\n## Overview\n\nThe Assemble Message Node is designed to assemble a single chat message from multiple parts. It is similar to a [Prompt Node](./prompt.mdx), but it works with multimodal models, allowing you to include both text and images in the message. This node is particularly useful when working with multimodal LLMs such as GPT-4 Vision that can process both text and images simultaneously.\n\nThe Assemble Message Node can be used in conjunction with the [Image Node](./image.mdx) or [URL Reference Node](./url-reference.mdx) to include images in a message.\n\nThe Assemble Message Node outputs a chat message in the same format as a [Prompt Node](./prompt.mdx).\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title  | Data Type                             | Description                                                                                                                                                             | Default Value | Notes                                                                                     |\n| ------ | ------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ----------------------------------------------------------------------------------------- |\n| Part N | `string`/`string[]`/`image`/`image[]` | A part of the message to assemble. Arrays connected to inputs will be flattened, so connecting a single `image[]` connection will put multiple images into the message. | N/A           | Dynamic number of input ports based on how many inputs are already connected to the node. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type      | Description                                                                                                         | Notes                                                                                                                |\n| ------- | -------------- | ------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |\n| Message | `chat-message` | The assembled chat message. The message will be in the same format as a message from a [Prompt Node](./prompt.mdx). | The output will be a chat message containing the assembled data. The type of the message will be the specified type. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                                                               | Default Value | Use Input Toggle | Input Data Type |\n| ------- | --------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Type    | The type of message to assemble. The value should be either 'system', 'user', 'assistant', or 'function'. | 'user'        | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Assemble a user message with text and an image\n\n1. Create an Assemble Message Node and set the Type to 'user'.\n1. Create a [Text Node](./text.mdx) and set the value to \"Here is an image:\". Connect the output of the Text Node to the first input of the Assemble Message Node.\n1. Create an [Image Node](./image.mdx) and browse for your image. Connect the output of the Image Node to the second input of the Assemble Message Node.\n1. Run the graph. The `Message` output of the Assemble Message Node should contain a user message with the text \"Here is an image of a cat:\" and the text `(Image)` indicating that an image is included in the message.\n\n![Assemble Message Node Example 1](./assets/assemble-message-node-example-01.png)\n\n## Error Handling\n\nThe Assemble Message Node will error if the `Type` input is enabled and is set to an invalid value.\n\n## FAQ\n\n**Q: Can I include multiple images in a message?**\n\nA: Yes, you can include multiple images in a message by connecting multiple input nodes.\n\n**Q: Can I use the Assemble Message Node with a function tool call?**\n\nA: Yes, you can set the Type to 'function' to assemble a function response tool call message. Note that function tool call messages require a Tool Call ID, which can be provided via the `Tool Call ID` input or setting. The output of the tool call is the assembled message content.\n\n**Q: Can I include a function call with an `assistant`-type message?**\n\nA: At this time, only the [Prompt Node](./prompt.mdx) supports function/tool calls with `assistant`-type messages.\n\n## See Also\n\n- [Prompt Node](./prompt.mdx)\n- [Image Node](./image.mdx)\n- [URL Reference Node](./url-reference.mdx)\n- [Array Node](./array.mdx)\n- [Chat Node](./chat.mdx)\n"]},{"id":"rVmHI2IZcark9YP3lxHzj","data":["extract-yaml.mdx","---\nid: extract-yaml\ntitle: Extract YAML Node\nsidebar_label: Extract YAML\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Extract YAML Node Screenshot](./assets/extract-yaml-node.png)\n\n## Overview\n\nThe Extract YAML Node is used to parse a YAML object from a string. It is particularly useful when you want to extract structured data from a text string that includes a YAML object.\n\nThe node looks for a predefined root property name in the input text and considers all indented text after that as part of the YAML object. By default, the root property name is set to `yamlDocument`, but it can be configured in the node settings or via an input port.\n\nYou may also specify a path to a specific property in the YAML object using a [JSONPath](https://goessner.net/articles/JsonPath/) expression. The node will then extract the value of that property from the YAML object. This is a shorthand for using the [Extract Object Path Node](./extract-object-path.mdx) after the Extract YAML Node.\n\nNote that the entire document includes the root property name. For example, if the root property name is set to `yamlDocument`, then the object path `$.yamlDocument` will return the entire document.\n\nThe Extract YAML Node can only extract a single YAML object from a string. If you want to extract multiple YAML objects from a string, you may want to use the [Code Node](./code.mdx) or [External Call Node](./external-call.mdx) to do more advanced text extraction.\n\nText outside of the YAML object will be ignored. If you want to extract text outside of the YAML object, you can use the [Extract with Regex Node](./extract-with-regex.mdx) instead.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title              | Data Type | Description                                                          | Default Value | Notes                                                                                                                        |\n| ------------------ | --------- | -------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| Input              | `string`  | The string that contains the YAML object.                            | (required)    | The input will be coerced into a string if it is not a string.                                                               |\n| Root Property Name | `string`  | The root property name of the YAML object in the input string.       | (optional)    | The input will be coerced into a string if it is not a string. This input is only available if enabled in the node settings. |\n| Object Path        | `string`  | The JSONPath expression to extract data from the parsed YAML object. | (optional)    | The input will be coerced into a string if it is not a string. This input is only available if enabled in the node settings. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                                                                                    | Notes                                                                                 |\n| -------- | --------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n| Output   | `object`  | The parsed YAML object or the value extracted from the object using the JSONPath expression.                   | If the YAML object or the value is not found, this port will not be ran.              |\n| Matches  | `any[]`   | When using a JSONPath expression that can match multiple times, represents all paths of the object that match. | If the YAML object or the value is not found, this port will run with an empty array. |\n| No Match | `string`  | If no YAML object is found in the input text, this port will run, with the full contents of the input string.  | If a YAML object is found in the input string, this port will not be ran.             |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting            | Description                                                          | Default Value  | Use Input Toggle | Input Data Type |\n| ------------------ | -------------------------------------------------------------------- | -------------- | ---------------- | --------------- |\n| Root Property Name | The root property name of the YAML object in the input string.       | `yamlDocument` | Yes              | `string`        |\n| Object Path        | The JSONPath expression to extract data from the parsed YAML object. | (empty)        | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract a YAML object from a string\n\n1. Create a [Text Node](./text.mdx) and set the text to the following:\n\n   ```\n   yamlDocument:\n     name: John Doe\n     age: 30\n     job: Engineer\n   ```\n\n2. Create an Extract YAML Node and connect the Text Node to its `Input` input.\n3. Run the graph. The `Output` of the Extract YAML Node should contain the parsed YAML object.\n\n![Extract YAML Node Example 1](./assets/extract-yaml-node-example-01.png)\n\n## Example 2: Extract a property from a YAML object\n\n1. Create a [Text Node](./text.mdx) and set the text to the following:\n\n   ```\n   yamlDocument:\n     name: John Doe\n     age: 30\n     job: Engineer\n   ```\n\n2. Create an Extract YAML Node and connect the Text Node to its `Input` input.\n3. Set the `Object Path` of the Extract YAML Node to `$.yamlDocument.name`.\n4. Run the graph. The `Output` of the Extract YAML Node should contain the value `John Doe`.\n\n![Extract YAML Node Example 2](./assets/extract-yaml-node-example-02.png)\n\n## Error Handling\n\nIf the JSONPath expression is invalid, the Extract YAML Node will error. If the YAML object or the value is not found, the `Output` and `Matches` outputs will not be ran, and the `No Match` output will run with the full contents of the input string.\n\n## FAQ\n\n**Q: Can I use the Extract YAML Node to extract data from a JSON object?**\n\nA: No, the Extract YAML Node is specifically designed to parse YAML objects. If you want to extract data from a JSON object, you can use the [Extract JSON Node](./extract-json.mdx) instead.\n\n**Q: Can I use the Extract YAML Node to extract an array from a YAML object?**\n\nA: Yes, you can use the Extract YAML Node to extract any valid YAML structure, including arrays. You can use a JSONPath expression to specify the path to the array in the YAML object. Alternatively you can specify a multi-match such as `$.yamlDocument.someArray[*]` and use the `Matches` output to get all the matches.\n\n## See Also\n\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"tUUh6hVlvA6UOP3E_qKvN","data":["graph-output.mdx","---\nid: graph-output\ntitle: Graph Output Node\nsidebar_label: Graph Output\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Graph Output Node Screenshot](./assets/graph-output-node.png)\n\n## Overview\n\nThe Graph Output Node is used to define the outputs of a graph. Each instance of this node represents an individual output of the graph. The value passed into this node becomes part of the overall output of the graph.\n\nWhen a graph is used as a subgraph, each Graph Output Node in the graph turns into an output port on the subgraph node.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                                                                      | Default Value | Notes |\n| ----- | --------- | -------------------------------------------------------------------------------------------------------------------------------- | ------------- | ----- |\n| Value | `any`     | The value to be outputted from the graph. The data type of the value should match the data type configured in the node settings. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title        | Data Type | Description                                                                                                                    | Notes |\n| ------------ | --------- | ------------------------------------------------------------------------------------------------------------------------------ | ----- |\n| Value Output | `any`     | The value that was passed into the node. The data type of the output will match the data type configured in the node settings. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                                                                                                                                                                         | Default Value | Use Input Toggle | Input Data Type |\n| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| ID        | The ID of the output. This will be used as the name and ID of the output port of the graph.                                                                                                                         | `output`      | No               | `string`        |\n| Data Type | The data type of the value to be outputted from the graph. This should match the data type of the value passed into the node. If the data type of the input data does not match, it will be coerced into this type. | `string`      | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Define an output for a graph\n\n1. Create a [Text Node](./text.mdx) and set the value to `Hello, world!`.\n2. Create a Graph Output Node and set the ID to `greeting` and the Data Type to `String`.\n3. Connect the Text Node to the `Value` input of the Graph Output Node.\n4. Create another graph, and add a [Subgraph Node](./subgraph.mdx) to the graph. Set the Subgraph Node's Graph ID to the ID of the graph created in step 1.\n5. Run the graph. You should see the `greeting` output of the subgraph is \"Hello, world!\"\n\n![Graph Output Node Example 1](./assets/graph-output-node-example-01.png)\n![Graph Output Node Example 1](./assets/graph-output-node-example-01-2.png)\n\n## Error Handling\n\nThe Graph Output Node will error if the data type of the value passed into the node does not match the data type configured in the node settings.\n\n## FAQ\n\n**Q: Can I have multiple Graph Output Nodes in a graph?**\n\nA: Yes, you can have multiple Graph Output Nodes in a graph. Each Graph Output Node represents an individual output of the graph. The ID of each Graph Output Node should be unique.\n\n**Q: What happens if the ID of a Graph Output Node is not unique?**\n\nA: If the ID of a Graph Output Node is not unique, the output of the graph will contain the value of the last Graph Output Node with that ID that was processed.\n\n**Q: Can I use the Graph Output Node to output an array or an object?**\n\nA: Yes, you can use the Graph Output Node to output any data type. The data type of the value passed into the node should match the data type configured in the node settings.\n\n## See Also\n\n- [Graph Input Node](./graph-input.mdx)\n- [Subgraph Node](./subgraph.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"W0VGKld1IovYETs0LdvDl","data":["coalesce.mdx","---\nid: coalesce\ntitle: Coalesce Node\nsidebar_label: Coalesce\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Coalesce Node works like the `COALESCE` function in SQL - it returns the first non-null value from a list of inputs.\n\nIn Rivet, \"null\" includes values that show as \"Not Ran\" in the UI - nodes that have been excluded from the run due to control flow processing.\nThe Coalesce node excels at taking a set of nodes, one of which will be run, and returning the output of the first one that actually runs. See\nthe examples section for more information on using this with a [Match Node](./match.mdx).\n\n![Coalesce Node Screenshot](./assets/coalesce-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type | Description                                                                                                                        | Default Value | Notes                                                                                                                                                                                      |\n| ----------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Conditional | `boolean` | If connected, this can be used so that the coalesce node itself is only run conditionally.                                         | N/A           | Otherwise, the input is treated as any of the other inputs, so if you want to run the coalesce node conditionally, you must connect to this specific port with e.g. an [If Node](./if.mdx) |\n| Input X     | Any       | One of the inputs to check for nullness. The first one of these inputs that is non-null will be passed through to the output port. | N/A           | Dynamic number of inputs based on how many are connected.                                                                                                                                  |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                            | Notes                                                   |\n| ------ | --------- | -------------------------------------- | ------------------------------------------------------- |\n| Output | Any       | The value of the first non-null input. | If no inputs are null, then the output will not be ran. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Default Values / Null Checks\n\nYou can use a Coalesce Node in order to do null checks and set default values for a parameter.\n\n1. Create an If node but do not connect to the input, so that it wil not be ran.\n2. Connect the output of the If node to the Coalesce node.\n3. Connect a Text node with a hardcoded value to the 2nd input of the Coalesce node.\n4. Run the graph. Note that the output of the Coalesce node will be the value of the Text node, since the If node was not ran.\n\n![Coalesce Node Example 1 Screenshot](./assets/coalesce-node-example-01.png)\n\n## Example 2: Getting a single value from a Match node\n\n1. Create a [Match Node](./match.mdx) with a few different cases, say `1`, `2`, and `3`.\n2. For each of the cases, use an [If Node](./if.mdx) to transform each of the cases into a unique value, say `A`, `B`, and `C`. You can use a [Text Node](./text.mdx) connected to the `value` port of the If Nodes to set the value passed through for each of the cases.\n3. Connect the outputs of each of the If nodes to one of the inputs on a Coalesce node.\n4. Connect an input to the Match node so that only one of the cases will be ran.\n5. Run the graph. Note that the output of the Coalesce node will be the value of the If node that was ran.\n\nThe above is a common pattern for working with a Match node - you can get a unique value for each case using an If node, which is not dependent on the value passed into the Match node itself.\n\n![Coalesce Node Example 2 Screenshot](./assets/coalesce-node-example-02.png)\n\n## Error Handling\n\nThe coalesce node cannot error in normal operation.\n\n## FAQ\n\n**Q: Will an empty string be passed over?**\n\nA: No, an empty string is not considered nullable for the Coalesce Node. If you would like to skip over empty strings, you can use an If Node to check for empty strings and return null if the string is empty.\n\n## See Also\n\n- [Match Node](./match.mdx)\n- [If Node](./if.mdx)\n- [If/Else Node](./if-else.mdx)\n"]},{"id":"fXUc8tKXH1M10E5T9kWvi","data":["set-global.mdx","---\nid: set-global\ntitle: Set Global Node\nsidebar_label: Set Global\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Set Global Node Screenshot](./assets/set-global-node.png)\n\n## Overview\n\nThe Set Global Node is used to set a global value that is shared across all graphs and subgraphs during an execution in Rivet. This can be useful for storing and retrieving values that need to be accessed by multiple graphs.\n\nThe Set Global Node allows you to specify the ID of the global value and the value itself. The ID can be either a static string or an input value. The value can be of any data type.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type | Description                                                                                          | Default Value | Notes                                                                                                |\n| ----------- | --------- | ---------------------------------------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------- |\n| Value       | Any       | The value to be set as the global value.                                                             | (required)    | The input will be coerced into the data type specified in the node's settings.                       |\n| Variable ID | `string`  | The ID of the global value to be set. This input is only available if `Use Variable ID Input` is on. | (optional)    | The input will be coerced into a string if it is not a string. The ID must be unique in the context. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title          | Data Type | Description                                                             | Notes                                                                                                                       |\n| -------------- | --------- | ----------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |\n| Value          | Any       | The value that was set as the global value.                             | The output will be of the same data type as the `Value` input.                                                              |\n| Previous Value | Any       | The previous value of the global variable before the new value was set. | The output will be of the same data type as the `Value` input. If there was no previous value, this output will not be ran. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                                             | Default Value | Use Input Toggle | Input Data Type |\n| --------- | --------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| ID        | The ID of the global value to be set.                                                   | (required)    | Yes              | `string`        |\n| Data Type | The data type of the value to be set. This determines how the `Value` input is coerced. | `string`      | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Set a global value\n\n1. Create a [Text Node](./text.mdx) and set the value to `Hello, World!`.\n2. Create a Set Global Node and set the ID to `greeting`.\n3. Connect the Text Node to the `Value` input of the Set Global Node.\n4. Run the graph. The `Value` output of the Set Global Node should contain the value `Hello, World!`.\n\n![Set Global Node Example 1](./assets/set-global-node-example-01.png)\n\n## Error Handling\n\nThe Set Global Node will error if the `Value` input is not provided or if the ID of the global value is not provided or not unique.\n\n## FAQ\n\n**Q: Can I set a global value to an array or an object?**\n\nA: Yes, you can set a global value to any data type, including arrays and objects. You can use an [Array Node](./array.mdx) or an [Object Node](./object.mdx) to create an array or an object, and then connect it to the `Value` input of the Set Global Node.\n\n## See Also\n\n- [Get Global Node](./get-global.mdx)\n- [Text Node](./text.mdx)\n- [Array Node](./array.mdx)\n- [Object Node](./object.mdx)\n"]},{"id":"KbhtF9Ht_Cz-83tdOfqh1","data":["split-text.mdx","---\nid: split-text\ntitle: Split Text Node\nsidebar_label: Split Text\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Split Text Node Screenshot](./assets/split-text-node.png)\n\n## Overview\n\nThe Split Text Node is used to split a string into an array of substrings based on a specified delimiter. This is useful when you want to separate a string into individual elements for further processing.\n\nThe node allows you to specify the delimiter either directly in the node settings or dynamically via an input port. The delimiter can be any string, including special characters like newline (`\\n`), tab (`\\t`), and space (` `).\n\nWhen entering special characters such as a new line in the node settings, put the literal character, not the escape sequence. For example, to split a string by a new line, press the Enter key to insert a new line in the node settings.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                                                                                             | Default Value | Notes                                                          |\n| --------- | --------- | ------------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------- |\n| String    | `string`  | The string that should be split.                                                                        | (required)    | The input will be coerced into a string if it is not a string. |\n| Delimiter | `string`  | The delimiter to split the string by. This input is only available if `Use Delimiter Input` is enabled. | (empty)       | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title        | Data Type  | Description                                                                                   | Notes |\n| ------------ | ---------- | --------------------------------------------------------------------------------------------- | ----- |\n| Split String | `string[]` | The array of substrings resulting from splitting the input string by the specified delimiter. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting             | Description                                                             | Default Value | Use Input Toggle | Input Data Type |\n| ------------------- | ----------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Delimiter           | The delimiter to split the string by.                                   | `,`           | Yes              | `string`        |\n| Use Delimiter Input | If enabled, the delimiter can be provided via the Delimiter input port. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Split a string into words\n\n1. Create a [Text Node](./text.mdx) and set the value to `Hello, world!`.\n2. Create a Split Text Node and set the Delimiter to `,`.\n3. Connect the Text Node to the `String` input of the Split Text Node.\n4. Run the graph. The `Split` output of the Split Text Node should contain the array `[\"Hello\", \" world!\"]`.\n\n![Split Text Node Example 1](./assets/split-text-node-example-01.png)\n\n## Example 2: Split a string into lines\n\n1. Create a [Text Node](./text.mdx) and set the value to:\n\n   ```\n   Hello,\n   world!\n   ```\n\n2. Create a Split Text Node and set the Delimiter to `\\n`.\n3. Connect the Text Node to the `String` input of the Split Text Node.\n4. Run the graph. The `Split` output of the Split Text Node should contain the array `[\"Hello,\", \"world!\"]`.\n\n![Split Text Node Example 2](./assets/split-text-node-example-02.png)\n\n## Error Handling\n\nThe Split Text Node will error if the `String` input is not provided. If the `Delimiter` input or setting is not provided, the node will not split the string and will output the original string as a single-element array.\n\n## FAQ\n\n**Q: Can I split a string by multiple delimiters?**\n\nA: No, the Split Text Node can only split a string by a single delimiter. If you want to split a string by multiple delimiters, you can use multiple Split Text Nodes in sequence.\n\n**Q: Can I split a string by a regular expression?**\n\nA: No, the Split Text Node does not support splitting a string by a regular expression. You can use a [Code Node](./code.mdx) to split a string by a regular expression using JavaScript's `split()` method.\n\n**Q: What happens if the delimiter is not found in the string?**\n\nA: If the delimiter is not found in the string, the Split Text Node will output the original string as a single-element array.\n\n## See Also\n\n- [Join Node](./join.mdx)\n- [Text Node](./text.mdx)\n- [Code Node](./code.mdx)\n- [Array Node](./array.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n"]},{"id":"X_hqbUqFCFUQUfkplUewE","data":["chat.mdx","---\nid: chat\ntitle: Chat Node\nsidebar_label: Chat\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Chat Node send one or more messages to an LLM - OpenAI's GPT, or any API compatible with the OpenAI API. It then returns the response from the LLM.\n\nYou can use the Chat Node for local LLMs, as long as their API is compatible with the OpenAI API. For example, you can use the Chat Node with [LM Studio](https://lmstudio.ai/).\n\nIf you are looking for other language models that do not support the OpenAI API format, see the Plugins page for a list of available plugins that implement other language model nodes.\n\n![Chat Node Screenshot](./assets/chat-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title         | Data Type                                                 | Description                                                                                          | Default Value | Notes                                                                                                                                                                                                            |\n| ------------- | --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| System Prompt | `string` or `chat-message`                                | A convenience input that allows a system prompt to be prepended to the main prompt message/messages. | (None)        | If not connected, then no system prompt will be prepended. You can always include a system prompt in the main prompt input instead, if you like instead, using an [Assemble Prompt](./assemble-prompt.mdx) node. |\n| Prompt        | `string` / `string[]` / `chat-message` / `chat-message[]` | The main prompt to send to the language model. Can be one or more strings or chat-messages.          | (Empty list)  | Strings will be converted into chat messages of type `user`, with no name.                                                                                                                                       |\n| Functions     | `gpt-function` or `gpt-function[]`                        | Defines the available functions that GPT is allowed to call during its response.                     | (Required)    | Only enabled if the `Enable Function Use` setting is enabled.                                                                                                                                                    |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description            | Notes                                                                                                       |\n| -------- | --------- | ---------------------- | ----------------------------------------------------------------------------------------------------------- |\n| Response | string    | The response from GPT. | The response will be streamed in, but subsequent nodes will not be executed until the response is finished. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting                         | Description                                                                                                                                                                                                                                                                                             | Default Value                                                                                                               | Use Input Toggle | Input Data Type |\n| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- | ---------------- | --------------- |\n| Model                           | The GPT model to use for the request. If you are not using OpenAI's GPT, and you would like to set the `model` parameter, you can see the Custom Model setting below.                                                                                                                                   | `gpt-3.5-turbo`                                                                                                             | Yes              | `string`        |\n| Temperature                     | The sampling temperature to use. Lower values are more deterministic. Higher values are more \"creative\".                                                                                                                                                                                                | 0.5                                                                                                                         | Yes              | `number`        |\n| Top P                           | Alternate sampling mode using the top X% of values. 0.1 corresponds to the top 10%.                                                                                                                                                                                                                     | 1                                                                                                                           | Yes              | `number`        |\n| Use Top P                       | Whether to use the Top P sampling mode.                                                                                                                                                                                                                                                                 | false                                                                                                                       | Yes              | `boolean`       |\n| Max Tokens                      | The maximum number of tokens that GPT is allowed to return. When hitting the max tokens, the response will be cut off.                                                                                                                                                                                  | 1024                                                                                                                        | Yes              | `number`        |\n| Stop                            | Comma separated list of stop tokens. If any stop token is encountered, the response will end immediately.                                                                                                                                                                                               | (None)                                                                                                                      | Yes              | `string[]`      |\n| Presence Penalty                | Applies a penalty or bonus for tokens that have already been used. See the OpenAI documentation for more info.                                                                                                                                                                                          | 0                                                                                                                           | Yes              | `number`        |\n| Frequency Penalty               | Applies a penalty or bonus for tokens based on how much they have been used. See the OpenAI documentation for more info.                                                                                                                                                                                | 0                                                                                                                           | Yes              | `number`        |\n| User                            | Attaches a user field, for monitoring and detecting abuse. See the OpenAI documentation for more info.                                                                                                                                                                                                  | (Empty)                                                                                                                     | Yes              | `string`        |\n| Number of Choices               | Allows the Chat Node to output a list of responses simultaneously if the value is greater than 1. Each response will have a unique set of text (assuming the temperature is more than 0)                                                                                                                | 1                                                                                                                           | Yes              | `number`        |\n| Enable Function Use             | Allows the use of functions in the prompt. Enables the `Functions` input.                                                                                                                                                                                                                               | false                                                                                                                       | No               | N/A             |\n| Cache                           | Caches the response locally in Rivet. If the chat node gets the exact same prompt again, it will return the cached response instead of making a new request to OpenAI.                                                                                                                                  | false                                                                                                                       | No               | N/A             |\n| Use for subgraph partial output | If enabled, the Chat Node will be used to generate partial output for subgraphs. This is only visual - the chat node's partial output will appear as the subgraph's partial output. Only enable if the chat node will be running exclusively from other chat nodes at the same time, to avoid problems. | true                                                                                                                        | No               | N/A             |\n| Endpoint                        | The endpoint to use for the request. For example, you can set the endpoint to `http://localhost:1234/v1/chat/completions` for LM Studio. You may also set a global Chat Node endpoint int the Rivet Settings page.                                                                                      | (empty string, uses the default endpoint configured in Settings, or OpenAI's chat completions endpoint if that is not set.) | No               | `string`        |\n| Custom Model                    | If you are not using OpenAI's GPT, you can set the `model` parameter here, to a custom string. This parameter overrides the model defined above.                                                                                                                                                        | (None)                                                                                                                      | No               | `string`        |\n| Headers                         | Allows you to set custom headers to send with the request.                                                                                                                                                                                                                                              | (None)                                                                                                                      | Yes              | `object`        |\n\nFor all settings, see the [OpenAI API documentation](https://platform.openai.com/docs/api-reference/chat/create) for more information.\n\n</TabItem>\n\n</Tabs>\n\n### Example 1: Simple Response\n\n1. Add a Chat node to your graph.\n2. Add a text node and place your message to GPT inside the text node by opening its editor and replacing `{{input}}` with your message.\n3. Connect the output of the text node to the `Prompt` input of the Chat node.\n4. Run your graph. You will see the output of the Chat node at the bottom of the node.\n\n![Simple Response Example](./assets/chat-node-example-01.png)\n\n### Example 2: Connecting to LM Studio\n\n1. Add a Chat node to your graph.\n2. Add a text node and place your message to GPT inside the text node by opening its editor and replacing `{{input}}` with your message.\n3. Connect the output of the text node to the `Prompt` input of the Chat node.\n4. Set the `Endpoint` setting to `http://localhost:1234/v1/chat/completions`.\n5. Load your desired model into LM Studio.\n6. Enable CORS in LM Studio Server Options.\n7. Run your graph. You will see the output of the Chat node at the bottom of the node.\n\n## Error Handling\n\nIf nothing is connected to the `Prompt` input, the Chat node will error.\n\nIf the request to OpenAI fails due to rate-limiting, the Chat node will retry the request using a jittered exponential backoff algorithm. This retry will\nhappen for up to 5 minutes. If the request still fails after 5 minutes, the Chat node will error.\n\n:::caution\n\nBe careful [splitting](../user-guide/splitting.md) a Chat node too much that you run into rate limiting issues.\n\n:::\n\nIf OpenAI returns a 500-level error (due to being overloaded or downtime, etc), the Chat node will retry in a similar manner.\n\n## FAQ\n\n**Q: What if I connect a different data type to the prompt or system prompt input?**\n\nA: The value will be attempted to be converted into a string, which will turn into a `user` type chat messages. So for example a number 5 will turn into a user message \"5\".\nIf the value cannot be converted to a string, then it will be ignored for the list of prompt messages.\n\n**Q: What if an input is toggled on, but not connected?**\n\nA: The value configured in the UI will be used instead.\n\n**Q: What if the system prompt is connected, but the prompt is not?**\n\nA: The Chat Node will error. The prompt input is required. To send only a system prompt, you can use a [Prompt](./prompt.mdx) node to create a system-type prompt, and connect it to the `Prompt` input.\n\n**Q: What if the system prompt is connected, and the prompt also contains a system prompt?**\n\nA: Both system prompts will be sent. System prompts that are not the first message in a chain are undefined behavior in GPT. It may work, or it may act strangely. It may follow one or both of the system prompts.\n\n## See Also\n\n- [Assemble Prompt Node](./assemble-prompt.mdx)\n- [Prompt Node](./prompt.mdx)\n- [Text Node](./text.mdx)\n- [OpenAI API Documentation](https://platform.openai.com/docs/api-reference/chat/create)\n"]},{"id":"7jd_22Cqv7sPBtNQp5yhG","data":["if-else.mdx","---\nid: if-else\ntitle: If/Else Node\nsidebar_label: If/Else\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![If/Else Node Screenshot](./assets/if-else-node.png)\n\n## Overview\n\nThe If/Else Node is a control flow node that allows you to choose between two different values based on a condition. It takes in three inputs: a condition, a true value, and a false value. If the condition is truthy, the true value is passed through the output port. If the condition is not truthy, the false value is passed through the output port.\n\nThis node can \"consume\" a `Not Ran` to continue a graph from that point. This means that if a `Not Ran` value is passed into the `If` port, the `False` value will be passed through instead. If the `False` value is not connected, then the result will again be `Not Ran`.\n\nThe If/Else node is particularly useful for always ensuring that a graph returns a value, and the outputs of the graph always run, or ensuring that a later node in the graph always receives a value, even if intermediate nodes do not run.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                  | Default Value | Notes                                                                                              |\n| ----- | --------- | ---------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------------------- |\n| If    | `any`     | The condition to evaluate. If truthy, the true value is passed through.      | (required)    | The input will be coerced into a boolean if it is not a boolean.                                   |\n| True  | `any`     | The value to pass through if the condition is truthy.                        | (empty)       | The input will be coerced into the same data type as the `False` input if it is not the same type. |\n| False | `any`     | The value to pass through if the condition is not truthy or is not provided. | (empty)       | The input will be coerced into the same data type as the `True` input if it is not the same type.  |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                                                                                     | Notes |\n| ------ | --------- | ----------------------------------------------------------------------------------------------- | ----- |\n| Output | `any`     | The value that was passed through based on the condition. Either the true value or false value. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Choose between two values based on a condition\n\n1. Create a [Bool Node](./bool.mdx). Set the value of the Bool Node to `true`.\n2. Create two [Text Nodes](./text.mdx). Set the text of one node to `Hello` and the other to `World`.\n3. Create an If/Else Node. Connect the Bool Node to the `If` input of the If/Else Node. Connect the Text Node with the text `Hello` to the `True` input of the If/Else Node. Connect the Text Node with the text `World` to the `False` input of the If/Else Node.\n4. Run the graph. The output of the If/Else Node should be `Hello`.\n5. Try changing the value of the Bool Node to `false`. Run the graph again. The output of the If/Else Node should now be `World`.\n\n![If/Else Node Example 1](./assets/if-else-node-example-01.png)\n\n## Example 2: Provide a default value for a missing input\n\n1. Create an [If Node](./if.mdx) but do not connect anything to its `If` input.\n2. Create two [Text Nodes](./text.mdx). Set the text of one node to `Hello` and the other to `World`.\n3. Connect the Hello Text Node to the `Value` input of the If Node.\n4. Create an If/Else Node. Connect the If Node to the `If` and `True` inputs of the If/Else Node. Connect the Text Node with the text `World` to the `False` input of the If/Else Node.\n5. Run the graph. The output of the If/Else Node should be `World`.\n\n![If/Else Node Example 2](./assets/if-else-node-example-02.png)\n\n## Error Handling\n\nThe If/Else node will not throw an error under normal circumstances.\n\n## FAQ\n\n**Q: What is considered truthy in Rivet?**\n\nA: Any value that is considered truthy in JavaScript, plus any non-empty Array, is considered truthy in Rivet. This includes:\n\n- `true`\n- Any non-zero number\n- Any non-empty string\n- Any non-empty Array\n- Any object\n- Any function\n\nAll other values are considered falsy, including the string value `\"false\"`.\n\n**Q: What happens if the `If` input is `Not Ran`?**\n\nA: If the `If` input is `Not Ran`, the `False` value will be passed through instead. If the `False` value is not connected, then the result will again be `Not Ran`.\n\n**Q: What happens if the `True` or `False` inputs are not provided?**\n\nA: If the `True` or `False` inputs are not provided, they will default to `Not Ran`.\n\n**Q: Can I use the If/Else Node to choose between two different types of values?**\n\nA: Yes, you can use the If/Else Node to choose between two different types of values. For example, you can use it to choose between a string and a number based on a condition. However, keep in mind that the output of the If/Else Node will be of the same type as the value that was passed through.\n\n## See Also\n\n- [If Node](./if.mdx)\n- [Match Node](./match.mdx)\n- [Coalesce Node](./coalesce.mdx)\n- [Control Flow](../user-guide/control-flow.md)\n"]},{"id":"A2KtPrQiO7Owoc1vFm2CU","data":["subgraph.mdx","---\nid: subgraph\ntitle: Subgraph Node\nsidebar_label: Subgraph\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Subgraph Node Screenshot](./assets/subgraph-node.png)\n\n## Overview\n\nThe Subgraph Node allows you to execute another graph within the current graph. This is useful for reusing logic across multiple graphs, or for breaking down complex graphs into smaller, more manageable pieces.\n\nThe inputs and outputs of the Subgraph Node are defined by [Graph Input Nodes](./graph-input.mdx) and [Graph Output Nodes](./graph-output.mdx) within the subgraph. The Subgraph Node will automatically update its inputs and outputs to match those of the selected subgraph.\n\nThe Subgraph Node also has an optional error output. If enabled, any errors that occur while executing the subgraph will be caught and output from the error output port. If not enabled, errors will cause the entire graph to fail.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title          | Data Type | Description                                                                                        | Default Value | Notes                         |\n| -------------- | --------- | -------------------------------------------------------------------------------------------------- | ------------- | ----------------------------- |\n| (custom names) | Any       | The input values passed into the subgraph. Dynamic based on the inputs configured in the subgraph. | N/A           | Always accepts any data type. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title          | Data Type | Description                                                                                                    | Notes                                                                                                              |\n| -------------- | --------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| (custom names) | Any       | The output values from the execution of the subgraph. Dynamic based on the outputs configured in the subgraph. | Always accepts any data type.                                                                                      |\n| Error          | `string`  | If the subgraph errors, will be populated with the error message.                                              | Only enabled if `Use Error Output` is turned on. If `Use Error Output` is turned off, the node will error instead. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting          | Description                                                                                                                                                                                      | Default Value | Use Input Toggle | Input Data Type |\n| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Graph            | The graph to execute when this node is ran. Must be a graph in the same project.                                                                                                                 | (required)    | No               | N/A             |\n| Use Error Output | If enabled, then the Subgraph node will not fail, but instead any error will appear in the `Error` output port of the node. If disabled, the entire Subgraph node will error if the call errors. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Reuse a graph in multiple places\n\n1. Create a new graph in your project, and add a [Graph Input Node](./graph-input.mdx) and a [Graph Output Node](./graph-output.mdx) to it. Connect the Graph Input Node to a [Text Node](./text.mdx) and connect that node to Graph Output Node.\n2. Update the Text node to have the text `{{input}}\nHi, From Subgraph`.\n3. In your main graph, add a Subgraph Node. In the editor settings, set the `Graph` to the graph you created in step 1.\n4. Connect a [Text Node](./text.mdx) to the input of the Subgraph Node.\n5. Set the Text of the Text Node to `Hello Subgraph!`.\n6. Run the graph. Note that the text is passed through the subgraph and back to the main graph with the text from the subgraph appended to it.\n\n![Subgraph Node Example 1a](./assets/subgraph-node-example-01a.png)\n![Subgraph Node Example 1b](./assets/subgraph-node-example-01b.png)\n\n## Example 2: Handle errors in a subgraph\n\n1. Using the same graphs from Example 1, in the subgraph add a vector store node.\n2. Connect all the outputs from the text node to the vector store node.\n3. This will cause the Vector Store Node to Error\n4. In your main graph, add a Subgraph Node. In the editor settings enable `Use Error Output`.\n5. Connect [Text Nodes](./text.mdx) to both outputs of the Subgraph Node.\n6. Run the graph. Note that the error is output on the `Error` port of the Subgraph Node, and the `Output` port is not ran.\n\n![Subgraph Node Example 2a](./assets/subgraph-node-example-02a.png)\n![Subgraph Node Example 2b](./assets/subgraph-node-example-02b.png)\n\n## Error Handling\n\nIf the subgraph errors, then the Subgraph Node will error. If you want to handle errors in the graph, then you can enable the `Use Error Output` setting. This will cause the Subgraph Node to not error, but instead pass the error message to the `Error` output port. If the `Error` port is populated, then the `Result` port will not be ran. You can use an [If Node](./if.mdx) to check if the `Error` port is populated, and handle the error accordingly.\n\n## FAQ\n\n**Q: Can I use the Subgraph Node to execute a graph in a different project?**\n\nA: No, the Subgraph Node can only execute graphs within the same project.\n\n**Q: Can I use the Subgraph Node to execute a graph in a loop?**\n\nA: Yes, you can use a [Loop Controller Node](./loop-controller.mdx) to execute a Subgraph Node in a loop. Each iteration of the loop will execute the subgraph with the current loop value as an input.\n\n**Q: Can I use the Subgraph Node to execute a graph conditionally?**\n\nA: Yes, you can use an [If Node](./if.mdx) to conditionally execute a Subgraph Node. If the condition is false, the Subgraph Node will not be executed.\n\n## See Also\n\n- [Graph Input Node](./graph-input.mdx)\n- [Graph Output Node](./graph-output.mdx)\n- [If Node](./if.mdx)\n- [Loop Controller Node](./loop-controller.mdx)\n- [Text Node](./text.mdx)\n"]},{"id":"cJJLvktt0P3Af84p61ti7","data":["read-directory.mdx","---\nid: read-directory\ntitle: Read Directory Node\nsidebar_label: Read Directory\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Read Directory Node Screenshot](./assets/read-directory-node.png)\n\n## Overview\n\nThe Read Directory Node reads the contents of a specified directory and outputs an array of filenames. The node can also be configured to read directories recursively, include directories in the output, filter the filenames, return relative paths, and ignore certain files or directories.\n\nIf you are using the Rivet SDK, this node requires a native API to be available in the context when the graph is being run. The native API is responsible for providing the functionality to read the contents of a directory.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\nThe only inputs for the Read Directory node are toggleable Editor Settings. See that section for possible inputs.\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title     | Data Type  | Description                                       | Notes                                                                                                                                      |\n| --------- | ---------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\n| Paths     | `string[]` | An array of filenames in the specified directory. | If the directory does not exist or is not accessible, the output will be an array with one element containing the string `(no such path)`. |\n| Root Path | `string`   | The path of the directory that was read.          | The output will be the same as the Path input or the Path specified in the settings.                                                       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting             | Description                                                                                                                                                      | Default Value | Use Input Toggle | Input Data Type |\n| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Path                | The path of the directory to read.                                                                                                                               | (required)    | Yes              | `string`        |\n| Recursive           | If enabled, the node will read directories recursively.                                                                                                          | `false`       | Yes              | `boolean`       |\n| Include Directories | If enabled, the node will include directories in the output.                                                                                                     | `false`       | Yes              | `boolean`       |\n| Filter Globs        | An array of glob patterns to filter the filenames, comma-separated.                                                                                              | `[]`          | Yes              | `string[]`      |\n| Relative            | If enabled, the node will return relative paths.                                                                                                                 | `false`       | Yes              | `boolean`       |\n| Ignores             | An array of glob patterns to ignore certain files or directories, comma-separated. For example, to filter out `node_modules`, you can do `**/node_modules/**/*`. | `[]`          | Yes              | `string[]`      |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Read the contents of a directory\n\n1. Create a Read Directory Node and set the `Path` to the directory you want to read.\n2. Run the graph. The `Paths` output of the Read Directory Node should contain an array of filenames in the specified directory.\n\n![Read Directory Node Example 1](./assets/read-directory-node-example-01.png)\n\n## Error Handling\n\nThe Read Directory Node will error if the native API is not available in the context when the graph is being run. It will also error if the `Path` input is not provided.\n\nIf the directory does not exist or is not accessible, the `Paths` output will be an array with one element containing the string `(no such path)`.\n\n## FAQ\n\n**Q: What is a native API?**\n\nA: A native API is an object that is responsible for providing native functionality to nodes. It is passed to the context when the graph is being run. The native API must implement the `NativeApi` interface, which includes methods for reading directories, reading and writing files, and other native operations. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I read directories recursively?**\n\nA: Yes, you can set the `Recursive` input or setting to `true` to read directories recursively.\n\n**Q: What does it mean to include directories in the output?**\n\nA: If the `Include Directories` input or setting is set to `true`, the `Paths` output will contain directory names in addition to filenames. For example, if the `Path` input is set to `/Users/username/Documents`, the `Paths` output will contain filenames like `file.txt` and directory names like `subdirectory` and `subdirectory2`.\n\n**Q: How to I filter or ignore using globs?**\n\nA: Glob patterns are a way to filter filenames using wildcards. For example, to filter out all `.txt` files, you can do `**/*.txt`. To filter out all files in a `node_modules` directory, you can do `**/node_modules/**/*`.\n\n**Q: What does it mean to return relative paths?**\n\nA: If the `Relative` input or setting is set to `true`, the `Paths` output will contain relative paths instead of absolute paths. For example, if the `Path` input is set to `/Users/username/Documents`, the `Paths` output will contain filenames like `file.txt` instead of `/Users/username/Documents/file.txt`.\n\n## See Also\n\n- [Read File Node](./read-file.mdx)\n"]},{"id":"GLXORWwUD_0SexmLsJgtR","data":["extract-object-path.mdx","---\nid: extract-object-path\ntitle: Extract Object Path Node\nsidebar_label: Extract Object Path\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Extract Object Path Node Screenshot](./assets/extract-object-path-node.png)\n\n## Overview\n\nThe Extract Object Path Node allows you to run [jsonpath](https://www.npmjs.com/package/jsonpath-plus) queries on an object. This is useful for extracting data from a JSON object or array. Some use-cases include:\n\n- Extracting data from a JSON object returned by an API\n- Extracting properties from the result of an [Extract JSON](./extract-json.mdx) node or [Extract YAML](./extract-yaml.mdx) node\n- Accessing individual elements of an array\n- Complex queries such as `$.store.book[?(@.price < 10)]` to perform filtering\n\nAny valid [`jsonpath-plus`](https://www.npmjs.com/package/jsonpath-plus) query can be used, but just be careful about complex queries.\n\nThe input to Extract Object path must be either an object, or an array of any data type. You can also query properties of non-object data types, such as strings, such as `$.length` to get the length of a string.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title  | Data Type                       | Description                         | Default Value | Notes |\n| ------ | ------------------------------- | ----------------------------------- | ------------- | ----- |\n| Object | `object` or `any[]` or `string` | The object to query using the path. | (required)    |       |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title       | Data Type | Description                                                                                                               | Notes                                                              |\n| ----------- | --------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Match       | `any`     | If the value is found in the object, the value matched.                                                                   | If the value is not found, this port is not ran.                   |\n| All Matches | `any[]`   | When using a path that can match multiple times, such as `$.someArray[*]`, represents all paths of the object that match. | If the value is not found, this port will run with an empty array. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                           | Default Value | Use Input Toggle | Input Data Type |\n| ------- | --------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Path    | The jsonpath path to use to extract properties from the input object. | `$`           | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract a property from an object\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   {\n     \"name\": \"John Doe\",\n     \"age\": 30\n   }\n   ```\n\n2. Create an Extract Object Path Node and connect the Object Node to it. Set the `Path` of the Extract Object Path Node to:\n\n   ```\n   $.name\n   ```\n\n3. Run the graph. The Extract Object Path Node should output the value `John Doe`.\n\n![Extract Object Path Node Example 1](./assets/extract-object-path-node-example-01.png)\n\n## Example 2: Extract properties from an array of objects\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   [\n     {\n       \"name\": \"John Doe\",\n       \"age\": 30\n     },\n     {\n       \"name\": \"Jane Doe\",\n       \"age\": 25\n     }\n   ]\n   ```\n\n2. Create an Extract Object Path Node and connect the Object Node to it. Set the `Path` of the Extract Object Path Node to:\n\n   ```\n    $[*].name\n   ```\n\n3. Run the graph. The Extract Object Path Node's `all_matches` output should have the value `John Doe` and `Jane Doe`. The `match` output contains the first match, which is `John Doe`.\n\n![Extract Object Path Node Example 2](./assets/extract-object-path-node-example-02.png)\n\n## Example 3: Extract a dynamic property from an object\n\n1. Create an [Object Node](./object.mdx) and set the value to the following:\n\n   ```json\n   {\n     \"name\": \"John Doe\",\n     \"age\": 30\n   }\n   ```\n\n2. Create a Text node and set the value to `age`.\n3. Create another Text node and set the value to `$.{{input}}`. Connect the first Text node to the second Text node.\n4. Create an Extract Object Path node and enable the input port for the `Path` setting. Connect the second Text node to the Extract Object Path node's `Path` input port. Connect the Object Node to the Extract Object Path node.\n5. Run the graph. Note that the path is constructed dynamicalled, and the `age` is extracted from the object.\n\n![Extract Object Path Node Example 3](./assets/extract-object-path-node-example-03.png)\n\n## Error Handling\n\nIf the path is invalid, the Extract Object Path Node will throw an error. If the path is valid, but the value is not found, the `match` output will not run, and the `all_matches` output will run with an empty array.\n\n## FAQs\n\n**Q: Does the Extract Object Path Node only work with objects?**\n\nA: No, it can also work with arrays and other JavaScript values that have properties, such as strings. For example, you can use `$.length` to get the length of a string.\n\n**Q: Can I split the Extract Object Path Node in order to execute a command on an array of objects?**\n\nA: It is recommended to simply use the `*` operator and the `All Matches` output, but there can be cases where splitting the node is appropriate. For example with an array of objects that themselves contain arrays, and you want to extract all sub-arrays, you can either to `$[*].someArray` or split the node and use `$.someArray` on the split node.\n\n**Q: Can I use the Extract Object Path Node to extract data from a JSON object returned by an API?**\n\nA: Yes, you can use the [HTTP Call Node](./http-call.mdx) to make an API request, and then use the Extract Object Path Node to extract data from the response.\n\n## See Also\n\n- [Code Node](./code.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [Object Node](./object.mdx)\n- [Array Node](./array.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n- [Data Types](../user-guide/data-types.md)\n"]},{"id":"YcdE_uYETm1wZeHdK2PBf","data":["extract-with-regex.mdx","---\nid: extract-with-regex\ntitle: Extract with Regex Node\nsidebar_label: Extract with Regex\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Extract with Regex Node Screenshot](./assets/extract-with-regex-node.png)\n\n## Overview\n\nThe Extract With Regex (or Extract Regex) node allows you to extract one or more strings from a string using a regular expression.\n\nEach capture group in the regular expression will correspond to an output port on the node, so the number of outputs will be equal to the number of capture groups in the regular expression.\n\nThe Extract With Regex node can be used for many cases such as parsing a response from an LLM to extract specific values, or parsing a string from a file to extract specific values.\n\nIf you do not have any capture groups in your regex, you can still use the `Matches`, `Succeeded`, and `Failed` outputs of the node to determine if the regex matched the input string.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                            | Default Value | Notes                                                                           |\n| ----- | --------- | -------------------------------------- | ------------- | ------------------------------------------------------------------------------- |\n| Input | `string`  | The string to match the regex against. | (required)    | If the value is not a string, it will be coerced into a string before matching. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title     | Data Type  | Description                                                                                                                     | Notes                                                  |\n| --------- | ---------- | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------ |\n| Output N  | `string`   | Output ports are created, one per capture group in the regular expression path. The value is the contents of the capture group. | Dynamic count based on the number of capture groups.   |\n| Matches   | `string[]` | All matches of the regular expression on the string, as an array.                                                               | Contains all matched strings, ignoring capture groups. |\n| Succeeded | `boolean`  | Outputs true if the regex was matched on the input string. Outputs false if it was node.                                        |                                                        |\n| Failed    | `boolean`  | Outputs true if the regex did not match the input string. Outputs false if it was matched.                                      |                                                        |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting         | Description                                                                                                                                                                                                                                        | Default Value                                     | Use Input Toggle | Input Data Type |\n| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- | ---------------- | --------------- |\n| Error on failed | If true, the Extract With Regex node will error entirely if the input string was not found. This is useful for required matches.                                                                                                                   | False                                             | No               | N/A             |\n| Multiline Mode  | If true, the [multiline flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline) is set on the regular expression, causing `^` and `$` to match the beginning and ends of lines within the string. | False                                             | No               | N/A             |\n| Regex           | The regular expression to use for matching against the input string.                                                                                                                                                                               | `([a-zA-Z]+)` (a string of alphabetic characters) | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract a command from an LLM response\n\n1. Create a [Chat Node](./chat.mdx) and pass a [Prompt Node](./text.mdx) set to `System` into its `prompt` input, with something like the following:\n   ```\n   Your reply can initiate commands, for example `!hello` will cause \"Hello world\" to appear for the user. Try it out now!\n   ```\n2. Feed the output of the Chat node into an Extract With Regex node with the following regular expression:\n   ```\n   !([a-zA-Z]+)\n   ```\n3. Feed the output of the `Output 1` port into another Text node to get the matched command. The output of the Text node should be `hello`.\n\n![Extract with Regex Example 1](./assets/extract-with-regex-node-example-01.png)\n\n## Error Handling\n\nIf the input string is not provided, the node will error. If the input is not a string, it will be coerced into a string before matching.\n\nIf the regular expression is invalid, the node will error.\n\nIf the `Error on failed` setting is enabled, the node will error if the regular expression did not match the input string.\n\n## FAQ\n\n**Q: How do I match a string that contains a special character?**\n\nSpecial characters such as a newline cannot be escaped in the regular expression editor, however you can put literal newlines in the regular expression in the editor, and they will be preserved. So to match a new line, put a new line in the regular expression editor.\n\n## See Also\n\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Match Node](./match.mdx)\n"]},{"id":"x1LwT8QjTa9rqySdX05nX","data":["match.mdx","---\nid: match\ntitle: Match Node\nsidebar_label: Match\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Match Node Screenshot](./assets/match-node.png)\n\n## Overview\n\nThe Match Node is used to match a string input against a series of regular expressions. Each regular expression corresponds to an output of the node.\n\nThe node can be configured to either run the _first_ matching output port, or to run _all_ matching output ports. If no match is found, the `Unmatched` output port will be executed.\n\nThis node is useful for routing control flow based on the content of a string. For example, you can use the Match Node to check if a user's message contains certain keywords and route the conversation accordingly.\n\nIf the `Value` input is provided, it will be passed through the corresponding output port if a match is found. If the `Value` input is not provided, the `Test` input will be passed through the corresponding output port if a match is found.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                    | Default Value | Notes                                                          |\n| ----- | --------- | -------------------------------------------------------------- | ------------- | -------------------------------------------------------------- |\n| Test  | `string`  | The string to be tested against the regular expressions.       | (required)    | The input will be coerced into a string if it is not a string. |\n| Value | `any`     | The value to be passed to the output port if a match is found. | (optional)    | If not provided, the `Test` input will be used as the value.   |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title     | Data Type | Description                                                                 | Notes                                                                                        |\n| --------- | --------- | --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- |\n| Case [i]  | `any`     | The output port corresponding to the ith regular expression.                | Dynamic number of outputs based on the number of regular expressions configured in the node. |\n| Unmatched | `any`     | The output port that is executed if no match is found for the input string. | If a match is found for the input string, this output port will not be executed.             |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting   | Description                                                                                                                                     | Default Value | Use Input Toggle | Input Data Type |\n| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Exclusive | If enabled, then the _first_ matched case will be ran, and all other cases will not be ran. If disabled, then _all_ matching cases will be ran. | Off           | No               | N/A             |\n| Cases     | The list of regular expression cases to match against.                                                                                          | `YES`, `NO`   | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Route control flow based on AI input\n\n1. Create a [Chat Node](./chat.mdx) and set the `Prompt` to a question, such as:\n   > Would you like to hear about information about cats or dogs first? Please only pick one! I will give you information on both, I just want to know what you'd like to hear first.\n2. Create a Match Node and connect the `Message` output of the Chat Node to the `Test` input of the Match Node.\n3. In the body of the Match Node, set the regular expressions to `cats` and `dogs`.\n4. Add three pairs of [If Nodes](./if.mdx) and [Text Nodes](./text.mdx). Connect the `Case 1` output of the Match Node to the first If Node's `If` input, the `Case 2` output of the Match Node to the second If Node's `If` input, and the `Unmatched` output of the Match Node to the third If Node's `If` input. Connect the text nodes to the If Nodes' `Value` inputs.\n5. The text of the three Text Nodes should be \"You chose cats!\", \"You chose dogs!\", and \"Sorry, I didn't understand that. Please try again.\", respectively.\n6. Run the graph. Depending on the AI's response, the corresponding If Node will be executed, with the text the AI selected\n\n![Match Node Example 1](./assets/match-node-example-01.png)\n\n## Error Handling\n\nThe Match Node will error if the `Test` input is not provided. If no match is found for the input string, the `Unmatched` output port will be executed.\n\n## FAQ\n\n**Q: Can multiple cases match at once?**\n\nA: Yes, multiple cases can match at once. If multiple cases match, all of the corresponding output ports will be executed. This may become a toggleable option in the future, so that only the first matching case will be executed.\n\n**Q: Can I use the Match Node to match against numbers?**\n\nA: Yes, you can use the Match Node to match against numbers. However, the `Test` input will be coerced into a string for the matching.\n\n**Q: Can I use the Match Node to match against a list of strings?**\n\nA: Yes, you can use the Match Node to match against a list of strings. However, the `Test` input will be coerced into a string for the matching. The default coercion will put each string on its own line for testing against.\n\n## See Also\n\n- [If Node](./if.mdx)\n- [If/Else Node](./if-else.mdx)\n- [Loop Controller Node](./loop-controller.mdx)\n- [Coalesce Node](./coalesce.mdx)\n- [Control Flow](../user-guide/control-flow.md)\n"]},{"id":"TbdNkqoNEzpzjN2qzJ64m","data":["audio.mdx","---\nid: audio\ntitle: Audio Node\nsidebar_label: Audio\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Audio Node Screenshot](./assets/audio-node.png)\n\n## Overview\n\nThe Audio Node is used to define an audio sample for use with other nodes. It can also convert a binary type into an audio type.\n\nThe Audio Node can either take an input that represents the audio data or use an audio file specified in the node's settings. The audio data should be in a format that can be converted to a Uint8Array.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                             | Default Value | Notes                                                                                                             |\n| ----- | --------- | --------------------------------------- | ------------- | ----------------------------------------------------------------------------------------------------------------- |\n| Data  | `string`  | The string representing the audio data. | N/A           | This input is only available if the \"Use Data Input\" setting is enabled. The input will be coerced into a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type | Description                                                                                             | Notes |\n| ---------- | --------- | ------------------------------------------------------------------------------------------------------- | ----- |\n| Audio Data | `audio`   | The audio data converted into a format that can be used by other nodes that accept audio data as input. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting        | Description                                                                                                                                                                             | Default Value | Use Input Toggle | Input Data Type |\n| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Audio File     | The audio file to be used as the audio data. This file should be in a format that can be converted to a Uint8Array.                                                                     | N/A           | Yes              | `file`          |\n| Use Data Input | If enabled, the node will use the data from the \"Data\" input port as the audio data. If disabled, the node will use the data from the audio file specified in the \"Audio File\" setting. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Using an Audio Node with a File\n\n1. Add an Audio Node to your graph.\n2. In the node's settings, click \"Pick File\" and select an audio file from your local file system.\n3. Play the audio back using the player on the Audio node. You may also connect the Audio node to other nodes that accept Audio data, such as the [AssemblyAI Plugin](../user-guide/plugins/built-in/assemblyai.md)\n\n## Error Handling\n\nThe Audio Node will throw an error if:\n\n- The \"Use Data Input\" setting is enabled but no data is provided to the \"Data\" input port.\n- The \"Use Data Input\" setting is disabled but no audio file is specified in the \"Audio File\" setting.\n- The provided audio data (either from the \"Data\" input or the specified audio file) cannot be converted to a Uint8Array.\n\n## FAQ\n\n**Q: What audio file formats are supported by the Audio Node?**\n\nA: The Audio Node does not process the audio data itself, so it does not have any specific audio file format requirements. However, the audio data should be in a format that can be converted to a Uint8Array. The specific audio file formats that can be used will depend on what other nodes you are connecting the Audio Node to.\n\n**Q: Can I use the Audio Node to play audio?**\n\nA: The Audio Node shows a playback bar on the Rivet UI, but otherwise, it cannot be used to play back audio during the graph's execution.\n\n## See Also\n\n- [Image Node](./image.mdx)\n- [Text Node](./text.mdx)\n- [Number Node](./number.mdx)\n- [Bool Node](./bool.mdx)\n- [External Call Node](./external-call.mdx)\n"]},{"id":"Pqi9mWIDufdi_cejHA17w","data":["pop.mdx","---\nid: pop\ntitle: Pop Node\nsidebar_label: Pop\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Pop Node Screenshot](./assets/pop-node.png)\n\n## Overview\n\nThe Pop Node is used to remove either the first or last element from an array and output both the removed element and the remaining array. By default, the Pop Node will pop the last element from the array.\n\nThis node is useful when you want to process elements of an array one by one in a loop.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description           | Default Value | Notes                                                          |\n| ----- | --------- | --------------------- | ------------- | -------------------------------------------------------------- |\n| Array | `any[]`   | The array to pop from | (required)    | The input will be coerced into an array if it is not an array. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                                                                         | Notes |\n| ----- | --------- | ----------------------------------------------------------------------------------- | ----- |\n| Last  | `any`     | The last element of the array, or the first element if \"Pop from front\" is enabled. |       |\n| Rest  | `any[]`   | The remaining elements of the array after the last element is popped.               |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting        | Description                                                                    | Default Value | Use Input Toggle | Input Data Type |\n| -------------- | ------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Pop from front | If enabled, the first element of the array will be popped instead of the last. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Pop the last element from an array\n\n1. Create an [Array Node](./array.mdx) and set the values to `[\"John\", \"Doe\", \"30\", \"Engineer\"]`.\n2. Create a Pop Node and connect the Array Node to its `Array` input.\n3. Run the graph. The `Last` output of the Pop Node should be `\"Engineer\"` and the `Rest` output should be `[\"John\", \"Doe\", \"30\"]`.\n\n![Pop Node Example 1](./assets/pop-node-example-01.png)\n\n## Example 2: Pop the first element from an array\n\n1. Create an [Array Node](./array.mdx) and set the values to `[\"John\", \"Doe\", \"30\", \"Engineer\"]`.\n2. Create a Pop Node, enable the `Pop from front` setting, and connect the Array Node to its `Array` input.\n3. Run the graph. The `Last` output of the Pop Node should be `\"John\"` and the `Rest` output should be `[\"Doe\", \"30\", \"Engineer\"]`.\n\n![Pop Node Example 2](./assets/pop-node-example-02.png)\n\n## Error Handling\n\nThe Pop Node will error if the `Array` input is not provided, is not an array, or is an empty array.\n\n## FAQ\n\n**Q: Can I pop multiple elements from an array at once?**\n\nA: No, the Pop Node can only pop one element at a time. If you want to remove multiple elements from an array, you can use multiple Pop Nodes in a sequence.\n\n**Q: Can I use the Pop Node to pop elements from a string?**\n\nA: No, the Pop Node only works with arrays. If you want to remove characters from a string, you can use a [Code Node](./code.mdx) with custom JavaScript code.\n\n**Q: What if the array is empty?**\n\nA: The Pop Node will error if the array is empty. You can use an [If Node](./if.mdx) to check if the array is empty before popping from it.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Slice Node](./slice.mdx)\n- [Code Node](./code.mdx)\n- [Loop Controller Node](./loop-controller.mdx)\n"]},{"id":"7bZebvmGV5ripwbMNi_R7","data":["chunk.mdx","---\nid: chunk\ntitle: Chunk Node\nsidebar_label: Chunk\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Chunk node is used to split a string into an array of strings based on a token count.\n\nChunking a string is useful to avoid hitting token count limited in LLMs. You can split a string into multiple chunks and then feed each chunk into a separate Chat node, then combine the outputs of the chat nodes back together to effectively answer questions\nabout strings of text longer than the LLM can handle.\n\nThe Chunk node can also be used to truncate a string to a certain token count, from the beginning or the end, by using the `first` or `last` outputs.\n\nIf an overlap percentage is specified, then the chunks will overlap by the specified percentage (relative to the max token count). For example, if the max token count is 100 and the overlap is 50%, then the chunks will overlap by 50 tokens. This can be useful so that context is not lost between chunks, but it may result in more total chunks.\n\n![Chunk Node Screenshot](./assets/chunk-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                        | Default Value | Notes |\n| ----- | --------- | ---------------------------------- | ------------- | ----- |\n| Input | `string`  | The string that should be chunked. | (Required)    | None  |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type  | Description                                                                               | Notes                                                                            |\n| ------- | ---------- | ----------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\n| Chunks  | `string[]` | The array of string chunks after splitting the string by the configured amount of tokens. | May be an array of length 1 if the string did not need to be split.              |\n| First   | `string`   | The first chunk in the chunks array.                                                      | Useful for truncating a string to a specified token count.                       |\n| Last    | `string`   | The last chunk in the chunks array.                                                       | Useful for truncating a string from the start to a specified token count.        |\n| Indexes | `number[]` | A list of the indexes of the chunks.                                                      | Useful when filtering or zipping the chunks array, and other more complex tasks. |\n| Count   | `number`   | The number of chunks in the chunks array.                                                 | Has many uses for more complex tasks.                                            |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting    | Description                                                                               | Default Value | Use Input Toggle | Input Data Type |\n| ---------- | ----------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Model      | The model to use for tokenizing. Different LLMs use different tokenizers.                 | gpt-3.5-turbo | Yes              | `string`        |\n| Max Tokens | The maximum number of tokens in the chunk.                                                | 1024          | Yes              | `number`        |\n| Overlap    | The amount of overlap (0-100% as 0-1) between chunks, as a factor of the max token count. | 0             | Yes              | `number`        |\n\n</TabItem>\n\n</Tabs>\n\n### Example 1: Chunk a string into multiple chunks\n\n1. Create a text node with some long data, such as lorem ipsum.\n2. Create a Chunk node and connect the text node to the input. Set the max tokens to something small like 100.\n3. Run the graph. Note how the output of the chunk node has split the text (visually as new lines) into multiple chunks.\n\n## Error Handling\n\nThe chunk node has no notable error handling behavior. If the input is not a string, then it will be coerced into a string.\n\n## FAQ\n\n## See Also\n\n- [Splitting](../user-guide/splitting.md)\n- [Chat Node](./chat.mdx)\n- [Text Node](./text.mdx)\n- [Trim Chat Messages Node](./trim-chat-messages.mdx)\n"]},{"id":"UuKs86zKS7Axde6CKxe1w","data":["filter.mdx","---\nid: filter\ntitle: Filter Node\nsidebar_label: Filter\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Filter Node Screenshot](./assets/filter-node.png)\n\n## Overview\n\nThe Filter Node is used to filter an array based on a corresponding array of boolean values. The node takes in an array of any data type and an array of boolean values of the same length. It then filters the array, only including the elements where the corresponding boolean value is `true`.\n\nThis node is particularly useful when you want to filter an array based on some condition. For example, you could use a split (see [Splitting](../user-guide/splitting.md)) [Compare Node](./compare.mdx) to compare each element in an array to a value, and then use the Filter Node to filter the array based on the results of the comparison.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title   | Data Type   | Description                                                                         | Default Value | Notes                                                                                                                                             |\n| ------- | ----------- | ----------------------------------------------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Array   | `any[]`     | The array to be filtered.                                                           | (required)    | The input will be coerced into an array if it is not an array.                                                                                    |\n| Include | `boolean[]` | An array of boolean values indicating whether to include each element in the array. | (required)    | The input will be coerced into a boolean array if it is not a boolean array. The length of this array should match the length of the Array input. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                                                                                             | Notes                                                                                                                                           |\n| -------- | --------- | ----------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| Filtered | `any[]`   | The filtered array, containing only the elements where the corresponding boolean value in the Include input was `true`. | The output will be an array of the same data type as the Array input. If the Array input is not an array, the output will be an array of `any`. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Filter an array of numbers\n\n1. Create an [Array Node](./array.mdx) and set the values to `[1, 2, 3, 4, 5]`.\n2. Create another Array Node and set the values to `[true, false, true, false, true]`.\n3. Create a Filter Node and connect the first Array Node to the `Array` input and the second Array Node to the `Include` input.\n4. Run the graph. The `Filtered` output of the Filter Node should be `[1, 3, 5]`.\n\n![Filter Node Example 1](./assets/filter-node-example-01.png)\n\n## Example 2: Filter an array based on a condition\n\n1. Create an [Array Node](./array.mdx) and set the values to `[1, 2, 3, 4, 5]`.\n2. Create a [Compare Node](./compare.mdx) and set the comparison to `>`. Enable splitting on the Compare node.\n3. Create a [Number Node](./number.mdx) and set the value to `3`.\n4. Connect the Array Node to the `A` input of the Compare Node, and connect the Number Node to the `B` input of the Compare Node.\n5. Create a Filter Node and connect the Compare Node to the `Array` input and the `Result` output of the Compare Node to the `Include` input.\n6. Run the graph. The `Filtered` output of the Filter Node should be `[4, 5]`.\n\n![Filter Node Example 2](./assets/filter-node-example-02.png)\n\n## Error Handling\n\nThe Filter Node will error if the `Array` or `Include` inputs are not provided, or if the lengths of the arrays do not match.\n\n## FAQ\n\n**Q: What happens if the lengths of the Array and Include inputs do not match?**\n\nA: The Filter Node will error. The lengths of the Array and Include inputs should always match.\n\n**Q: Can I use the Filter Node to filter an array of objects?**\n\nA: Yes, you can use the Filter Node to filter an array of any data type, including objects. Just make sure to provide an array of boolean values indicating whether to include each object in the filtered array.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Compare Node](./compare.mdx)\n- [Number Node](./number.mdx)\n- [Splitting](../user-guide/splitting.md)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Evaluate Node](./evaluate.mdx)\n- [Coalesce Node](./coalesce.mdx)\n- [Join Node](./join.mdx)\n"]},{"id":"dwhLex4JTfAT4xj4iwllx","data":["comment.mdx","---\nid: comment\ntitle: Comment Node\nsidebar_label: Comment\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Comment Node Screenshot](./assets/comment-node.png)\n\n## Overview\n\nThe Comment Node is a special type of node that doesn't perform any operations but serves as a way to add notes or comments to a graph. It can be used to provide additional context or explanation for a group of nodes, making the graph easier to understand. The Comment Node is always rendered behind other nodes and has a distinct appearance with customizable colors.\n\nA comment node is always rendered behind all other nodes in the graph.\n\n<Tabs\n  defaultValue=\"settings\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\nThe Comment Node does not have any inputs.\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\nThe Comment Node does not produce any outputs.\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting          | Description                                                                                                                       | Default Value         |\n| ---------------- | --------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\n| Color            | The color of the text in the comment node.                                                                                        | `rgba(255,255,255,1)` |\n| Background Color | The background color of the comment node.                                                                                         | `rgba(0,0,0,0.05)`    |\n| Text             | The text content of the comment node. Supports Markdown syntax, allowing for rich text formatting including headings, lists, etc. | (Empty)               |\n\n</TabItem>\n\n</Tabs>\n\n## Example Usage\n\nThe Comment Node can be used to add notes or comments to a graph. For example, if you have a group of nodes performing a specific operation, you can add a Comment Node behind them to provide a brief explanation of what they do.\n\nAdditionally, you can use different colors for the text and background of different Comment Nodes to visually distinguish between different sections of your graph.\n\n## See Also\n\n- [Markdown Guide](https://www.markdownguide.org/)\n"]},{"id":"F7GUI0jrIZcl4-tn7mM_2","data":["get-global.mdx","---\nid: get-global\ntitle: Get Global Node\nsidebar_label: Get Global\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Get Global Node Screenshot](./assets/get-global-node.png)\n\n## Overview\n\nThe Get Global Node is used to retrieve a global value that is shared across all graphs and subgraphs. The ID of the global value is configured in this node.\n\nThe node can be configured to retrieve the value on demand, which means it will be read when nodes need it, rather than when this node executes. This is useful when the global value might change during the execution of the graph.\n\nThe node can also be configured to wait until the variable is available. This is useful when the global value is set by another node that might not have completed its execution when this node runs.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type | Description                                                                                                   | Default Value | Notes                                                          |\n| ----------- | --------- | ------------------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------- |\n| Variable ID | `string`  | The ID of the global variable to retrieve. This input is only available if the \"Use Input\" toggle is checked. | N/A           | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                       | Notes                                                                                 |\n| ----- | --------- | --------------------------------- | ------------------------------------------------------------------------------------- |\n| Value | (any)     | The value of the global variable. | The data type of the output will be the same as the data type of the global variable. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting     | Description                                                                                                                       | Default Value | Use Input Toggle | Input Data Type |\n| ----------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Variable ID | The ID of the global variable to retrieve.                                                                                        | (required)    | Yes              | `string`        |\n| Data Type   | The data type of the global variable.                                                                                             | `string`      | No               | N/A             |\n| On Demand   | If enabled, the global variable will be read when nodes need it, rather than when this node executes. Cannot be used with \"Wait\". | True          | No               | N/A             |\n| Wait        | If enabled, the node will wait until the variable is available. Cannot be used with \"On Demand\".                                  | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Retrieve a global variable\n\n1. Add a [Set Global Node](./set-global.mdx) to the graph. Set the variable name to `myGlobalVariable` and the value to `Hello World` using a [Text Node](./text.mdx).\n2. In a separate part of the graph, add a [Delay Node](./delay.mdx) and set the delay to `1000` (1 second).\n3. Create a [Text Node](./text.mdx) and set the text to `myGlobalVariable`. Pass the text into the Delay Node.\n4. Create a Get Global Node, enable the input for \"Variable Name\", and pass the output of the Delay Node into the input. Disable the \"On Demand\" setting.\n\n![Get Global Node Example 1](./assets/get-global-node-example-01.png)\n\n## Example 2: Retrieve a global variable on-demand\n\n1. Add a [Set Global Node](./set-global.mdx) to the graph. Set the variable name to `myGlobalVariable` and the value to `Hello World` using a [Text Node](./text.mdx).\n2. Add a Get Global Node and set the variable name to `myGlobalVariable`. Enable the \"On Demand\" setting.\n3. Add an [If Node](./if.mdx). Set the `If` input to the Set Global Node, and set the `Value` input to the Get Global Node. This will wait for both nodes to complete before running, and will pass the Get Global Node's value through to the next node.\n4. Add a Text Node and connect the If Node to the Text Node.\n5. Run the graph. Notice that the value of the If node is `Function<string>` because the \"On-Demand\" setting has been enabled, causing the value to not have resolved yet. The value is resolved in the Text Node, and \"Hello World\" is displayed.\n\n![Get Global Node Example 2](./assets/get-global-node-example-02.png)\n\n## Error Handling\n\nThe Get Global Node will error if the global variable is not found and the `Wait` setting is disabled. If the `Wait` setting is enabled, the node will wait until the variable is available.\n\n## FAQ\n\n**Q: What is a global variable?**\n\nA: A global variable is a value that is shared across all graphs and subgraphs. It is set using a [Set Global Node](./set-global.mdx) and retrieved using a Get Global Node.\n\n**Q: Can I set a global variable from a parent application?**\n\nA: No, global variables can only be set from within the graph. Use a [Context Node](./context.mdx) instead to access global variables set by the parent application.\n\n**Q: What happens if the global variable is not found?**\n\nA: If the global variable is not found and the `Wait` setting is disabled, the Get Global Node will return the default value for the data type selected. For example, if the data type is set to `string`, the default value will be an empty string. If the `Wait` setting is enabled, the node will wait until the variable is available before returning the value.\n\n## See Also\n\n- [Set Global Node](./set-global.mdx)\n- [Context Node](./context.mdx)\n- [External Call Node](./external-call.mdx)\n- [Raise Event Node](./raise-event.mdx)\n"]},{"id":"QP1Ml12hiKSae6liSpbGe","data":["vector-knn.mdx","---\nid: vector-knn\ntitle: Vector K-Nearest Neighbors Node\nsidebar_label: Vector KNN\n---\n\n# Vector Nearest Neighbors Node\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nThe Vector KNN Node takes a vector embedding and searches for K similar vectors.\n\n![Chat Node Screenshot](./assets/vector-knn-node.png)\n\n## Overview\n\nThe Vector K-Nearest Neighbors (KNN) Node is used to perform a k-nearest neighbors search on vectors stored in a configured vector database integration. It takes in a vector and returns the k closest vectors and their corresponding data.\n\nThis node is useful when working with vector databases such as Pinecone, where you might want to find the vectors in the database that are most similar to a given input vector.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title         | Data Type | Description                                                                          | Default Value | Notes                                                                         |\n| ------------- | --------- | ------------------------------------------------------------------------------------ | ------------- | ----------------------------------------------------------------------------- |\n| Vector        | `vector`  | The vector to find the nearest neighbors for.                                        | (required)    | The input will be coerced into a vector if it is not a vector.                |\n| Integration   | `string`  | The name of the vector database integration to use.                                  | (optional)    | Only required if `Use Integration Input` is enabled in the editor settings.   |\n| K             | `number`  | The number of nearest neighbors to find.                                             | (optional)    | Only required if `Use K Input` is enabled in the editor settings.             |\n| Collection ID | `string`  | The ID of the collection in the vector database to search for the nearest neighbors. | (optional)    | Only required if `Use Collection ID Input` is enabled in the editor settings. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type | Description                                                                       | Notes                                            |\n| ------- | --------- | --------------------------------------------------------------------------------- | ------------------------------------------------ |\n| Results | `any[]`   | The k nearest neighbors to the input vector, along with their corresponding data. | If the value is not found, this port is not ran. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                                          | Default Value | Use Input Toggle | Input Data Type |\n| ------------- | ------------------------------------------------------------------------------------ | ------------- | ---------------- | --------------- |\n| Integration   | The name of the vector database integration to use.                                  | (empty)       | Yes              | `string`        |\n| K             | The number of nearest neighbors to find.                                             | 10            | Yes              | `number`        |\n| Collection ID | The ID of the collection in the vector database to search for the nearest neighbors. | (empty)       | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Find the nearest neighbors of a vector in a Pinecone database\n\n1. Create a [Text Node](./text.mdx) with the text you want to search for nearest neighbors of.\n2. Connect the Text Node to a [Get Embedding Node](./get-embedding) to convert the text into a vector.\n3. Create a Vector KNN Node and connect the Vector Node to its `Vector` input. Set the `Integration` to `pinecone`, the `K` to `10`, and the `Collection ID` to the ID of your Pinecone collection.\n4. Run the graph. The Vector KNN Node should output the 10 nearest neighbors to the input vector in the Pinecone collection.\n\n![Vector KNN Node Example 1](./assets/vector-knn-node-example-01.png)\n\n## Error Handling\n\nThe Vector KNN Node will throw an error if the input vector is not a vector, or if the specified vector database integration is not found. If the specified collection ID is not found in the vector database, the node will return an empty array.\n\n## FAQ\n\n**Q: Can I use the Vector KNN Node with other vector database integrations?**\n\nA: Yes, you can use the Vector KNN Node with any vector database integration supported by Rivet, such as Pinecone. You just need to specify the name of the integration in the `Integration` setting of the node.\n\n**Q: Can I find the nearest neighbors of multiple vectors at once?**\n\nA: No, the Vector KNN Node can only find the nearest neighbors of a single vector at a time. If you want to find the nearest neighbors of multiple vectors, you would need to use multiple Vector KNN Nodes, one for each vector.\n\n## See Also\n\n- [Pinecone](../user-guide/plugins/built-in/pinecone.md)\n"]},{"id":"BUwoes0EQi-lDZHCo9_8m","data":["extract-markdown-code-blocks.mdx","---\nid: extract-markdown-code-blocks\ntitle: Extract Markdown Code Blocks Node\nsidebar_label: Extract Markdown Code Blocks\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Extract Markdown Code Blocks Node Screenshot](./assets/extract-markdown-code-blocks-node.png)\n\n## Overview\n\nThe Extract Markdown Code Blocks Node is used to extract code blocks from a Markdown text. It extracts all code blocks and the specified languages for each block. The node outputs the first matched block, all matched blocks, and the languages specified for the blocks.\n\nA markdown code block is defined as a code block that is surrounded by three backticks on each side. For example:\n\n````markdown\nHere is some JavaScript code:\n\n```javascript\nconsole.log('Hello, world!');\n```\n````\n\nThis node is useful when working with LLMs that have been trained extensively on replying with markdown data.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                         | Default Value | Notes                                                         |\n| ----- | --------- | --------------------------------------------------- | ------------- | ------------------------------------------------------------- |\n| Input | `string`  | The Markdown text from which to extract code blocks | (required)    | The input will be coerced into a string if it is not a string |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title       | Data Type  | Description                                                                                      | Notes                                                                                                        |\n| ----------- | ---------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------ |\n| First Block | `string`   | The first code block found in the input Markdown text                                            | If no code block is found, this output will not be ran                                                       |\n| All Blocks  | `string[]` | All code blocks found in the input Markdown text                                                 | If no code block is found, this output will be an empty array                                                |\n| Languages   | `string[]` | The languages specified for each code block in the input Markdown text, in the order they appear | If no language is specified for a code block, the corresponding element in the array will be an empty string |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Extract code blocks from a Markdown text\n\n1. Create a [Text Node](./text.mdx) and set the text to the following Markdown text:\n\n   ````markdown\n   Here is some JavaScript code:\n\n   ```javascript\n   console.log('Hello, world!');\n   ```\n\n   And here is some Python code:\n\n   ```python\n   print('Hello, world!')\n   ```\n\n   That's it!\n   ````\n\n2. Create an Extract Markdown Code Blocks Node and connect the Text Node to its `Input` input.\n3. Run the graph. The `First Block` output of the Extract Markdown Code Blocks Node should be `console.log('Hello, world!');`, the `All Blocks` output should be an array containing `console.log('Hello, world!');` and `print('Hello, world!')`, and the `Languages` output should be an array containing `javascript` and `python`.\n\n![Extract Markdown Code Blocks Node Example 1](./assets/extract-markdown-code-blocks-node-example-01.png)\n\n## Error Handling\n\nThe Extract Markdown Code Blocks Node will not error under normal circumstances. If the input text does not contain any code blocks, the `First Block` output will not be ran, and the `All Blocks` and `Languages` outputs will be empty arrays.\n\n## FAQ\n\n**Q: What happens if a code block does not specify a language?**\n\nA: The corresponding element in the `Languages` output array will be an empty string.\n\n**Q: What happens if the input text contains non-Markdown text?**\n\nA: The node will ignore any non-Markdown text and only extract code blocks. If the input text does not contain any code blocks, the `First Block` output will not be ran, and the `All Blocks` and `Languages` outputs will be empty arrays.\n\n## See Also\n\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Extract with Regex Node](./extract-with-regex.mdx)\n- [Text Node](./text.mdx)\n- [Split Text Node](./split-text.mdx)\n\n```\n\n```\n"]},{"id":"d4EzeRtHgb6uZ6STsh86M","data":["shuffle.mdx","---\nid: shuffle\ntitle: Shuffle Node\nsidebar_label: Shuffle\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Shuffle Node Screenshot](./assets/shuffle-node.png)\n\n## Overview\n\nThe Shuffle Node is used to randomize the order of elements in an array. It takes an array as input and outputs a new array with the elements in a shuffled order.\n\nThe Shuffle Node uses the [Fisher-Yates (aka Knuth) shuffle algorithm](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) to ensure a fair distribution of permutations.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description           | Default Value | Notes |\n| ----- | --------- | --------------------- | ------------- | ----- |\n| Array | `any[]`   | The array to shuffle. | (required)    | None  |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title    | Data Type | Description                                | Notes |\n| -------- | --------- | ------------------------------------------ | ----- |\n| Shuffled | `any[]`   | The input array with its order randomized. | None  |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Shuffle an array of numbers\n\n1. Create an [Array Node](./array.mdx) and set the values to `[1, 2, 3, 4, 5]`.\n2. Create a Shuffle Node and connect the Array Node to its `Array` input.\n3. Run the graph. The `Shuffled` output of the Shuffle Node should contain the numbers 1 through 5 in a random order.\n\n![Shuffle Node Example 1](./assets/shuffle-node-example-01.png)\n\n## Error Handling\n\nThe Shuffle Node will error if the `Array` input is not provided or is not an array.\n\n## FAQ\n\n**Q: Can I shuffle an array of objects?**\n\nA: Yes, the Shuffle Node can shuffle arrays of any data type, including objects.\n\n**Q: Does the Shuffle Node modify the original array?**\n\nA: No, the Shuffle Node does not modify the original array. It creates a new array with the elements in a shuffled order.\n\n**Q: Is the shuffle algorithm truly random?**\n\nA: The Shuffle Node uses the Fisher-Yates (aka Knuth) shuffle algorithm, which is considered a fair shuffle algorithm. However, it relies on the JavaScript `Math.random()` function, which is not suitable for cryptographic purposes.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Filter Node](./filter.mdx)\n- [Join Node](./join.mdx)\n- [Code Node](./code.mdx)\n- [RNG Node](./rng.mdx)\n"]},{"id":"X1brTAjA3SrWpauq5PPZq","data":["rng.mdx","---\nid: RNG\ntitle: RNG Node\nsidebar_label: RNG\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Random Number Node Screenshot](./assets/rng-node.png)\n\n## Overview\n\nThe Random Number Node, also known as RNG, generates a random number within a specified range. This node is useful for creating randomized behavior in your graph.\n\nThe node can be configured to generate either integers or floating-point numbers. The range of the random number can be specified with a minimum and maximum value. The maximum value can be set to be either inclusive or exclusive.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                                                                | Default Value | Notes                                                          |\n| ----- | --------- | -------------------------------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------- |\n| Min   | `number`  | The minimum value of the random number. This input is only available if `Use Min Input` is enabled in the editor settings. | (optional)    | The input will be coerced into a number if it is not a number. |\n| Max   | `number`  | The maximum value of the random number. This input is only available if `Use Max Input` is enabled in the editor settings. | (optional)    | The input will be coerced into a number if it is not a number. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description                  | Notes |\n| ----- | --------- | ---------------------------- | ----- |\n| Value | `number`  | The generated random number. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                                                                     | Default Value | Use Input Toggle | Input Data Type |\n| ------------- | --------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Min           | The minimum value of the random number.                                                                         | 0             | Yes              | `number`        |\n| Max           | The maximum value of the random number.                                                                         | 1             | Yes              | `number`        |\n| Integers      | If enabled, the node will generate integer numbers. If disabled, the node will generate floating-point numbers. | False         | No               | N/A             |\n| Max Inclusive | If enabled, the maximum value will be inclusive. If disabled, the maximum value will be exclusive.              | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Generate a random integer\n\n1. Create a Random Number Node.\n2. Set the `Min` to `1` and the `Max` to `10`.\n3. Enable the `Integers` setting.\n4. Run the graph. The output of the Random Number Node should be a random integer between 1 and 10.\n\n![Random Number Node Example 1](./assets/rng-node-example-01.png)\n\n## Example 2: Generate a random floating-point number\n\n1. Create a Random Number Node.\n2. Set the `Min` to `0` and the `Max` to `1`.\n3. Disable the `Integers` setting.\n4. Run the graph. The output of the Random Number Node should be a random floating-point number between 0 and 1.\n\n![Random Number Node Example 2](./assets/rng-node-example-02.png)\n\n## Error Handling\n\nThe Random Number Node will error if the `Min` is greater than the `Max`. If the `Min` and `Max` are equal, the node will always output the `Min` value.\n\n## FAQ\n\n**Q: Can I use the Random Number Node to generate a random boolean value?**\n\nA: Yes, you can use the Random Number Node to generate a random boolean value by setting the `Min` to `0`, the `Max` to `1`, and enabling the `Integers` setting. The node will then output either `0` or `1`, which can be interpreted as `false` and `true` by a [Bool Node](./bool.mdx).\n\n**Q: Can I use the Random Number Node to generate a random string?**\n\nA: No, the Random Number Node can only generate random numbers. If you want to generate a random string, you can use a [Code Node](./code.mdx) with a custom JavaScript function.\n\n## See Also\n\n- [Code Node](./code.mdx)\n- [Number Node](./number.mdx)\n- [Text Node](./text.mdx)\n- [Shuffle Node](./shuffle.mdx)\n"]},{"id":"CDIhExeVKPC6eYDwSwqOG","data":["context.mdx","---\nid: context\ntitle: Context Node\nsidebar_label: Context\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Context Node Screenshot](./assets/context-node.png)\n\n## Overview\n\nThe \"Context\" in Rivet is a set of shared inputs that are accessible in any graph, no matter if they are the entry-point graph, or a subgraph called by another graph. The Context node is used to access these inputs.\n\nThe Context Node allows you to access these values in your graph. It is useful for \"global values\" that every graph can access, without having to pipe the values in as graph inputs. Use the Context Node and `contextValues` to pass in \"global context\" to your projects, such as the current date.\n\nContext can currently only be set when Rivet is embedded in a host application. It is passed in using the `contextValues` parameter to `runGraphInFile` or `createProcessor`:\n\n```ts\nimport * as Rivet from '@ironclad/rivet-node';\n\nconst contextValues = {\n  stringContext: 'str',\n  numberContext: 1,\n  booleanContext: true,\n};\n\nconst processor = Rivet.createProcessor({\n  ...etc,\n  contextValues,\n});\n```\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\nThe context node has no inputs besides optional ones from the Editor Settings page.\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title        | Data Type              | Description                     | Notes                                                                                                                                                                                                                |\n| ------------ | ---------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| (Context ID) | (Configured in editor) | The value of the context value. | The ID and data type are configured in the Editor Settings page of the Context node. If the context value is not set, then the default value configured in the editor settings, or via the input port, will be used. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                                                                                         | Default Value | Use Input Toggle | Input Data Type                                                                                    |\n| ------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | -------------------------------------------------------------------------------------------------- |\n| ID            | The ID of the context that you are pulling in. Must match exactly to the ID passed in to `contextValues` in the parent application. | (required)    | No               | N/A                                                                                                |\n| Data Type     | The data type of the value passed in to `contextValues`. The value will be coerced to this data type if it does not match.          | String        | No               | N/A                                                                                                |\n| Default Value | The default value, if the context value is not set.                                                                                 | (empty)       | Yes              | Same data type as the configured `Data Type` above. Will be coerced into the data type configured. |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Access a string context value\n\nIn your parent application, pass a string value into `contextValues`:\n\n```ts\nimport * as Rivet from '@ironclad/rivet-node';\n\nconst contextValues = {\n  stringContext: 'str',\n};\n\nconst processor = Rivet.createProcessor({\n  ...etc,\n  contextValues,\n});\n```\n\nIn your graph, add a Context node. Set the `ID` to `stringContext`, and the `Data Type` to `String`. Leave the `Default Value` empty.\n\nRun your graph while the [Remote Debugger](../user-guide/remote-debugging.md) is attached. The output of the Context node should be `str`.\n\n## Error Handling\n\nThe context node cannot error in normal circumstances. If the context is not set via `contextValues`, then the default value will be used.\n\n## FAQ\n\n**Q: Can I use the Context node to pass in the current date and time?**\n\nA: Yes, you can pass in the current date as a context value:\n\n```ts\nconst processor = Rivet.createProcessor({\n  ...etc,\n  contextValues: {\n    currentDate: new Date(),\n  },\n});\n```\n\nThen, in your graph, add a Context node. Set the `ID` to `currentDate`, and the `Data Type` to `Date`. Leave the `Default Value` empty.\n\n**Q: Can I use the Context node to pass in a function?**\n\nA: No, you cannot pass in a function as a context value. You can only pass in [Data Values](../user-guide/data-types.md)\n\n**Q: Can I use the Context node to pass in a custom data type?**\n\nA: No, you cannot pass in a custom data type as a context value. You can only pass in [Data Values](../user-guide/data-types.md)\n\n## See Also\n"]},{"id":"VslVOUxmcBBaoZJE4I5aa","data":["get-embedding.mdx","---\nid: get-embedding\ntitle: Get Embedding Node\nsidebar_label: Get Embedding\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Get Embedding Node Screenshot](./assets/get-embedding-node.png)\n\n## Overview\n\nThe Get Embedding Node is used to generate a vector embedding for a given input text. This node is particularly useful when you want to convert text into a numerical representation that can K-nearest neighbor search, and more.\n\nThe node requires an integration to be available in the context when the graph is being run. The integration is responsible for generating the embedding. Currently, the only supported integration is OpenAI. However, when running Rivet in a parent application, you can register custom integrations.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title       | Data Type | Description                                                      | Default Value                                             | Notes                                                          |\n| ----------- | --------- | ---------------------------------------------------------------- | --------------------------------------------------------- | -------------------------------------------------------------- |\n| Input       | `string`  | The text for which the embedding should be generated.            | (required)                                                | The input will be coerced into a string if it is not a string. |\n| Integration | `string`  | The name of the integration to use for generating the embedding. | (required if the input toggle for Integration is enabled) | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title     | Data Type | Description                                        | Notes                                                                                  |\n| --------- | --------- | -------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| Embedding | `vector`  | The vector embedding generated for the input text. | The output will be a vector containing the numerical representation of the input text. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting     | Description                                                      | Default Value | Use Input Toggle | Input Data Type |\n| ----------- | ---------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Integration | The name of the integration to use for generating the embedding. | `openai`      | Yes              | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Generate an embedding for a text\n\n1. Create a [Text Node](./text.mdx) and set the text to `\"Hello, world!\"`.\n2. Create a Get Embedding Node and connect the Text Node to its `Input` input.\n3. Run the graph. The `Embedding` output of the Get Embedding Node should contain the vector embedding for the input text.\n\n![Get Embedding Node Example 1](./assets/get-embedding-node-example-01.png)\n\n## Error Handling\n\nThe Get Embedding Node will error if the integration is not available in the context when the graph is being run. It will also error if the `Input` input is not provided.\n\n## FAQ\n\n**Q: What is an embedding?**\n\nA: An embedding is a numerical representation of a piece of text. Embeddings are useful for performing K-nearest neighbor search, which is a common operation in AI applications.\n\n**Q: Can I use my own integration?**\n\nA: Yes, you can use your own integration by passing it to the context when the graph is being run. The integration must implement the `EmbeddingGenerator` interface, which includes a method for generating an embedding.\n\n## See Also\n\n- [Vector Store Node](./vector-store.mdx)\n- [Vector KNN Node](./vector-knn.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Text Node](./text.mdx)\n- [Array Node](./array.mdx)\n- [Object Node](./object.mdx)\n"]},{"id":"fkURrezbhGF1MgkIoIotc","data":["knn-dataset.mdx","---\nid: knn-dataset\ntitle: KNN Dataset Node\nsidebar_label: KNN Dataset\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![KNN Dataset Node Screenshot](./assets/knn-dataset-node.png)\n\n## Overview\n\nThe KNN (K-Nearest Neighbors) Dataset Node is used to find the k nearest neighbors in a dataset given an embedding. This node is particularly useful when you want to find the most similar items in a dataset to a given item.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title      | Data Type | Description                                                                                                                   | Default Value                                               | Notes                                                          |\n| ---------- | --------- | ----------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------- |\n| Embedding  | `object`  | The embedding to use as the reference point for finding the nearest neighbors.                                                | (required)                                                  |                                                                |\n| Dataset ID | `string`  | The ID of the dataset to search for the nearest neighbors. This input is only available if `Use Dataset ID Input` is enabled. | (required if if the input toggle for Dataset ID is enabled) | The input will be coerced into a string if it is not a string. |\n| K          | `number`  | The number of nearest neighbors to find. This input is only available if `Use K Input` is enabled.                            | (required if if the input toggle for K is enabled)          | The input will be coerced into a number if it is not a number. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title             | Data Type  | Description                                                                                                      | Notes                                                                                                                              |\n| ----------------- | ---------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| Nearest Neighbors | `object[]` | An array of the k nearest neighbors. Each object in the array contains the ID, distance, and data of a neighbor. | The output will be an array of objects. Each object represents a neighbor and contains the ID, distance, and data of the neighbor. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ---------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Dataset | The ID of the dataset to search for the nearest neighbors. | (required)    | Yes              | `string`        |\n| K       | The number of nearest neighbors to find.                   | 5             | Yes              | `number`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Find the nearest neighbors in a dataset\n\n1. First, in the [Data Studio](../user-guide/features/data-studio.md), create a new dataset with the name `Employees`.\n2. In a new graph, add an [Append to Dataset Node](./append-to-dataset.mdx) and set the Dataset ID to `Employees`.\n3. Add a [Text Node](./text.mdx) and set the value to `John Doe`. We will be getting an embedding for this text node.\n4. Add a [Get Embedding Node](./get-embedding.mdx) and connect the Text Node to it. Connect the `Embedding` output of the Get Embedding Node to the `Embedding` input of the Append to Dataset Node.\n5. Connect the Text Node to the `Data` input of the Append to Dataset Node.\n6. Run the graph. This will append \"John Doe\" and its embedding to the `Employees` dataset.\n7. Change the value of the Text Node to `Jane Doe` and run the graph again. This will append \"Jane Doe\" and its embedding to the `Employees` dataset.\n\n![KNN Dataset Node Example 1](./assets/knn-dataset-node-example-01.png)\n\n1. Next, create a new graph with a KNN Dataset Node and set the Dataset ID to `Employees` and K to 1.\n2. Add a [Text Node](./text.mdx) and set the value to `Jane`. We will be finding the nearest neighbor to this text node.\n3. Add a [Get Embedding Node](./get-embedding.mdx) and connect the Text Node to it. Connect the `Embedding` output of the Get Embedding Node to the `Embedding` input of the KNN Dataset Node.\n4. Run the graph. This will find the nearest neighbor to \"Jane\" in the `Employees` dataset, which is \"Jane Doe\".\n\n![KNN Dataset Node Example 1](./assets/knn-dataset-node-example-01-2.png)\n\n## Error Handling\n\nThe KNN Dataset Node will error if the dataset provider is not available in the context when the graph is being run. It will also error if the `Embedding` input is not provided.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Is there any way to get the nearest neighbors without using a dataset?**\n\nYou can use the [Vector KNN Node](./vector-knn.mdx) to find the nearest neighbors using other integrations, such as Pinecone.\n\n**Q: What happens if the dataset does not exist?**\n\nA: If the dataset does not exist, the KNN Dataset Node will error.\n\n## See Also\n\n- [Load Dataset Node](./load-dataset.mdx)\n- [Create Dataset Node](./create-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [Append to Dataset Node](./append-to-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n- [Vector KNN Node](./vector-knn.mdx)\n"]},{"id":"0ScPc--4-1zPUoZyVkevC","data":["slice.mdx","---\nid: slice\ntitle: Slice Node\nsidebar_label: Slice\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Slice Node Screenshot](./assets/slice-node.png)\n\n## Overview\n\nThe Slice Node is used to extract a portion of an array. It takes an array as input and outputs a new array that starts at a specified index and contains a specified number of elements.\n\nThis node is useful for manipulating arrays, such as extracting a subset of data from a larger dataset.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                                     | Default Value | Notes                                                                                  |\n| ----- | --------- | ----------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------- |\n| Input | `any[]`   | The array to be sliced.                                                                         | (required)    | The input will be coerced into an array if it is not an array.                         |\n| Start | `number`  | The index at which to start the slice.                                                          | 0             | The input will be coerced into a number if it is not a number.                         |\n| Count | `number`  | The number of elements to include in the slice. If not provided, all elements will be included. | (all)         | The input will be coerced into a number if it is not a number. This input is optional. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description       | Notes                                                                            |\n| ------ | --------- | ----------------- | -------------------------------------------------------------------------------- |\n| Output | `any[]`   | The sliced array. | The output will be an array containing the sliced elements from the input array. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description                                                                                     | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ----------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Start   | The index at which to start the slice. If not provided, the slice will start at the beginning.  | 0             | Yes              | `number`        |\n| Count   | The number of elements to include in the slice. If not provided, all elements will be included. | (all)         | Yes              | `number`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Slice an array\n\n1. Create an [Array Node](./array.mdx) and set the values to `[1, 2, 3, 4, 5]`.\n2. Create a Slice Node and set the `Start` to `2` and the `Count` to `2`.\n3. Connect the Array Node to the `Input` of the Slice Node.\n4. Run the graph. The `Output` of the Slice Node should be `[3, 4]`.\n\n![Slice Node Example 1](./assets/slice-node-example-01.png)\n\n## Error Handling\n\nThe Slice Node will error if the `Input` is not provided or is not an array. It will also error if the `Start` or `Count` is not a number.\n\n## FAQ\n\n**Q: What happens if the `Start` is greater than the length of the array?**\n\nA: The Slice Node will return an empty array.\n\n**Q: What happens if the `Count` is greater than the number of elements in the array?**\n\nA: The Slice Node will return all elements from the `Start` to the end of the array.\n\n**Q: Can I use negative numbers for the `Start` and `Count`?**\n\nA: Yes, you can use negative numbers for the `Start` to count from the end of the array. However, using a negative number for the `Count` will result in an error.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Code Node](./code.mdx)\n- [Split Text Node](./split-text.mdx)\n- [Join Node](./join.mdx)\n"]},{"id":"CKnx3h3e1npOIICk1gOlb","data":["if.mdx","---\nid: if\ntitle: If Node\nsidebar_label: If\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Overview\n\nTakes in a condition and a value. If the condition is truthy, the value is passed through the True port, and the False port is not ran.\nIf the condition is falsy, the value is passed through the False port, and the True port is not ran.\n\n![If node screenshot](./assets/if-node.png)\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type   | Description                                          | Required |     |\n| ----- | ----------- | ---------------------------------------------------- | -------- | --- |\n| If    | conditional | The condition you would like to check.               | True     |\n| Value | any         | The value passed through either True or False ports. | True     |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type       | Description                                  |\n| ----- | --------------- | -------------------------------------------- |\n| True  | type of `Value` | Returns the Value if the condition is True.  |\n| False | type of `Value` | Returns the Value if the condition is False. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node does not have any specific settings.\n\n</TabItem>\n\n</Tabs>\n\n### Example 1: Simple `string` comparison\n\n- Let's say we're trying to build a simple string comparison. The code for which in Typscript would look something like below:\n\n```\nif('Hello, World!' === 'Not Hello, World!')\n```\n\n- Similarly in Rivet we can make the following graph to perform a similar comparison.\n\n![if-node-example-1](./assets/if-node-example.png)\n\n1. Create the following nodes in your graph:\n   - An `If` node\n   - A `Compare` node\n   - Two `Input Text` nodes: System Text and Input Text\n   - Two `Graph Output` nodes: True Output and False Output\n2. Connect the following nodes:\n   - System Text `Output` to `A` of the Compare node and `Value` of the If node\n   - Input Text `Output` to `B` of the Compare node\n     - Make sure the Compare condition is set at `==`\n   - If Node `True` to True Output\n   - If Node `False` to False Output\n3. You are ready to run the graph\n4. Results: You'll see that based on the Input Text, and the comparison we've supplied to the If node, the graph output execution changes.\n   If the If condition supplied to the node is true, the true port receives the value but if its false, the false port receives the values.\n"]},{"id":"v9Vn8bbne1S3pIEHZSj7_","data":["object.mdx","---\nid: object\ntitle: Object Node\nsidebar_label: Object\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Object Node Screenshot](./assets/object-node.png)\n\n## Overview\n\nThe Object Node allows you to create an object from input values and a JSON template. The node automatically escapes the input values and inserts them into the template.\n\nThis node is particularly useful for creating objects from multiple inputs. It supports any data type as input and outputs an object.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title     | Data Type | Description                                                                                        | Default Value | Notes                                                                                                                |\n| --------- | --------- | -------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------------------------------------- |\n| (Dynamic) | `any`     | The input values to be inserted into the JSON template. The input names are dynamically generated. | N/A           | The input will be coerced into a string if it is not a string. The input names are extracted from the JSON template. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title  | Data Type | Description                                                     | Notes |\n| ------ | --------- | --------------------------------------------------------------- | ----- |\n| Output | `object`  | The object created from the input values and the JSON template. |       |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting       | Description                                                                                         | Default Value            | Use Input Toggle | Input Data Type |\n| ------------- | --------------------------------------------------------------------------------------------------- | ------------------------ | ---------------- | --------------- |\n| JSON Template | The JSON template to be used for creating the object. Input values are inserted into this template. | `{ \"key\": \"{{input}}\" }` | No               | `string`        |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Creating an object from multiple inputs\n\n1. Create an Object Node and set the JSON Template to the following:\n\n   ```json\n   {\n     \"name\": \"{{name}}\",\n     \"age\": {{age}},\n     \"job\": \"{{job}}\"\n   }\n   ```\n\n2. Create two Text Nodes and set their values to `John Doe` and `Engineer` respectively. Connect them to the `name` and `job` inputs of the Object Node.\n3. Create a Number Node and set its value to `30`. Connect it to the `age` input of the Object Node.\n4. Run the graph. The `Output` of the Object Node should be the following object:\n\n   ```json\n   {\n     \"name\": \"John Doe\",\n     \"age\": 30,\n     \"job\": \"Engineer\"\n   }\n   ```\n\n![Object Node Example 1](./assets/object-node-example-01.png)\n\n## Error Handling\n\nThe Object Node will error if the JSON Template is not a valid JSON string or if the interpolated JSON string (after inserting the input values) is not a valid JSON string.\n\n## FAQ\n\n**Q: Can I use the Object Node to create an array?**\n\nA: Yes, you can use the Object Node to create an array by setting the JSON Template to a valid JSON array string. For example:\n\n```json\n[\"{{value1}}\", \"{{value2}}\", \"{{value3}}\"]\n```\n\n**Q: How are the input values escaped?**\n\nA: The input values are automatically escaped by the Object Node. If the input value is a string, it is escaped using `JSON.stringify()`. If the input value is not a string, it is first converted to a string using `JSON.stringify()` and then escaped.\n\n## See Also\n\n- [Array Node](./array.mdx)\n- [Text Node](./text.mdx)\n- [Extract Object Path Node](./extract-object-path.mdx)\n- [Extract JSON Node](./extract-json.mdx)\n- [Extract YAML Node](./extract-yaml.mdx)\n- [To JSON Node](./to-json.mdx)\n- [Code Node](./code.mdx)\n"]},{"id":"ni_rY9qIcwAaJYdUueKad","data":["read-file.mdx","---\nid: read-file\ntitle: Read File Node\nsidebar_label: Read File\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Read File Node Screenshot](./assets/read-file-node.png)\n\n## Overview\n\nThe Read File Node is used to read the contents of a specified file from the file system and output it as a string.\n\nIf you are using the Rivet SDK, this node requires a native API to be available in the context when the graph is being run. The native API is responsible for providing the functionality to read the contents of a directory.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description                                                                                            | Default Value | Notes                                                          |\n| ----- | --------- | ------------------------------------------------------------------------------------------------------ | ------------- | -------------------------------------------------------------- |\n| Path  | `string`  | The path of the file to read. This input is only available if `Use Path Input` is enabled in settings. | N/A           | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title   | Data Type | Description                                            | Notes                                                                                                    |\n| ------- | --------- | ------------------------------------------------------ | -------------------------------------------------------------------------------------------------------- |\n| Content | `string`  | The contents of the file read from the specified path. | If the file does not exist and `Error On Missing File` is disabled, this output will be an empty string. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting               | Description                                                                                                                               | Default Value | Use Input Toggle | Input Data Type |\n| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ------------- | ---------------- | --------------- |\n| Path                  | The path of the file to read.                                                                                                             | (required)    | Yes              | `string`        |\n| Use Path Input        | If enabled, the path can be provided via the Path input port.                                                                             | False         | No               | N/A             |\n| Error On Missing File | If enabled, the node will error if the file does not exist. If disabled, the node will output an empty string if the file does not exist. | False         | No               | N/A             |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Read a file from a specified path\n\n1. Create a Read File Node and set the `Path` to the path of the file you want to read.\n2. Run the graph. The `Content` output of the Read File Node should contain the contents of the file.\n\n![Read File Node Example 1](./assets/read-file-node-example-01.png)\n\n## Example 2: Read a file from a dynamic path\n\n1. Create a [Text Node](./text.mdx) and set the text to the path of the file you want to read.\n2. Create a Read File Node and enable the `Use Path Input` setting.\n3. Connect the Text Node to the `Path` input of the Read File Node.\n4. Run the graph. The `Content` output of the Read File Node should contain the contents of the file.\n\n![Read File Node Example 2](./assets/read-file-node-example-02.png)\n\n## Error Handling\n\nThe Read File Node will error if the native API is not available in the context when the graph is being run. It will also error if the file does not exist and the `Error On Missing File` setting is enabled. If the file does not exist and the `Error On Missing File` setting is disabled, the node will output an empty string.\n\n## FAQ\n\n**Q: What is a native API?**\n\nA: A native API is an object that is responsible for providing native functionality to nodes. It is passed to the context when the graph is being run. The native API must implement the `NativeApi` interface, which includes methods for reading directories, reading and writing files, and other native operations. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I read a file from a URL?**\n\nA: No, the Read File Node can only read files from the local file system. If you want to read a file from a URL, you can use the [HTTP Call Node](./http-call.mdx) to make a GET request to the URL.\n\n**Q: Can I read a file in a different format, like CSV or XML?**\n\nA: The Read File Node will always output the contents of the file as a string. If you want to parse the contents of the file, you can use other nodes like the [Extract JSON](./extract-json.mdx), [Extract YAML](./extract-yaml.mdx), and the [Code Node](./code.mdx) to parse the contents of the file.\n\n## See Also\n\n- [HTTP Call Node](./http-call.mdx)\n- [Text Node](./text.mdx)\n"]},{"id":"8xJAbzPgWS3vxMKXGD2DI","data":["_template.mdx","---\nid: ID\ntitle: NAME Node\nsidebar_label: NAME\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![NAME Node Screenshot]()\n\n## Overview\n\nMAIN OVERVIEW\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title | Data Type | Description | Default Value | Notes |\n| ----- | --------- | ----------- | ------------- | ----- |\n| TITLE | DATA_TYPE | DESCRIPTION | DEFAULT_VALUE | NOTES |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title | Data Type | Description | Notes |\n| ----- | --------- | ----------- | ----- |\n| TITLE | DATA_TYPE | DESCRIPTION | NOTES |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\n| Setting | Description | Default Value | Use Input Toggle | Input Data Type |\n| ------- | ----------- | ------------- | ---------------- | --------------- |\n| SETTING | DESCRIPTION | DEFAULT_VALUE | USE_INPUT_TOGGLE | INPUT_DATA_TYPE |\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: EXAMPLE\n\nEXAMPLE 1 HERE\n\n## Error Handling\n\nERROR_HANDLING_HERE\n\n## FAQ\n\n**Q: QUESTION?**\n\nA: ANSWER\n\n## See Also\n"]},{"id":"ZNhFQte31MZLHUyT2V6uN","data":["create-dataset.mdx","---\nid: create-dataset\ntitle: Create Dataset Node\nsidebar_label: Create Dataset\n---\n\nimport Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n![Create Dataset Node Screenshot](./assets/create-dataset-node.png)\n\n## Overview\n\nThe Create Dataset Node is used to create a new dataset with a specified ID and name. If a dataset with the specified ID already exists, the node does nothing. This node is particularly useful when you want to create a new dataset for storing or processing data.\n\nMultiple datasets can have the same name, but IDs are unique across all datasets. The ID is used to identify the dataset when loading, appending, or deleting data. If the `Dataset ID` input is not provided, the node will automatically generate an ID for the dataset.\n\nIf the `Dataset Name` input is not provided, the node will use the `Dataset ID` as the name.\n\nThe node requires a dataset provider to be available in the context when the graph is being run. The dataset provider is responsible for managing the storage and retrieval of datasets. In the Rivet application, the dataset provider is handled for you automatically.\n\nFor more information on datasets, see the [Data Studio](../user-guide/features/data-studio.md) section of the user guide.\n\n<Tabs\n  defaultValue=\"inputs\"\n  values={[\n    {label: 'Inputs', value: 'inputs'},\n    {label: 'Outputs', value: 'outputs'},\n    {label: 'Editor Settings', value: 'settings'},\n  ]\n}>\n\n<TabItem value=\"inputs\">\n\n## Inputs\n\n| Title        | Data Type | Description                                                                                      | Default Value             | Notes                                                          |\n| ------------ | --------- | ------------------------------------------------------------------------------------------------ | ------------------------- | -------------------------------------------------------------- |\n| Dataset ID   | `string`  | The ID of the dataset to be created.                                                             | (automatically generated) | The input will be coerced into a string if it is not a string. |\n| Dataset Name | `string`  | The name of the dataset to be created. If not provided, the Dataset ID will be used as the name. | (dataset ID)              | The input will be coerced into a string if it is not a string. |\n\n</TabItem>\n\n<TabItem value=\"outputs\">\n\n## Outputs\n\n| Title      | Data Type | Description                             | Notes                                                                                                                  |\n| ---------- | --------- | --------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |\n| Dataset ID | `string`  | The ID of the dataset that was created. | The output will be the same as the Dataset ID input, or the automatically-generated ID if the input was not connected. |\n\n</TabItem>\n\n<TabItem value=\"settings\">\n\n## Editor Settings\n\nThis node has no configurable editor settings.\n\n</TabItem>\n\n</Tabs>\n\n## Example 1: Create a new dataset\n\n1. Create a [Text Node](./text.mdx) and set the text to `employees`.\n2. Create another Text Node and set the text to `Employees`.\n3. Create a Create Dataset Node and connect the first Text Node to the `Dataset ID` input, and the second Text Node to the `Dataset Name` input.\n4. Run the graph. The `Dataset ID` output of the Create Dataset Node should contain the ID of the new dataset that was created.\n\n![Create Dataset Node Example 1](./assets/create-dataset-node-example-01.png)\n\n## Error Handling\n\nThe Create Dataset Node will error if the dataset provider is not available in the context when the graph is being run. It will also error if the `Dataset ID` input is not provided.\n\n## FAQ\n\n**Q: What is a dataset provider?**\n\nA: A dataset provider is an object that is responsible for managing the storage and retrieval of datasets. It is passed to the context when the graph is being run. The dataset provider must implement the `DatasetProvider` interface, which includes methods for getting, putting, and deleting datasets. See the [API Reference](../api-reference.md) for more information.\n\n**Q: Can I create multiple datasets at once?**\n\nA: No, the Create Dataset Node can only create one dataset at a time. If you want to create multiple datasets, you can use multiple Create Dataset Nodes.\n\n**Q: What happens if the dataset already exists?**\n\nA: If the dataset already exists, the Create Dataset Node will do nothing and the graph will continue to run. The dataset's ID will be outputted from the node. This is useful for ensuring that a dataset exists before loading or appending data to it.\n\n## See Also\n\n- [Append to Dataset Node](./append-to-dataset.mdx)\n- [Load Dataset Node](./load-dataset.mdx)\n- [Get All Datasets Node](./get-all-datasets.mdx)\n- [KNN Dataset Node](./knn-dataset.mdx)\n- [Get Dataset Row Node](./get-dataset-row.mdx)\n"]}]}}]}